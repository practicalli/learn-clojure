{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learning Clojure","text":"<p>Clojure is an elegant programming language for a more civilized development experience.</p> <p>Clojure encourages the creation of simple software systems using immutable values and a pragmatic approach to pure functional design.</p> <p>The aim of Learning Clojure is to cover the essentials required to start a journey into the Clojure programming language.</p> <p>Patients, Practice and Time</p> <p>Learning any programming language takes a lot of patients, practice and time to feel comfortable.</p> <p> Practicalli recommended Clojure Learning Path </p> <p>Clojure Concepts</p>"},{"location":"#navigate-the-book","title":"Navigate the book","text":"<p>Use the mouse or built-in key bindings to navigate the pages of the book</p> <ul> <li>P , , : go to previous page</li> <li>N , . : go to next page</li> </ul> <p>Use the search box to quickly find a specific topic</p> <ul> <li>F , S , / : open search dialog</li> <li>Down , Up : select next / previous result</li> <li>Esc , Tab : close search dialog</li> <li>Enter : follow selected result</li> </ul>"},{"location":"#resources","title":"Resources","text":"<p> Practicalli Clojure CLI Config - additional tools via aliases Clojure Aware Editors Practicalli YouTube channel</p>"},{"location":"#sponsor-practicalli","title":"Sponsor Practicalli","text":"<p>All sponsorship funds are used to support the continued development of Practicalli series of books and videos, although most work is done at personal cost and time.</p> <p>Thanks to Cognitect, Nubank and a wide range of other sponsors from the Clojure community for your continued support</p>"},{"location":"#creative-commons-license","title":"Creative commons license","text":"This work is licensed under a Creative Commons Attribution 4.0 ShareAlike License (including images &amp; stylesheets)."},{"location":"#external-resources","title":"External Resources","text":"<ul> <li>Clojure Cookbook</li> <li>Clojure Standard Reference</li> <li>Getting Clojure</li> </ul>"},{"location":"adoption/","title":"Adoption","text":"<ul> <li>2013 DevNexus presentation</li> </ul> <p>Clojure is simple by design.  What does that mean, and why should you care?</p> <p>Simplicity is a powerful technique for writing better programs, programs that have:</p> <ul> <li>concision: write programs 5-10x smaller than before</li> <li>robustness: easily write programs that work correctly</li> <li>generality: use the same simple ideas over and over, instead of masses and masses of redundant classes</li> <li>agility: add new capabilities with ease</li> </ul> <p>In this talk, we will introduce Clojure, and introduce Simplicity via concrete examples from</p> <ul> <li>Clojure syntax</li> <li>Clojure protocols</li> <li>Clojure values and references</li> </ul> <p>These ideas (and others) lead to concision, robustness, generality, and agility.</p> <ul> <li>All Things Open</li> </ul>"},{"location":"adoption/#languages-of-the-system","title":"Languages of the System","text":"<p>edn and Fressian are self-describing, schema-free, batteries-included, extensible data languages. In this talk, you will find out where you might benefit from these languages over e.g. JSON or XML.</p> <p>Systems use many languages, and not just programming languages such as Java, C#, Ruby, or Python. Systems also relay on data languages, both for data on the wire, and for data at rest. These data languages differ greatly in their design objectives and capabilities, and are often less understood than their programming language counterparts.</p> <p>This talk will introduce two data notations: edn and Fressian, which share several common characteristics. Both are </p> <ul> <li>self-describing</li> <li>schema-free</li> <li>batteries-included</li> <li>extensible</li> </ul> <p>These capabilities align well with the dynamic, flexible needs of real systems. And in their key difference (text vs. binary), edn and Fressian cover the bases of human readability and maximum performance.</p>"},{"location":"adoption/#perception-and-action","title":"Perception and Action","text":"<p>Perception and action are radically different. Clojure's time model makes it easy to build systems that model the real-world differences between perception and action. In this talk, you will learn how to think using</p> <ul> <li>values: immutable data items, both atomic and composite</li> <li>identities: entities that take a series of causally-related values over time</li> <li>time: a before/after ordering of perceptions and actions</li> <li>references: point-in-time values of an identity</li> </ul> <p>Getting time right is essential for modeling concurrency effectively, but its importance does not stop there. Without a good model of time, it is difficult to deal sensibly with currency and history, much less concurrency and parallelism.</p> <p>The ideas in this talk will help you create better programs that more faithfully model the world, even if you write linear programs that hope to never see a second thread.</p> <ul> <li>Video from QCon SF, Nov 2010</li> </ul>"},{"location":"adoption/#clojurescript","title":"ClojureScript","text":"<p>ClojureScript brings the sophisticated semantics of a world-class production language (Clojure) to the world's dominant deployment platform (JavaScript, especially running in the browser).</p> <p>ClojureScript enables browser development that is cheaper, leaner, and more performant than JavaScript (and \"slightly enhanced JavaScript\" alternatives), and makes it possible to share code between client and server side development.</p> <p>In this talk, we will begin with the semantics of edn and Clojure, and why you might want to build programs with them.  We will then move into areas specific to ClojureScript:</p> <ul> <li>How Clojure's semantics map to JavaScript's capabilities</li> <li>Targeting the Google Closure Compiler for whole-program optimization</li> <li>Bootstrapping Clojure in JavaScript</li> <li>Calling JavaScript libraries</li> <li>Connecting browsers and REPLs</li> <li>Ending callback hell with core.async</li> </ul> <p>Finally, we will put the pieces together, showing substantial browser applications written in ClojureScript, and a brief tour of the Pedestal framework for web applications.</p>"},{"location":"adoption/#clojure-big-ideas","title":"Clojure Big Ideas","text":"<p>The key to understanding Clojure is ideas, not language constructs. In this talk, we will approach Clojure via 10 Big Ideas:</p> <ul> <li>Extensible Data Notation</li> <li>Persistent Data Structures</li> <li>Sequences</li> <li>Transducers</li> <li>Specification</li> <li>Dynamic Development</li> <li>Async Programming</li> <li>Protocols</li> <li>ClojureScript</li> <li>Logic Programming</li> <li>Atomic Succession Model</li> </ul> <p>Each of these ideas is valuable and useful a la carte, and not necessarily only in Clojure. Taken together, they begin to fill in the picture of why Clojure is changing the way many programmers think about software development.</p> <ul> <li>2013 RuPy slides</li> <li>2017 Chicago JUG slides</li> </ul>"},{"location":"adoption/#clojure-web-services-big-ideas","title":"Clojure Web Services Big Ideas","text":"<p>The key to understanding Clojure web development is ideas, not language constructs.</p> <ul> <li>edn, not json</li> <li>core.async, not callbacks </li> <li>platform, not language</li> <li>data, not objects</li> <li>protocols, not interfaces</li> <li>libraries, not frameworks</li> <li>one ring to rule them all</li> </ul> <p>Each of these ideas is valuable and useful a la carte, and not necessarily only in Clojure. Taken together, they begin to fill in the picture of why Clojure is changing the way many programmers think about web development.</p>"},{"location":"adoption/#benefits","title":"Benefits","text":"<p>benefits of Clojure that are immediately visible to beginners:</p> <ul> <li>concision: write programs 5-10x smaller than before</li> <li>robustness: easily write programs that work correctly</li> <li>generality: use the sample simple ideas over and over, instead of masses and masses of redundant classes</li> <li>agility: add new capabilities with ease</li> </ul> <p>That is a powerful story in itself, but the advantages of Clojure increase with expertise.  We will tour just a few of the power tools used Clojure experts:</p> <ul> <li>core.async for communicating sequential processes</li> <li>transducers for programmable algorithmic transformations</li> <li>PigPen for big data map/reduce</li> <li>Datomic for flexible, ACID data of record</li> </ul> <p>Finally, we will look at what everybody else is saying, reporting on business and open source projects using Clojure. </p> <ul> <li>Slides from Nov 2014</li> </ul> <p> </p>"},{"location":"adoption/#clojure-specifications","title":"Clojure Specifications","text":"<p>Engineer projects with high agility and end up with a robust, maintainable code. </p> <p>Use Clojure spec library to write programs that behave as expected, meet operational requirements, and have the flexibility to accommodate change.</p> <p>Rapidly develop robust and reusable Clojure projects using</p> <ul> <li>interactive development at the REPL</li> <li>immutable data and pure functions</li> <li>code as data</li> </ul> <p>Clojure spec library augments these approaches. Developing with spec is declarative, predicative, layered, robust, and integrated with Clojure.</p> <p>spec is declarative. As with type systems in static languages, spec lets you make declarative statements that communicate and document data, function arguments, and returns.</p> <p>spec is predicative. You can declare predicates about data, about function arguments and returns, and even function semantics. This overlaps not only with type systems, but also with validations that are often done with costly bespoke tests and runtime checks.</p> <p>spec is layered. Spec does not require any specific workflow or program shape, and in particular is compatible with iterative and incremental development.</p> <p>spec supports robust programs via automatic generative testing. Given specifications, spec can write generative tests for you, generating a volume of tests limited only by your CPU time, not by what you are able to write and maintain by hand.</p> <p>spec is fully integrated with Clojure. As you develop your program, you have interactive access to spec-driven documentation, validation, destructuring, conformance checking, sample data, testing, and program instrumentation.</p> <ul> <li>2016 StrangeLoop video</li> <li>2016 JavaOne slides</li> <li>Spec overview and rationale</li> <li>Spec guide</li> <li>Clojure Made Simple at JavaOne in 2015</li> <li>Clojure Spec: Leverage</li> <li>Clojure Spec: Testing</li> <li>Clojure Spec: Customizing Generators</li> </ul>"},{"location":"adoption/#datomic","title":"Datomic","text":"<p>Codeq imports your Git repositories into a Datomic database, then performs language-aware analysis on them, extending the Git model both down and up:</p> <ul> <li>down, from the textual world of files and lines to the code quantum (codeq) level </li> <li>up, across multiple repositories</li> </ul> <p>This allows you to track change in terms of program units, e.g. function and method definitions, and query your code declaratively. A codeq database can serve as infrastructure for editors, IDEs, code browsing, analysis, and documentation tools.</p> <p>In this talk, you will learn</p> <ul> <li>how to install codeq locally</li> <li>how to import and analyze git repositories</li> <li>how to query your repositories</li> <li>how to extend codeq's builtin analysis with your own custom analyzers</li> </ul> <p>Codeq is open source (EPL), and on github. It works with Datomic Free.</p> <ul> <li>Blog post introducing codeq</li> <li>Codeq on the Relevance Podcast</li> <li>Day of Datomic 2016</li> <li>Day of Datomic Cloud 2018 YouTube playlist Sept. 2018</li> <li>Datomic Ions in 7 minutes</li> </ul>"},{"location":"adoption/#on-the-web","title":"On the Web","text":"<ul> <li>Blog post introducing codeq</li> <li>Codeq on the Relevance Podcast</li> </ul>"},{"location":"adoption/#writing-correct-programs","title":"Writing correct programs","text":"<ul> <li>Slides from May 2018</li> </ul> <p>We have tons of tools and practices to help us write correct programs, including:</p> <ul> <li>red squiggly underlines</li> <li>type systems</li> <li>automated tests</li> <li>proofs</li> <li>generative testing</li> <li>stacktraces</li> <li>frameworks</li> <li>agile methods</li> <li>test-driven development</li> <li>logging</li> <li>humane error messages</li> <li>step debuggers</li> <li>simulation</li> </ul> <p>Net result so far: We invest a lot of time and money, and our programs are still full of bugs.</p> <p>I don't have a silver bullet to offer, nor do I plan to denigrate any of the ideas listed above. But I will say this: I regularly watch programmers aim too large and miss by miles.</p> <p>To aim small is to:</p> <ul> <li>plan ahead and catch misconceptions early before they ramify</li> <li>make small things, at every level</li> </ul> <p>and then plan to miss anyway:</p> <ul> <li>expect failures and make them more evident</li> <li>divide and conquer when things go wrong</li> </ul>"},{"location":"adoption/#architectural-briefings","title":"Architectural Briefings","text":"<p>Developers make decisions all the time, and can never have enough information and support. At Cognitect, we run a weekly Architectural Briefing as a resource for the team.  Everybody participates, both attending and speaking.  In this talk, we will cover</p> <ul> <li>a template for Architectural Briefings</li> <li>how to develop and present an Architectural Briefing </li> <li>how to run an Architectural Briefing program in your organization</li> </ul> <p>We will finish with an example briefing, showing how these ideas come together.</p> <ul> <li>2014 NFJS slides</li> </ul>"},{"location":"adoption/#writing-effective-bug-reports","title":"Writing Effective Bug Reports","text":"<p>https://docs.datomic.com/cloud/tech-notes/writing-a-problem-report.html</p> <p>Presentation</p>"},{"location":"adoption/#conference-talks","title":"Conference Talks","text":""},{"location":"adoption/#keynotes","title":"Keynotes","text":"<ul> <li>[[Aim Small, Miss Small: Writing Correct Programs]]</li> <li>[[Adopting Clojure]]</li> <li>[[Datomic, and How We Built It]]</li> <li>[[Debugging with the Scientific Method]]</li> <li>[[Design after Agile: How to Succeed By Trying Less]]</li> <li>[[Evident Code at Scale]]</li> <li>[[Ousterhout's Dichotomy Isn't]]</li> <li>[[Sherlock Holmes, Consulting Developer]]</li> <li>[[Stewardship Made Practical]]</li> <li>[[Simplicity Ain't Easy]]</li> <li>[[The Impedance Mismatch is Our Fault]]</li> <li>[[Too Lazy To Fail]]</li> <li>[[Pure Fun]]</li> </ul>"},{"location":"adoption/#technical-talks","title":"Technical Talks","text":"<ul> <li>[[Better Bug Reports]]</li> <li>[[Running with Scissors]]: Live Coding with Data</li> <li>[[Datomic Ions]]</li> <li>[[REPL Driven Development]]</li> <li>[[The Ten Rules of Schema Growth]]</li> <li>Simplifying ETL with Clojure &amp; Datomic</li> <li>Agility &amp; Robustness: [[Clojure spec]]</li> <li>[[Datalog 2015]]</li> <li>[[Clojure: Simple By Design]]</li> <li>[[Narcissistic Design]]: 10 easy steps to complex code and job security</li> <li>[[Clojure in 10 Big Ideas]]</li> <li>[[ClojureWeb in 7 Big Ideas]]</li> <li>[[ClojureScript]]</li> <li>[[Core Async]]</li> <li>[[Datomic For The 96 Percent]]</li> <li>[[Architectural Briefings]]</li> <li>[[Simulation Testing]]</li> <li>[[edn and Fressian]]</li> <li>[[Codeq: Making Git Repositories Smarter]]</li> <li>[[Introduction to Clojure]]</li> <li>[[Clojure in the Field]]</li> <li>[[Concurrent Programming with Clojure]]</li> <li>[[Generative Testing]]</li> <li>[[Get Logical with Datalog]]</li> <li>[[Perception and Action]]</li> <li>[[Transit]]</li> </ul>"},{"location":"namespace-design/","title":"Namespace Design","text":"<p>In a small project with only a few developers, things like naming and style conventions don\u2019t matter all that much, because almost everyone has worked with almost all of the code.</p> <p>With larger teams and sizable code bases \u2014 think tens of developers, tens of thousands of lines of Clojure \u2014 there\u2019s a good chance that anyone reading the code has never seen it before. For that reader, a few conventions can be a big help.</p> <p>Optimizing for readability usually means being more verbose. Don\u2019t abbreviate unless you have to.</p> <p>Optimizing for a reader who is not necessarily familiar with the entire code base, or even an entire file. They\u2019ve just jumped to a function definition in their editor, or maybe pulled a line number from a stack trace. They don\u2019t want to take the time to understand how all the different namespaces relate. They especially don\u2019t want to have to scroll to the top of the file just to see where a symbol comes from.</p> <p>So these conventions are about maximizing readability at the level of single function definitions. Yes, it means more typing. But it makes it much easier to navigate a large codebase maintained by multiple people.</p> <p>As a general first rule, make the alias the same as the namespace name with the leading parts removed.</p> <pre><code>(ns com.example.application\n  (:require\n   [clojure.java.io :as io]\n   [clojure.string :as string]))\n</code></pre> <p>Keep enough trailing parts to make each alias unique. Did you know that namespace aliases can have dots in them?</p> <pre><code>[clojure.data.xml :as data.xml]\n[clojure.xml :as xml]\n</code></pre> <p>Eliminate redundant words such as \u201ccore\u201d\u009d and \u201cclj\u201d\u009d in aliases.</p> <pre><code>[clj-http :as http]\n[clj-time.core :as time]\n[clj-time.format :as time.format]\n</code></pre> <p>Use :refer sparingly. It\u2019s good for symbols that have no alphabetic characters, such as &gt;! &lt;! &gt;!! &lt;!! in core.async, or heavily-used macros such those in clojure.test.</p> <p>You can combine :refer and :as in the same :require clause.</p> <pre><code>[clojure.core.async :as async :refer [&lt;! &gt;! &lt;!! &gt;!!]]\n[clojure.test :refer [deftest is]]\n</code></pre>"},{"location":"additional-projects/","title":"Additional Projects","text":"<p>Some guided projects that help you apply many of the ideas learned in the workshop.</p> <ul> <li>Celebrity Name Smash - string manipulation: subs count, take, str, lazy sequence, apply, reduce</li> <li>Clacks messages - simple encoding &amp; decoding of messages, thinking about data structures: maps (key value pairs), get, map reduce  (extension of the map reduce sandwich)</li> <li>Most common word - find the most common word in a book (not including common English language words, like 'the')</li> </ul>"},{"location":"additional-projects/#challenge-build-a-new-clojurebridge-london-website","title":"Challenge: Build a new ClojureBridge London website","text":"<p>Try build a new website for ClojureBridge London and give us ideas of what you would like to see in our website.</p>"},{"location":"additional-projects/#bigger-projects","title":"Bigger projects","text":"<ul> <li>Practicalli, Clojure WebApps - Serverside web application with Ring, Compojure and PostgresQL database</li> <li>Tic-tac-toe game in ClojureScript, reagent and SVG</li> </ul>"},{"location":"additional-projects/celebrity-name-smash/","title":"celebrity-name-smash","text":"<p>Take celebrity names and smash them together to create weird and wonderful gestalt version of them.</p> <p>To understand how this code was created, read the article Clojure Dojo: Celebrity Name Smash - June 2016</p> <p>The June 2016 edition of the London Clojurians coding dojo set the challenge of building a celebrity name smash, taking two \"celebrities\" and smashing their names together to make a weird or amusing gestalt name.</p> <p>For bonus points the challenge would include this celebrity name smash as a service and even more bonus points if using the new <code>clojure.spec</code> library to put specifications around data structures and functions.</p> <p>Bonus points are non-redeemable, sorry!</p> <p>Although our group didn't get get any of the bonus levels, here is the blow by blow development of our code for the Celebrity Name Smash.</p> <p></p>"},{"location":"additional-projects/celebrity-name-smash/#todobreak-the-celebrity-name-smash-challenge-into-several-sections","title":"TODO::Break the celebrity name smash challenge into several sections","text":""},{"location":"additional-projects/celebrity-name-smash/#a-simple-leiningen-project-to-start","title":"A simple leiningen project to start","text":"<p>We created a default Clojure project to start using the following leiningen command</p> <pre><code>lein new celebrity-name-smash\n</code></pre> <p>This created a simple project using Clojure 1.8.0.  If we had chosen to use <code>clojure.spec</code> as well then we would have updated the <code>project.clj</code> file to use Clojure 1.9.x as a dependency instead.</p>"},{"location":"additional-projects/celebrity-name-smash/#modeling-the-celebrities","title":"Modeling the Celebrities","text":"<p>The simplest way to represent a celebrity name is in a string.  So we bound a name called <code>celebrities</code> to a string containing the first celebrity we could think of</p> <pre><code>(def celebrities \"Brad Pitt\")\n</code></pre> <p>As we want to have two celebrities then we changed the data structure into a Clojure vector.  A vector is the most flexible data structure in Clojure.  So we redefined the name <code>celebrities</code> to be bound to a vector of strings containing the first celebrity couple we could think of.</p> <pre><code>(def celebrities [\"Brad Pitt\" \"Angelina Jolie\"])\n</code></pre>"},{"location":"additional-projects/celebrity-name-smash/#splitting-names","title":"Splitting names","text":"<p>Each celebrity has a first and last name, so we need to split them into individual strings first.</p> <p>We decided to exclude celebrities with just a single name.</p> <p>From a quick Google we found the clojure.string/split function that will split a string on a given pattern, that pattern being a regular expression (regex).</p> <pre><code>(clojure.string/split \"Clojure is awesome!\" #\" \")\n\n;; =&gt; [\"Clojure\" \"is\" \"awesome!\"]\n</code></pre> <p>The regular expression pattern <code>\" \"</code> matches the space characters.  We could have also used <code>#\"+s\"</code> for the same results in this example, although it was felt that the space was clearer in intent.</p> <p>So we wrote a function called <code>name-split</code> to take a first and last name as a string and return two separate strings, one for the first name and one for the last name.</p> <pre><code>(defn name-split\n  \"Splits a celebrity name into their first &amp; last names\"\n  [name]\n  (str/split name #\" \"))\n</code></pre> <p>We tested the <code>name-split</code> function in the repl</p> <pre><code>(name-split \"Brad Pitt\")\n\n;; =&gt;[\"Brad\" \"Pitt\"]\n</code></pre> <p>We could now successfully split the full name of a celebrity into their first and last names.</p> <p>A more advanced example of splitting up words would be to use re-seq with a regex patter, as in the HHGTTG book processing example in clojure-through-code.</p>"},{"location":"additional-projects/celebrity-name-smash/#creating-sub-strings-of-names-the-long-way","title":"Creating sub-strings of names the long way","text":"<p>As the aim of our code is to create silly and weird names from celebrity names, we wont get the desired results with just the first and last names.  So we take those and split them.</p> <p>At first we decided to split them in half, rounding down for odd length names.</p> <p>As a Clojure String can be used like a collection of characters, we could simply <code>take</code> the first x number of characters.</p> <pre><code>(take 2 \"Brad\")\n;; =&gt; (\\B \\r)\n</code></pre> <p>The value returned is a list of characters, so we would have to combine them back into a string.  Just using the <code>str</code> function on the result of the <code>take</code> function returned a lazy sequence.  To get a string we needed to <code>apply</code> or <code>reduce</code> with the <code>str</code> function</p> <pre><code>;; (str (take 2 \"Brad\"))\n;; =&gt; \"clojure.lang.LazySeq@c31\"\n\n(apply str (take 2 \"Brad\"))   ;; =&gt; \"Br\"\n(reduce str (take 2 \"Brad\"))  ;; =&gt; \"Br\"\n</code></pre> <p>To do this for a name of any length we would need to <code>count</code> the string characters and divide by 2.</p> <pre><code>(take (/ (count \"Brad\") 2) \"Brad\")\n;; =&gt; (\\B \\r)\n\n(apply str (take (/ (count \"Brad\") 2) \"Brad\"))\n;; =&gt; \"Br\"\n</code></pre> <p>This code also works for names that have an odd number of characters.  When the odd number of characters is divided by two, a Clojure ratio type is used to hold the result rather than return a decimal value.  The <code>take</code> function calculated the value of the ratio type and rounds it to the nearest whole number.</p> <p>Here is a breakdown of how this code works with a name containing an odd number of characters.</p> <pre><code>(count \"Bradley\")\n;; =&gt; 7\n\n(/ (count \"Bradley\") 2)\n;; =&gt; 7/2\n\n(take (/ (count \"Bradley\") 2) \"Bradley\")\n;; =&gt; (\\B \\r \\a \\d)\n\n(apply str (take (/ (count \"Bradley\") 2) \"Bradley\"))\n;; =&gt; \"Brad\"\n</code></pre>"},{"location":"additional-projects/celebrity-name-smash/#creating-sub-strings-the-short-way","title":"Creating sub-strings the short way","text":"<p>After reviewing this code it seemed a little complex for what we wanted, so a quick Google gave us the <code>subs</code> function.  The <code>subs</code> function takes a string and a starting point for the split, with an optional end point</p> <pre><code>(subs \"Brad\" 0 2)\n;; =&gt; \"Br\"\n\n(subs \"Brad\" 2)\n;; =&gt; \"ad\"\n\n(subs \"Bradley\" 0 (/ (count \"Bradley\") 2))\n;; =&gt; \"Bra\"\n</code></pre> <p>So when we want the first part of the name we give the <code>subs</code> function a start point and an end point for the sub-division.  For the last part of a name we simply give the start point for the sub-division.</p> <p>Hint If the <code>take</code> or <code>subs</code> function did not deal with odd numbers of characters, then instead of dividing by 2 we could have used the <code>quot</code> function.  The <code>quote</code> function divides the first argument by the second argument, returning the result as a whole number.</p>"},{"location":"additional-projects/celebrity-name-smash/#creating-a-subname-function-for-the-first-name","title":"Creating a subname function for the first name","text":"<p>We created a function that takes the name as a argument and returns the substring for the first half of the name</p> <pre><code>(defn first-celeb-subname [name]\n  (let [end (/ (count name) 2)]\n    (subs name 0 end)))\n\n;; calling the function with an odd length name\n(first-celeb-subname \"Bradley\")\n;; =&gt; \"Bra\"\n</code></pre> <p>We used the <code>let</code> function to create a local name (symbol) called <code>end</code> that points to the end position in the string, based on dividing the name by 2.  Then we call the <code>subs</code> function to get the substring from 0 to the value of <code>end</code>.</p>"},{"location":"additional-projects/celebrity-name-smash/#creating-a-more-random-sub-name-function","title":"Creating a more random sub-name function","text":"<p>Just talking the half way point for our substring only gives one result.  If we add a random element to creating our substring then we should get many more variations in results.</p> <pre><code>(defn first-celeb-subname [name]\n  (let [end (+ 1 (rand-int (count name)))]\n    (subs name 0 end)))\n</code></pre> <p>A slight refinement can be made by replacing <code>+ 1</code> with the <code>inc</code> function</p> <pre><code>(defn first-celeb-subname [name]\n  (let [end (inc (rand-int (count name)))]\n    (subs name 0 end)))\n</code></pre>"},{"location":"additional-projects/celebrity-name-smash/#a-subname-function-for-the-second-celebrity","title":"A subname function for the second celebrity","text":"<p>We wanted to combine two first names and two last names to make a new first &amp; last name.  So we need a similar function to create the lastname subname</p> <pre><code>(defn last-celeb-subname [name]\n  (let [start (inc (rand-int (count name)))]\n    (subs name start)))\n</code></pre> <p>This function is almost identical to the first function, however only a start position is provided to <code>subs</code> function, creating a substring from the <code>start</code> position to the end of the name.</p>"},{"location":"additional-projects/celebrity-name-smash/#putting-it-all-together","title":"Putting it all together","text":"<p>Finally we call these functions from a main function named <code>celeb-name-smash</code>, which takes two celebrity names as string arguments and returns a string containing the smashed name.</p> <pre><code>(defn celeb-name-smash\n  \"Smashes to celebrity names together\"\n  [celeb-one celeb-two]\n  (str (first-celeb-subname (first (name-split celeb-one)))\n       (second-celeb-subname (first (name-split celeb-two)))\n       \" \"\n       (first-celeb-subname (last (name-split celeb-one)))\n       (second-celeb-subname (last (name-split celeb-two)))))\n\n;; call the celeb-name-smash function with example data\n(name-smash-strings \"Brad Pitt\" \"Angelina Jolie\")\n;; =&gt; \"Brana Pitie\"\n;; =&gt; \"Brelina Pie\"\n;; =&gt; \"Brelina Piolie\"\n;; =&gt; \"Brlina Pi\"\n</code></pre> <p>The <code>celeb-name-smash</code> function has a lot of duplication, so should probably be refactored to make it more elegant.  However, we ran out of time at the dojo, so I will have a look at refactoring this function as homework.</p> <p>T</p>"},{"location":"additional-projects/clacks-messages/","title":"Clacks Messages - encoding and decoding text messages","text":"<p>At the March 2016 London Clojurians code dojo at uSwitch our group created a Clacks Interpreter in honor of Terry Pratchett, the author of the amazing Discworld series of books (and a few TV shows of those books too).</p> <p>In the 33rd Discworld novel called Going Postal, messages are sent faster than a speeding horse via the Clacks system.  This composes of a series of towers that cross a continent and pass messages on via combinations of lights.  Each tower sees a grid of lights from a distant tower and sends the message on to the next tower.</p> <p>The Clacks system was actually introduced in the 24th Discworld novel called \"The Fifth Elephant\", however its the \"Going Postal\" book where we learn the full history of the Clacks system.</p> <p>We created a Clacks Interpreter that converts any English message into its corresponding clacks signal, based on the Clacks alphabet as defined by the board game of the same name.  The board game defines the alphabet as a 2 by 3 grid (although in the Discworld its actually 8 large squares).  Naturally, the interpreter also converts the Clacks signal back into an English message too.</p> <p></p> <p>The code is available on Github at: https://github.com/liamjtaylor/clacks-messenger and read on for a walk through of how we came up with the solution.</p>"},{"location":"additional-projects/clacks-messages/#todocovert-clacks-messages-into-multiple-pages","title":"TODO::Covert clacks messages into multiple pages","text":""},{"location":"additional-projects/clacks-messages/#the-challenge","title":"The Challenge","text":"<p>We wanted to be able to take any English language messages and transmit it across the clacks network, then</p>"},{"location":"additional-projects/clacks-messages/#representing-a-clack","title":"Representing a Clack","text":"<p>For each clack, we read the pattern from the top of the first column to the bottom, then from the top of the second column to the bottom.  A light in a position represents a 1 value and no light represents a 0 value.  This gives us our 6 number pattern for each clack in the alphabet.</p>"},{"location":"additional-projects/clacks-messages/#deciding-the-data-structure","title":"Deciding the data structure","text":"<p>The initial data structure chosen was essentially just modelling each individual clack.  Since a clack is a 2x3 structure, the simplest way to represent a clacks is to have a vector that contains 2 vectors, each with three elements.</p> <p>So a simple expression of the letter a in the clacks alphabet would be:</p> <p><pre><code>[[0 1 0][0 0 1]]\n</code></pre> Therefore we could define a single letter of our alphabet as follows:</p> <pre><code>(def a [[0 1 0][0 0 1]])\n</code></pre> <p>Before we define the complete alphabet using this data structure, lets test if we have the right data structure for our conversion process.</p>"},{"location":"additional-projects/clacks-messages/#testing-a-simple-conversion-with-our-data-structure","title":"Testing a simple conversion with our data structure","text":"<p>Lets try the simplest way to convert a character into a clack:</p> <pre><code>(defn character-&gt;clack [character]\n  (if (= character \"a\")\n    a\n    (str \"Sorry, character is not yet in the alphabet, please create a pull request\")))\n</code></pre> <p>Calling the function converts a string into the corresponding clack</p> <pre><code>(character-&gt;clack \"a\")\n</code></pre> <p>Although the code is simple for 1 character, it does highlight the problem of converting the whole alphabet.  We would need either a deeply nested set of if statements or a very long case statement, neither of which seems to be a particularly functional approach or idiomatic Clojure.</p> <p>Even if we did use a case statement, how would we convert a clack back into a character?</p> <p>So perhaps we need to change the data structure, one that provides an easy way to map to values together.</p> <p>Also, there seems no value in mapping values to a 2x3 grid as long as we consistently express a clack.</p>"},{"location":"additional-projects/clacks-messages/#defining-the-alphabet-with-a-map","title":"Defining the alphabet with a map","text":"<p>A map data structure in Clojure is a hash map (a key &amp; value paring) for example I could define myself as a map</p> <pre><code>{:name \"john\" :age \"21\" :twitter \"jr0cket\"}\n</code></pre> <p>Its very common to use Clojure keywords for the keys, to make it easy to look up a particular value by referring to the keyword.</p> <p>So the new design for our clacks data structure is as follows</p> <pre><code>{:a [0 1 0 0 0 1]}\n</code></pre> <p>To help with testing this new data structure design, we crated enough letters of the clacks alphabet to make some simple words, i.e bat</p> <pre><code>(def alphabet {:a [0 1 0 0 0 1]\n               :b [0 0 1 0 1 0]\n               :t [1 0 0 1 1 1]})\n</code></pre>"},{"location":"additional-projects/clacks-messages/#testing-the-map-design","title":"Testing the map design","text":"<p>We can use the keyword to lookup the value of its clack code</p> <pre><code>(alphabet :a)\n\n;; =&gt; [0 1 0 0 0 1]\n</code></pre> <p>Then we created a simple function to convert a string to a sequence of clacks</p> <pre><code>(defn character-&gt;clack [letter]\n  (if (= letter \"a\")\n    (alphabet :a)\n    (str \"Sorry, character is not yet in the alphabet, please create a pull request\")))\n</code></pre> <p>The <code>-&gt;</code> character is part of the function name.  This is a Clojure naming convention used when the function you are defining converts from one type to another.</p> <p>And call the function as follows</p> <pre><code>(character-&gt;clack \"a\")\n\n;; =&gt; [0 1 0 0 0 1]\n</code></pre>"},{"location":"additional-projects/clacks-messages/#converting-a-word","title":"Converting a word","text":"<p>Now we want to convert a whole word to a clacks sequence.  It seemed the easiest way to convert a whole word was to convert each letter at a time using the map to look up each clack code, returning all the clacks codes in a sequence.</p> <p>So we redefined the <code>string-&gt;clacks</code> function to take in a whole word.</p> <p>We used the <code>map</code> function to apply a conversion function over each element in the word (each element of the string).  This conversion function called <code>clacksify</code>.</p> <pre><code>(defn clacksify [letter]\n  (let [character (str letter)]\n  (alphabet (keyword character))))\n\n(defn string-&gt;clacks [word]\n  (map clacksify word))\n</code></pre> <p>Now we could convert any word that used the letters of our limited alphabet.  We chose bat as a simple word.</p> <pre><code>(string-&gt;clacks \"bat\")\n</code></pre> <p>As we are passing a string and not a keyword to the <code>clacksify</code> function, then we first convert the string to a keyword using the <code>keyword</code> function.</p>"},{"location":"additional-projects/clacks-messages/#converting-the-clack-to-a-string","title":"Converting the clack to a string","text":"<p>Is there a simple way to look up a key given a value that is unique in the map?</p> <p>All Clack codes are unique in the map, but there did not seem to be a simple expression to find the key when given a value.</p> <p>We could have created a second mapping, however having two maps seemed redundant and a potential cause for silly bugs.</p> <p>The answer was simple once we found it.  As the clack codes are unique, they could be used as keys for the letter values, we just needed to swap the map around.  Swapping a map's keys and values was done by writing a <code>reverse-map</code> function.</p> <pre><code>(defn reverse-map\n  \"Reverse the keys and value pairs in a map.\n  Allows the map to be used to convert from a clack to a letter without defining a second map\"\n  [m]\n  (into {} (map (fn [[a b]] [b a]) m)))\n</code></pre> <p>So we defined the function <code>declacksify</code> which takes a clack code and returns its corresponding character.  The clack code returns the corresponding keyword rather than a character, so we use the <code>name</code> function to convert the keyword into a character name.</p> <pre><code>(defn declacksify [clack]\n  (name ((reverse-map alphabet) clack)))\n\n(defn clacks-&gt;string [clacks]\n  (map declacksify clacks))\n</code></pre> <p>So calling these functions with a clacks</p> <pre><code>(declacksify  [1 0 0 1 1 1])\n;; =&gt; \"t\"\n\n(clacks-&gt;string [[0 0 1 0 1 0] [0 1 0 0 0 1] [1 0 0 1 1 1]])\n;; =&gt; (\"b\" \"a\" \"t\")\n</code></pre> <p>Its probably at this point we should have realised that we didn't need to use keywords to represent the characters of the alphabet.  In fact, using keywords made a little more work for us.</p>"},{"location":"additional-projects/clacks-messages/#tyding-up-the-output","title":"Tyding up the output","text":"<p>Our <code>clacks-&gt;string</code> function returns the right result, but not quite in the format we want.  Rather than a single string, we get the individual characters.</p> <p>Using the <code>reduce</code> function we can apply the <code>str</code> function over the resulting characters to give a single string.  So our function becomes</p> <pre><code>(defn clacks-&gt;string [clacks]\n(map str (map declacksify clacks)))\n</code></pre>"},{"location":"additional-projects/clacks-messages/#working-with-another-language","title":"Working with another language","text":"<p>Thanks to a flexible design with no side effects or side causes then its really easy to replace the English language alphabet with another language that can be encoded into Clack codes.  So languages based on the greek, latin or cyrillic alphabet could be send if a suitable alphabet with clack codes is supplied.</p>"},{"location":"additional-projects/clacks-messages/#summary","title":"Summary","text":"<p>We were quite happy with the code produced in this dojo.  The code is pretty readable we believe and we have taken a fairly simple approach to the design.  In hindsight we could have made the code even easier if we had tested out the map data structure a little more and used a string character for each letter in the alphabet.</p> <p>Working in an editor attached to a REPL worked well (Vim in this case, but not relevant to the development of the code).  The behaviour of the code was tested with almost every expression, so we gained a good understanding of each line of code.</p> <p>There are ideas to take this further and show a visual representation of a message passing through a chain of clack tower, showing how the message would pass through the system at a human speed.  This would assume a fixed time to show a clacks between each clack tower and a minimum level of speed by the human part of the clacks tower.</p> <p>No REPL's were harmed in the making of this code, although one REPL was heavily used.</p>"},{"location":"additional-projects/clojurebridge-london-website/","title":"Create a Clojurebridge London website","text":"<p>We have a very simple website for ClojureBridge London and we would like to know how to make it easier to use.</p> <p>We would also like to have a website create with Clojure or preferably ClojureScript, so we can host the website on GitHub pages.</p>"},{"location":"additional-projects/clojurebridge-london-website/#infothis-section-is-new-so-feedback-is-appreciated","title":"Info::This section is new, so feedback is appreciated","text":""},{"location":"additional-projects/clojurebridge-london-website/#hintan-example-clojurescript-website-using-bootstrap-css-library","title":"HINT::An example ClojureScript website using Bootstrap CSS library","text":"<p>Clojure Study Group project contains examples of code you can include to create your ClojureScript website</p>"},{"location":"additional-projects/clojurebridge-london-website/#create-a-clojurescript-project","title":"Create a ClojureScript project","text":"<p>This will create a project with a working web page (usually described as a single page app).</p>"},{"location":"additional-projects/clojurebridge-london-website/#note-create-a-clojurescript-website-for-clojurebridge-london","title":"Note:: Create a ClojureScript website for ClojureBridge London","text":"<p>Create a project using the figwheel template, adding reagent library.</p> <pre><code>lein new figwheel clojurebridge-website -- --reagent\n</code></pre>"},{"location":"additional-projects/clojurebridge-london-website/#add-bootstrap-css-library","title":"Add Bootstrap CSS library","text":"<p>Bootstrap is a simple way to structure and make your website more appealing, using a wide range of CSS styles available.</p> <p>See the Clojure study group index.html file for an example</p> <p>The Bootstrap Introduction documentation includes examples of layouts and component styles you can include in your website.</p>"},{"location":"additional-projects/clojurebridge-london-website/#noteadd-bootstrap-to-project-web-page","title":"Note::Add Bootstrap to project web page","text":"<p>Edit the <code>resources/public/index.html</code> file in your project Add the following line of code inside the <code>&lt;head&gt;</code> tag: <pre><code>    &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css\" integrity=\"sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS\" crossorigin=\"anonymous\"&gt;\n</code></pre></p>"},{"location":"additional-projects/clojurebridge-london-website/#adding-sections-to-the-website","title":"Adding sections to the website","text":"<p>Create a function for each section of the website you want to add.</p>"},{"location":"additional-projects/clojurebridge-london-website/#hintreagent-examples","title":"HINT::Reagent examples","text":"<p>Introduction to Reagent has many simple examples of functions you can include in the website</p> <p>Guide to Reagent has even more examples</p>"},{"location":"additional-projects/clojurebridge-london-website/#create-a-banner-heading-using-bootstrap-jumbotron-style","title":"Create a banner heading using Bootstrap jumbotron style","text":"<pre><code>(defn website-title []\n  [:div {:class \"jumbotron practicalli-jumbotron\"}\n   [:h1 (get-in @app-state [:website :title])]\n   [:h4 (get-in @app-state [:website :description])]])\n</code></pre>"},{"location":"additional-projects/clojurebridge-london-website/#writing-html-in-clojure-with-hiccup","title":"Writing html in Clojure with hiccup","text":"<p>Rather than write <code>&lt;div&gt; &lt;/div&gt;</code>, <code>&lt;h1&gt; &lt;/h1&gt;</code>, <code>&lt;p&gt;  &lt;/p&gt;</code> pairs of tags in html, we define our content using a syntax called hiccup.</p> <p>A vector, <code>[]</code> is used to hold the name of the html tag, represented by a keyword such as <code>:div</code></p> <p>Defining our content in this way makes it easier to generate and transform using Clojure, so you can generate structure and content dynamically too.</p>"},{"location":"additional-projects/clojurebridge-london-website/#references","title":"References","text":"<ul> <li>Reagent Mysteries - part 1: vectors and sequences</li> <li>SVG in reagent</li> </ul>"},{"location":"additional-projects/clojurebridge-website/","title":"Live ClojureScript websites","text":"<p>This tutorial guides you through the creation of a relatively simple, responsive website that is deployed live on the Internet.</p> <p>You will discover how to use the following tools: - ClojureScript - writing functions for sections of content - Reagent - add basic state management to the website - Bulma - a CSS only framework for responsive design - Figwheel-main - an interactive development environment for ClojureScript - GitHub Pages - a free service for deploying your website on the Internet</p>"},{"location":"additional-projects/clojurebridge-website/#infothis-section-is-new-so-feedback-is-appreciated","title":"Info::This section is new, so feedback is appreciated","text":""},{"location":"additional-projects/clojurebridge-website/#example-clojurescript-websites","title":"Example ClojureScript websites","text":"<ul> <li>ClojureBridge London, a landing page for the event using Bulma CSS, global navigation and responsive design.</li> <li>ClojureBridge London source code</li> <li>Practicalli, a landing page using Bulma CSS (similar to the above)</li> <li>Clojure Study Group project a ClojureScript and bootstrap website</li> </ul>"},{"location":"additional-projects/clojurebridge-website/#looking-for-something-more","title":"Looking for something more?","text":"<p>pesterhazy/cljs-spa-example is a more involved example of a Single Page Application in ClojureScript.  This project uses figwheel-main, reagent, webpack, router5, yarn package management for npms,</p>"},{"location":"additional-projects/clojurebridge-website/#references","title":"References","text":"<ul> <li>Reagent Mysteries - part 1: vectors and sequences</li> <li>SVG in reagent</li> </ul>"},{"location":"additional-projects/clojurebridge-website/add-bluma-css/","title":"Add Bulma CSS library","text":"<p>Bulma is a CSS only framework (no JavaScript) that provides a range of easy to apply styles using meaningful style names.  Its quite lightweight and therefore fast to load along with your website.</p> <p>Bulma also recommends using FontAwesome library, to add common logos such at GitHub.</p> <p>See the Practicalli Landing page index.html file for an example</p>"},{"location":"additional-projects/clojurebridge-website/add-bluma-css/#noteadd-bulma-css-and-fontawesome-icons-to-project-web-page","title":"Note::Add Bulma CSS and FontAwesome icons to project web page","text":"<p>Edit the <code>resources/public/index.html</code> file in your project Add the following line of code inside the <code>&lt;head&gt;</code> tag: <pre><code>    &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css\"&gt;\n    &lt;script defer src=\"https://use.fontawesome.com/releases/v5.8.1/js/all.js\"&gt;&lt;/script&gt;\n</code></pre></p>"},{"location":"additional-projects/clojurebridge-website/add-content-namespace/","title":"Refactor content to its own namespace","text":"<p>Create a new namespace called <code>clojurebridge-landing-page.content</code> in the file <code>src/clojurebridge_landing_page/content.cljs</code></p> <p>Move all function definitions, except <code>landing-page</code> from the content section to the new file for the namespace.</p>"},{"location":"additional-projects/clojurebridge-website/add-content-namespace/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"additional-projects/clojurebridge-website/add-content-namespace/#require-the-content-namespace","title":"require the <code>content</code> namespace","text":"<p>Edit the the file <code>src/clojurebridge_landing_page/core.cljs</code>.</p> <p>Update the <code>clojurebridge-landing-page.core</code> namespace to require the new <code>clojurebridge-landing-page.content</code> namespace</p> <p>The <code>content</code> namespace should be given the alias <code>content</code></p> <pre><code>(ns ^:figwheel-hooks clojurebridge-london-landing-page.core\n  (:require\n   [goog.dom :as gdom]\n   [reagent.core :as reagent :refer [atom]]\n   [clojurebridge-landing-page.content :as content]))\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/add-content-namespace/#add-the-alias-to-the-function-calls","title":"Add the alias to the function calls","text":"<pre><code>(defn main-page []\n  [:div\n   [content/navigation-top]\n   [content/banner-columns]\n   [content/sponsor-current (get-in @app-state [:sponsors :current])]\n   (content/level-separator \"overview\")\n   [content/overview]\n   (content/level-separator \"showcase\")\n   [content/showcase]\n   (content/level-separator \"learning-paths\")\n   [content/learning-paths]\n   (content/level-separator \"install\")\n   [content/install]\n   (content/level-separator \"schedule\")\n   [content/schedule]\n   (content/level-separator \"resources\")\n   [content/resources]\n   (content/level-separator \"coaches\")\n   [content/coaches]\n   (content/level-separator \"sponsors\")\n   [content/sponsors]\n   ])\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/add-more-sections/","title":"Add a function to define each section","text":"<p>List of section ideas - Registration (sign up button, date, location, etc.) - Current sponsor (details of the current sponsor, sponsor messaging) - ClojureBridge overview (description of the event) - Clojure Showcase (some projects that demonstrate what Clojure can do) - Learning paths (links to the various curriculums) - Clojure Installation (how to set up a development environment) - ClojureBridge Schedule (what happens and when) - Resources (documentation, how to practice clojure, books, videos, etc) - Coaching guide (documentation to help coaches coach the students) - Sponsors guide (how to sponsor ClojureBridge and what to get out of it) - Past events (overview of all previous events, date, location, sponsors, etc.) - Models of learning (ideas on how to learn more effectively)</p> <p>Create a function for each section of the website you want to add.</p>"},{"location":"additional-projects/clojurebridge-website/add-more-sections/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"additional-projects/clojurebridge-website/add-more-sections/#hintreagent-examples","title":"HINT::Reagent examples","text":"<p>Introduction to Reagent has many simple examples of functions you can include in the website</p> <p>Guide to Reagent has even more examples</p>"},{"location":"additional-projects/clojurebridge-website/add-more-sections/#create-a-banner-heading-using-bootstrap-hero-style","title":"Create a banner heading using Bootstrap hero style","text":"<pre><code>(defn website-title []\n  [:section {:class \"hero\"}\n   [:h1 (get-in @app-state [:website :title])]\n   [:h4 (get-in @app-state [:website :description])]])\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/add-navigation/","title":"Add Navigation bar","text":"<p>To jump to specific content, we will add a navigation bar at the top of the page.</p> <p>The navigation will be fixed in place, so it will not move as the page is scrolled.</p> <p>The navigation will be responsive, so when the website is viewed on smaller screens, the navigation will show as a drop-down button (referred to as a burger as that is the rough shape of the icon typically used).</p>"},{"location":"additional-projects/clojurebridge-website/add-navigation/#navigation-section","title":"Navigation section","text":"<p>Create a function to define the navigation, using the <code>navbar</code> class from Bulma.</p> <pre><code>(defn navigation-top\n  \"A responsive navigation that is fixed to the top of the page\"\n  []\n\n  [:nav {:class      \"navbar is-fixed-top is-dark\"\n         :role       \"navigation\"\n         :aria-label \"main navigation\"}\n   [:div {:class \"container\"}\n    [:div {:class \"navbar-brand\"}\n     [:a {:class \"navbar-item\"\n          :href  \"/\"}\n      [:img {:src \"images/clojurebridge-logo.png\"}]]\n     [:span {:class       \"navbar-burger burger\"\n             :data-target \"navbarClojureBridge\"}\n      ;; Empty spans needed for navbar burger\n      [:span][:span][:span]]]\n\n    [:div {:id    \"navbarClojureBridge\"\n           :class \"navbar-menu\"}\n     [:div {:class \"navbar-start\"}\n      [:a {:class \"navbar-item\"\n           :href  \"#overview\"} \"Overview\"]\n      [:a {:class \"navbar-item\"\n           :href  \"#showcase\"} \"Showcase\"]\n      [:a {:class \"navbar-item\"\n           :href  \"#learning-paths\"} \"Learning Paths\"]\n      [:a {:class \"navbar-item\"\n           :href  \"#schedule\"} \"Schedule\"]\n      [:a {:class \"navbar-item\"\n           :href  \"#install\"} \"Install\"]\n      [:a {:class \"navbar-item\"\n           :href  \"#resources\"} \"Resources\"]\n      [:a {:class \"navbar-item\"\n           :href  \"#resources\"} \"Coaches\"]\n      [:a {:class \"navbar-item\"\n           :href  \"#sponsors\"} \"Sponsors\"]\n\n      [:span {:class \"navbar-item\"}\n       [:a {:class  \"button is-inverted\"\n            :target \"_blank\"\n            :href   \"https://github.com/ClojureBridgeLondon/landing-page-draft\"}\n        [:span {:class \"icon\"}\n         [:i {:class \"fab fa-github\"}]]\n        [:span \"Issues/PRs\"]]]]]]]\n  )\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/add-navigation/#fixing-spacing-under-navbar","title":"Fixing spacing under navbar","text":"<p>To prevent hiding content under the navigation bar, we add the <code>has-navbar-fixed-top</code> class to the body of the <code>index.html</code> file</p> <pre><code>  &lt;body class=\"has-navbar-fixed-top\"&gt;\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/add-navigation/#script-to-populate-the-drop-down-menu","title":"Script to populate the drop-down menu","text":"<p>As Bulma does not have any JavaScript functionality, we need to add a script to dynamically populate the navigation bar drop-down menu when on smaller devices.</p> <pre><code>    &lt;!-- Script for Bulma hamburger menu --&gt;\n    &lt;!-- https://www.adam-bray.com/2018/04/03/responsive-bulma-css-navigation-bar/ --&gt;\n    &lt;script&gt;\n     (function() {\n         var burger = document.querySelector('.burger');\n         var nav = document.querySelector('#'+burger.dataset.target);\n\n         burger.addEventListener('click', function(){\n             burger.classList.toggle('is-active');\n             nav.classList.toggle('is-active');\n         });\n     })();\n    &lt;/script&gt;\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/add-navigation/#todo","title":"TODO::","text":"<p>The script is the approach that Bulma suggests.  However, it should be possible to write ClojureScript to do this work.  This JavaScript would then be removed.</p> <p>One approach is to make the navigation data part of the application state, then it can be easily used and updated.  Using the application state helps make the webpage layout more dynamic, as changes to the application state will cause parts of the website to be re-drawn (re-rendered).</p>"},{"location":"additional-projects/clojurebridge-website/add-welcome-message/","title":"Add welcome message to the website","text":"<p>Update the <code>landing-page</code> function to contain content.</p> <p>Use the hiccup style to define the structure of the content</p> <p>Add style class names to the hiccup code to use CSS styles from Bulma.  Feel free to experiment on what you want to add here.</p>"},{"location":"additional-projects/clojurebridge-website/add-welcome-message/#simple-example","title":"Simple Example","text":"<pre><code>;; Content components\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn landing-page []\n\n  [:section {:class \"section\"}\n\n   [:h1\n    {:class \"title\"}\n    \"Welcome to ClojureBridge\"]\n\n   ;; Content will just use HTML tags directly, useful when you have no specific styles\n   ;; https://bulma.io/documentation/elements/content/\n\n   [:div {:class \"content\"}\n    [:p\n     \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras sed enim ante. Nullam consectetur, sapien in rutrum facilisis, augue velit finibus est, at lobortis odio eros sollicitudin risus. Nullam mollis, metus a varius volutpat, metus elit mollis est, finibus pretium dui enim non velit. Praesent sit amet volutpat nulla. Sed volutpat venenatis nisi id sagittis. Nunc nec efficitur mi. Duis consequat sapien ultricies quam bibendum, elementum faucibus sapien bibendum. Morbi diam elit, gravida iaculis metus vitae, ullamcorper mattis mi. Maecenas luctus lorem metus. Maecenas eleifend nisl sit amet felis accumsan, sit amet tincidunt turpis consequat. Cras non molestie ante, a pellentesque dui.\"]\n    [:p\n     \"Vivamus ullamcorper at orci ac tincidunt. Vivamus tincidunt sed erat nec consequat. Donec venenatis lorem justo, eget imperdiet arcu ultrices vitae. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Donec congue tempor posuere. Sed nec nisl mauris. Maecenas elementum quam justo, vitae auctor felis dapibus a. Phasellus leo justo, mattis a auctor tempus, facilisis vel tellus. Etiam at scelerisque justo, ac facilisis purus. Duis in leo pretium purus bibendum ultricies ac vitae lectus. Proin nec mi nec urna sollicitudin iaculis. In a orci felis. Sed luctus posuere luctus. Cras id euismod orci, id mollis nibh. Vestibulum et tellus quis lorem placerat scelerisque non et nisl. Ut dictum lacus nulla, sit amet ultricies eros pharetra vitae. \"]\n    ]])\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/add-welcome-message/#hintlorem-ipsum-generators","title":"Hint::Lorem ipsum generators","text":"<p>When you want to thing about the layout of a page without considering the wording of the content, you can use a Lorem ipsum generator to create text that most people will not just sit and read.</p>"},{"location":"additional-projects/clojurebridge-website/add-welcome-section/","title":"Refactor welcome to a specific component","text":"<p>Rename the <code>landing-page</code> function to <code>welcome-message</code>.</p> <p>Below the <code>welcome-message</code> function, create a new <code>landing-page</code> function definition as follows</p> <pre><code>(defn landing-page []\n  [welcome-message])\n</code></pre> <p>The <code>welcome-message</code> function needs to be defined above the <code>landing-page</code> function, as it <code>welcome-message</code> is call this new <code>landing-page</code> function.</p>"},{"location":"additional-projects/clojurebridge-website/app-state-section/","title":"App State driven section","text":"<p>The sponsor section of the website will change the sponsor details each time we have a new event.  Rather than hard code the sponsor details, we can add them to the application state.  Then each time we have a new event, all we need to do is update that state with new sponsor details.</p> <p>Update the map to contain a <code>:sponsors</code> key whose value is a map.</p> <p>That map containes <code>:current</code> and <code>:past</code> sponsors (past sponsors will be a map that has the number of the event and the sponsor details copied from the :current map).</p> <pre><code>(defonce\n  app-state\n    (atom\n      {:text \"Hello world!\"\n       :sponsors\n         {:current\n           {:name    \"Functional Works\"\n            :logo    \"images/functional-works-logo.svg\"\n            :website \"https://functional.works-hub.com/\"\n            :message \"Breaking down the barriers to hiring the right software engineers,\n            providing a platform to managing the whole process (written in ClojureScript).\"}\n          :past    {:9 {,,,}}}}))\n</code></pre> <p>Here is an example of a current sponsor component.</p> <pre><code>(defn sponsor-current\n  \"Sponsors for our current event, to help that sponsor get some exposure\n\n  Argument: hash-map of strings - :name, :website, :logo, :message\"\n  [sponsor-details]\n  [:div {:class \"container\"}\n   [:div {:class \"box\"}\n    [:div {:class \"column is-half is-8 is-offset-2\"}\n     [:a {:href (get sponsor-details :website)}\n      [:h3 {:class \"title is-5 has-text-centered\"} (str \"Our Sponsors:\" \" \" (get sponsor-details :name))]]\n     [:div {:class \"columns\"}\n      [:div {:class \"column\"}\n       [:figure {:class \"image\"}\n        [:a {:href (get sponsor-details :website)}\n         [:img {:src \"images/functional-works-logo.png\"}]]]]\n      [:div {:class \"column\"}\n       [:div {:class \"content\"}\n        [:p (get sponsor-details :message)]]]]]]])\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/create-project/","title":"Create a ClojureScript project","text":"<p>This will create a project with a working web page (usually described as a single page app).</p>"},{"location":"additional-projects/clojurebridge-website/create-project/#note-create-a-clojurescript-website-for-clojurebridge-london","title":"Note:: Create a ClojureScript website for ClojureBridge London","text":"<p>Create a project using the figwheel template, adding reagent library.</p> <p>Using Leiningen <pre><code>lein new figwheel-main clojurebridge-landing-page -- --reagent\n</code></pre></p> <p>or the Clojure CLI tools and clj-new <pre><code>clj -A:new figwheel-main clojurebridge-landing-page -- --reagent\n</code></pre></p>"},{"location":"additional-projects/clojurebridge-website/create-project/#hintfigwheel-main-template","title":"Hint::figwheel-main template","text":"<p>figwheel-main-template project provides a simple way to create a minimal ClojureScript project, optionally using reagent, rum, om or react/sablono</p>"},{"location":"additional-projects/clojurebridge-website/deploy-build/","title":"Creating a Deploy build configuration","text":"<p>Create a build configuration for deployment, to remove the need to copy the <code>.js</code> file to the deploy location.</p> <p>These instructions assume the <code>/docs</code> directory is used by GitHub pages for deploying the website.</p>"},{"location":"additional-projects/clojurebridge-website/deploy-build/#create-a-deploy-build-configuration-file","title":"Create a deploy build configuration file","text":"<p>Copy the <code>dev.cljs.edn</code> to <code>deploy.cljs.edn</code>.</p> <p>Edit <code>deploy.cljs.edn</code> and add the <code>ouptput-to:</code> configuration option</p> <pre><code>^{:watch-dirs   [\"test\" \"src\"]\n  :css-dirs     [\"resources/public/css\"]\n  :auto-testing true}\n{:main clojurebridge-landing-page.core\n :output-to \"docs/cljs-out/dev-main.js\"}\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/deploy-build/#hintadjust-file-and-path-if-required","title":"Hint::Adjust file and path if required","text":"<p>This configuration assumes GitHub pages has been configured to use the <code>/docs</code> directory in the master branch to serve the website.</p>"},{"location":"additional-projects/clojurebridge-website/deploy-build/#create-a-new-alias","title":"Create a new alias","text":"<p>Edit the <code>project.clj</code> file.</p> <p>Add a new <code>:aliases</code> line, the same as the <code>fig:min</code> line, except using <code>deploy</code> at the end.</p> <pre><code>  :aliases {\"fig\"        [\"trampoline\" \"run\" \"-m\" \"figwheel.main\"]\n            \"fig:build\"  [\"trampoline\" \"run\" \"-m\" \"figwheel.main\" \"-b\" \"dev\" \"-r\"]\n            \"fig:min\"    [\"run\" \"-m\" \"figwheel.main\" \"-O\" \"advanced\" \"-bo\" \"dev\"]\n            \"fig:deploy\" [\"run\" \"-m\" \"figwheel.main\" \"-O\" \"advanced\" \"-bo\" \"deploy\"]\n            \"fig:test\"   [\"run\" \"-m\" \"figwheel.main\" \"-co\" \"test.cljs.edn\" \"-m\" juxt-edge.test-runner]}\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/deploy-build/#deploying-updates","title":"Deploying updates","text":"<p><code>lein fig:deploy</code> will now deploy any changes to your ClojureScript app without the need to copy any files.</p> <p>In a terminal window open in the root of your project, run the commands:</p> <pre><code>lein clean\nlein fig:deploy\n</code></pre> <p>Then commit the new file and push to GitHub</p> <pre><code>git commit -a \"Deploy version 4.2\"\ngit push origin master\n</code></pre> <p>If you make any changes to the index.html or css/styles.css files, then still need to copy them into <code>/docs</code> directory manually, then commit those changes too.</p>"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/","title":"Deploy to GitHub pages","text":"<p>GitHub pages is a free service for serving up content in static files, its ideal for websites that do not require their own database or other services (or simply plugs into purely online services and API's).</p> <p>Create a repository on GitHub for this ClojureScript project</p> <p>Add that repository as a remote repository to the local Git repository for this project</p> <pre><code>git remote add origin &lt;repository URI from GitHub&gt;\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/#project-specific-landing-pages","title":"Project specific landing pages","text":"<p>There are two approaches when adding a website to a specific project.</p> <ul> <li>add files to a <code>gh-pages</code> branch (classic approach)</li> <li>add files to <code>/docs</code> directory on the master branch (new approach)</li> </ul> <p>We will use the new approach and deploy our files in <code>/docs</code></p>"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/#alternative-organisation-user-landing-pages","title":"Alternative: Organisation / user Landing pages","text":"<p>For Organisations on GitHub, like ClojureBridgeLondon and Pracitalli, I use two separate Git repositories</p> <ul> <li>ClojureScript repository - created by Leiningen / figwheel template</li> <li>Deployment repository - only contains specific files for deployment</li> </ul>"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/#creating-the-files-for-deployment","title":"Creating the files for deployment","text":"<p>During development the build of the ClojureScript application is contained in multiple files, as this makes it easy to do fast updates of just the specific parts of the application.</p> <p>When we deploy, we generate a single JavaScript file that contains our application.  We also minify the application to make it quick to load into the browser.</p>"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/#note","title":"Note::","text":"<p>In the root of your ClojureScript project (where project.clj file is) run the commands: <pre><code>lein clean\nlein fig:min\n</code></pre></p>"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/#add-directory-to-github","title":"Add directory to GitHub","text":"<p>Create the <code>/docs</code> and <code>/docs/cljs-out</code> directories in the project first.</p> <p>Add a <code>README.md</code> file with a message describing the purpose of the /docs directory.</p> <p>Commit the <code>README.md</code> file and push to your GitHub repository</p>"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/#set-github-pages-location","title":"Set GitHub pages location","text":"<p>Visit the GitHub repository website and update the Settings to point to `/docs as the source of GitHub pages</p> <p>Setting &gt; GitHub Pages &gt; Source</p> <p>master branch /docs folder</p> <p></p>"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/#copy-the-files","title":"Copy the files","text":"<p>Copy the following files into the <code>/docs</code> directory.</p> <pre><code>cp resources/public/index.html docs\n\ncp -r resources/public/css docs\n\ncp -r resources/public/images images\n\ncp resources/public/cljs-out/dev-main.js docs/cljs-out/\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/#commit-and-push-the-files","title":"Commit and push the files","text":"<p>Commit all the changes in the <code>/docs</code> directory.</p> <p>Push the commit to GitHub <code>git push origin master</code></p> <p>Visit your live website at https://.github.io/clojurebridge-landing-page/"},{"location":"additional-projects/clojurebridge-website/github-pages-deploy/#deploying-updates","title":"Deploying updates","text":"<p>Any changes to your ClojureScript app that you want to deploy, then you only need to build the single javascrpt file again</p> <pre><code>lein clean\nlein fig:min\n</code></pre> <p>Then copy the new javascript file to the <code>docs/cljs-out</code> directory</p> <pre><code>cp resources/public/cljs-out/dev-main.js docs/cljs-out/\n</code></pre> <p>Commit the new file and push to GitHub <pre><code>git commit -a \"New version\"\ngit push origin master\n</code></pre></p> <p>If you make any changes to the index.html or css/styles.css files, then you will need to copy them into <code>/docs</code> directory and commit those changes too</p>"},{"location":"additional-projects/clojurebridge-website/hiccup-for-html/","title":"Writing html in Clojure with hiccup","text":"<p>Rather than write <code>&lt;div&gt; &lt;/div&gt;</code>, <code>&lt;h1&gt; &lt;/h1&gt;</code>, <code>&lt;p&gt;  &lt;/p&gt;</code> pairs of tags in html, we define our content using a syntax called hiccup.</p> <p>A vector, <code>[]</code> is used to hold the name of the html tag, represented by a keyword such as <code>:div</code></p> <p>Defining our content in this way makes it easier to generate and transform using Clojure, so you can generate structure and content dynamically too.</p> <p>For example this simple html code uses open and closing tags to define the scope of where to apply that tag.</p> <pre><code>&lt;div&gt;\n  &lt;h1&gt;Hello World&lt;/h1&gt;\n  &lt;h3&gt;Live reloading in the repl makes web development fun!&lt;/h3&gt;\n&lt;/div&gt;\n</code></pre> <p>In Clojure, we only have the one tag, which is represented by a keyword that has the same name as the HTML tag.  The vector defines the scope of the tag.</p> <p>Using vectors for scope its trivial to use structured editing to organise and refactor the structure of your web page content.</p> <pre><code>(defn hello-world []\n  [:div\n   [:h1 (:text @app-state)]\n   [:h3 \"Live reloading in the repl makes web development fun!\"]])\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/hiccup-for-html/#using-state-for-dynamic-content","title":"Using state for dynamic content","text":"<p>We can also use dynamic information from the application state, defined as an atom called <code>app-state</code>.  As this name refers to an atom, we need to use the <code>@</code> character or the <code>deref</code> function to access its values</p> <p>In this example, the atom contains a Clojure map with a key called <code>text</code>.  We can get the value associated with <code>text</code> in the map by de-referencing the atom. <pre><code>[:h1 (get @app-state :text)]\n</code></pre></p> <p>Its quite common to use the short form when the key of a map is the keyword type <pre><code>[:h1 (:text @app-state)]\n</code></pre></p>"},{"location":"additional-projects/clojurebridge-website/live-reloading/","title":"Live reloading","text":"<p>figwheel-main provides live reloading of our application in the browser.  When we save a change to the code (JavaScript or CSS), that change is automatically pushed to the browser and the web page is updates.</p> <p>You may see a little ClojureScript logo appear briefly.</p> <p>The web page should have automatically updated</p> <p></p>"},{"location":"additional-projects/clojurebridge-website/live-reloading/#noteedit-the-code-to-see-live-reloading","title":"Note::Edit the code to see live reloading","text":"<p>Edit the file <code>clojurebridge-landing-page/src/clojurebridge_landing_page/core.cljs</code></p> <p>Change the heading 3 contents in the <code>hello-world</code> function <pre><code>(defn hello-world []\n  [:div\n   [:h1 (:text @app-state)]\n   [:h3 \"Live reloading in the repl makes web development fun!\"]])\n</code></pre></p>"},{"location":"additional-projects/clojurebridge-website/mount-lifecycle-management/","title":"Mount - lifecycle management","text":"<p>Essentially mount allow you to start and stop parts of your application (components), so you dont have to stop the whole of your application</p> <p>TODO: write a simple explanation of mount</p>"},{"location":"additional-projects/clojurebridge-website/mount-lifecycle-management/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Pull requests are welcome</p>"},{"location":"additional-projects/clojurebridge-website/organising-the-code/","title":"Re-organising the code a little","text":"<p>Create comments to make it easier to identify the specific parts of the code</p>"},{"location":"additional-projects/clojurebridge-website/organising-the-code/#hintgood-structure-helps-refactor-later","title":"Hint::Good structure helps refactor later","text":"<p>Having an organised structure to your code helps you maintain the code and help you refactor code into multiple namespaces.</p>"},{"location":"additional-projects/clojurebridge-website/organising-the-code/#rename-main-component-to-landing-page","title":"Rename main component to landing-page","text":"<p>To make our code clearer, rename <code>hello-world</code> function to <code>landing-page</code></p> <pre><code>(defn landing-page []\n  [:div\n   [:h1 (:text @app-state)]\n   [:h3 \"Live reloading in the REPL makes web development fun!\"]])\n</code></pre> <p>And update the <code>mount</code> function to use this new function name as the main component</p> <pre><code>(defn mount [el]\n  (reagent/render-component [landing-page] el))\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/organising-the-code/#create-a-system-section","title":"Create a system section","text":"<p>Move the <code>get-app-element</code> to the other mount / reagent functions and call that section System</p> <pre><code>;; System\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn get-app-element []\n  (gdom/getElement \"app\"))\n\n(defn mount [el]\n  (reagent/render-component [landing-page] el))\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/organising-the-code/#add-a-datetime-stamped-reload-message","title":"Add a date/time stamped reload message","text":"<p>As a quick sanity check, add a date / time stamp to the println message at the top of the file, so you can see the time figwheel reloads the page in the REPL output.</p> <pre><code>;; simple debug statement for each build\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(println (js/Date.) \"Reloading: src/clojurebridge_landing_page/core.cljs\")\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/organising-the-code/#final-result","title":"Final result","text":"<p>After all the changes the file should look as follows</p> <pre><code>(ns ^:figwheel-hooks clojurebridge-landing-page.core\n  (:require\n   [goog.dom :as gdom]\n   [reagent.core :as reagent :refer [atom]]))\n\n;; simple debug statement for each build\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(println (js/Date.) \"Reloading: src/clojurebridge_landing_page/core.cljs\")\n\n\n;; Application state\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; define your app data so that it doesn't get over-written on reload\n(defonce app-state (atom {:text \"Hello world!\"}))\n\n\n;; Helper functions\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn multiply [a b] (* a b))\n\n\n;; Content components\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn landing-page []\n  [:div\n   [:h1 (:text @app-state)]\n   [:h3 \"Live reloading in the REPL makes web development fun!\"]])\n\n\n;; System\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn get-app-element []\n  (gdom/getElement \"app\"))\n\n(defn mount [el]\n  (reagent/render-component [landing-page] el))\n\n(defn mount-app-element []\n  (when-let [el (get-app-element)]\n    (mount el)))\n\n;; conditionally start your application based on the presence of an \"app\" element\n;; this is particularly helpful for testing this ns without launching the app\n(mount-app-element)\n\n;; specify reload hook with ^;after-load metadata\n(defn ^:after-load on-reload []\n  (mount-app-element)\n  ;; optionally touch your app-state to force rerendering depending on\n  ;; your application\n  ;; (swap! app-state update-in [:__figwheel_counter] inc)\n)\n</code></pre>"},{"location":"additional-projects/clojurebridge-website/responsive-design/","title":"responsive-design","text":""},{"location":"additional-projects/clojurebridge-website/responsive-design/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Discuss ideas behind Bulma</p>"},{"location":"additional-projects/clojurebridge-website/run-the-project/","title":"Run the project","text":""},{"location":"additional-projects/clojurebridge-website/run-the-project/#on-the-command-line","title":"On the command line","text":"<p>Change into the directory <code>clojurebridge-landing-page</code> and run the command</p> <p><code>lein fig:build</code></p> <p>or</p> <p><code>clojure -A:fig:build</code></p>"},{"location":"additional-projects/clojurebridge-website/run-the-project/#spacemacs","title":"Spacemacs","text":"<p><code>SPC f f</code> and open the file <code>clojurebridge-landing-page/src/clojurebridge_landing_page/core.cljs</code></p> <p><code>, \"</code> or <code>, s I</code> to run the command <code>clojurescript-jack-in</code></p> <p>When prompted for the REPL type, select <code>figwheel-main</code></p> <p></p> <p>When prompted for the build, type <code>dev</code></p> <p></p> <p>After a few moments, your default browser will automatically open at [http://localhost:9500/]</p> <p></p>"},{"location":"additional-projects/clojurebridge-website/interacting/","title":"Interacting with the website","text":"<p>So far our website has been pretty static.  We can change the page by saving new function definitions or by updating data in the application state.</p> <p>What about user interaction?</p> <p>In this section we will learn how to interact with the website and understand how reagent manages updates for us.</p> <p>Ideas we could do</p> <ul> <li> <p>a daily like / love / interested button  - each time the button is pressed it increases the number of likes (eg. a fancy counter).  Without persisting the number of likes in a data store, the number of likes would be reset each time the application is deployed.</p> </li> <li> <p>minimise a section, minimise all sections but that which you click on</p> </li> </ul>"},{"location":"additional-projects/clojurebridge-website/interacting/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"assets/images/social/","title":"Social Cards","text":"<p>Social Cards are visual previews of the website that are included when sending links via social media platforms.</p> <p>Material for MkDocs is configured to generate beautiful social cards automatically, using the colors, fonts and logos defined in <code>mkdocs.yml</code></p> <p>Generated images are stored in this directory.</p>"},{"location":"clojure-design/","title":"Clojure Design","text":"<ul> <li>naming functions, symbols, namespaces, projects</li> <li>documentation is an essential part of good design (tips on how to make documentation very effective)</li> <li>idioms (the clojure way)</li> <li>simple design</li> <li>immutability</li> </ul>"},{"location":"clojure-design/idioms/","title":"Clojure Design Idioms","text":"<p>An idiom is the Clojure way</p> <p>Idioms are not Design Patterns found in languages like C++ and Java.  Design patterns have a very specific language and structure and carefully design the context in which they are used.</p> <p>Idioms are very simple in comparision, they are the way Clojure should be used.</p> <p>Idiomatic Clojure is a term commonly used, commonly as a question.  Is this idiomatic Clojure?</p>"},{"location":"clojure-design/idioms/#idioms-from-style-guide","title":"Idioms from style guide","text":"<p>A (WIP) refactor of the idioms from the Clojure Style guide</p>"},{"location":"clojure-design/idioms/#dynamic-namespace-manipulation","title":"Dynamic Namespace Manipulation","text":"<p>TODO: vauge statement with no example</p> <p>Avoid the use of namespace-manipulating functions like <code>require</code> and <code>refer</code>. They are entirely unnecessary outside of a REPL environment.</p>"},{"location":"clojure-design/idioms/#forward-references","title":"Forward References","text":"<p>TODO: vauge statement with no example</p> <p>Avoid forward references.  They are occasionally necessary, but such occasions are rare in practice.</p>"},{"location":"clojure-design/idioms/#declare","title":"Declare","text":"<p>Use <code>declare</code> to enable forward references when forward references are necessary.</p>"},{"location":"clojure-design/idioms/#higher-order-functions","title":"Higher-order Functions","text":"<p>TODO: expand and provide examples</p> <p>Prefer higher-order functions like <code>map</code> to <code>loop/recur</code>.</p>"},{"location":"clojure-design/idioms/#appropriate-function-use","title":"Appropriate Function use","text":"<ul> <li>let def</li> <li>if when cond condp </li> <li>Nil Punning (a pun that null is not a value, when it is??) seq empty?</li> </ul>"},{"location":"clojure-design/idioms/#use-let-for-local-names","title":"Use let for local names","text":"<p><code>let</code> should be used inside a function definition or to create a local name when experimenting in the REPL.</p> <p><code>def</code> defines a symbol name at the scope of the current namespace and therefore is inappropriate to use within a function definition.</p> <p>Avoid vars inside functions</p> <pre><code>(defn iterative-function \n  \"Avoid breaking the scope of data in a function by using def\"\n  [args]\n    (def x 5)  ; Avoid using a var as it breaks the scope of the function\n  ...)\n\nx ; evaluating will return the result without going through the function call and could be used anywere the namespace is required, increasing complexity.\n</code></pre> <p>Problematic debuging technique</p> <p>An obscure debug technique is to define a def inside a function definition to capture intermediate values, however, this breaks the scope of Clojure and can lead to incorrect use of Clojure (especially by those new to the language).</p> <p>Use a debug tool rather than break the scope of Clojure with a def, e.g. Cider Debug or Flowstorm-debugger.</p>"},{"location":"clojure-design/idioms/#shadowing-clojurecore-names-dont-shadow-clojure-core","title":"Shadowing <code>clojure.core</code> Names [[dont-shadow-clojure-core]]","text":"<p>Don't shadow <code>clojure.core</code> names with local bindings or custom function definitions (confusion, a change of well held expectations).</p> <pre><code>;; bad - clojure.core/map must be fully qualified inside the function\n(defn inc [map]\n  ...)\n</code></pre> <p>RELATED: avoid renaming functions required by name via the <code>ns</code> definition. </p>"},{"location":"clojure-design/idioms/#alter-var-binding-alter-var","title":"Alter Var Binding [[alter-var]]","text":"<p>Use <code>alter-var-root</code> instead of <code>def</code> to change the value of a var.</p> <p>[source,clojure] <pre><code>;; good\n(def thing 1) ; value of thing is now 1\n; do some stuff with thing\n(alter-var-root #'thing (constantly nil)) ; value of thing is now nil\n\n;; bad\n(def thing 1)\n; do some stuff with thing\n(def thing nil)\n; value of thing is now nil\n</code></pre></p>"},{"location":"clojure-design/idioms/#nil-punning-nil-punning","title":"Nil Punning [[nil-punning]]","text":"<p>Use <code>seq</code> as a terminating condition to test whether a sequence is empty (this technique is sometimes called nil punning).</p> <p>[source,clojure] <pre><code>;; good\n(defn print-seq [s]\n  (when (seq s)\n    (prn (first s))\n    (recur (rest s))))\n\n;; bad\n(defn print-seq [s]\n  (when-not (empty? s)\n    (prn (first s))\n    (recur (rest s))))\n</code></pre></p>"},{"location":"clojure-design/idioms/#converting-sequences-to-vectors-to-vector","title":"Converting Sequences to Vectors [[to-vector]]","text":"<p>Prefer <code>vec</code> over <code>into</code> when you need to convert a sequence into a vector.</p> <p>[source,clojure] <pre><code>;; good\n(vec some-seq)\n\n;; bad\n(into [] some-seq)\n</code></pre></p>"},{"location":"clojure-design/idioms/#converting-something-to-boolean","title":"Converting Something to Boolean","text":"<p>Use the <code>boolean</code> function if you need to convert something to an actual boolean value (<code>true</code> or <code>false</code>).</p> <p>[source,clojure] <pre><code>;; good\n(boolean (foo bar))\n\n;; bad\n(if (foo bar) true false)\n</code></pre></p> <p>NOTE: Don't forget that the only values in Clojure that are \"falsey\" are <code>false</code> and <code>nil</code>. Everything else will evaluate to <code>true</code> when passed to the <code>boolean</code> function.</p> <p>You'll rarely need an actual boolean value in Clojure, but it's useful to know how to obtain one when you do.</p>"},{"location":"clojure-design/idioms/#when-vs-if-when-instead-of-single-branch-if","title":"<code>when</code> vs <code>if</code> [[when-instead-of-single-branch-if]]","text":"<p>Use <code>when</code> instead of <code>if</code> with just the truthy branch, as in <code>(if condition (something...))</code> or <code>(if ... (do ...))</code>.</p> <p>[source,clojure] <pre><code>;; good\n(when pred\n  (foo)\n  (bar))\n\n;; bad\n(if pred\n  (do\n    (foo)\n    (bar)))\n</code></pre></p>"},{"location":"clojure-design/idioms/#if-let-if-let","title":"<code>if-let</code> [[if-let]]","text":"<p>Use <code>if-let</code> instead of <code>let</code> + <code>if</code>.</p> <p>[source,clojure] <pre><code>;; good\n(if-let [result (foo x)]\n  (something-with result)\n  (something-else))\n\n;; bad\n(let [result (foo x)]\n  (if result\n    (something-with result)\n    (something-else)))\n</code></pre></p>"},{"location":"clojure-design/idioms/#when-let-when-let","title":"<code>when-let</code> [[when-let]]","text":"<p>Use <code>when-let</code> instead of <code>let</code> + <code>when</code>.</p> <p>[source,clojure] <pre><code>;; good\n(when-let [result (foo x)]\n  (do-something-with result)\n  (do-something-more-with result))\n\n;; bad\n(let [result (foo x)]\n  (when result\n    (do-something-with result)\n    (do-something-more-with result)))\n</code></pre></p>"},{"location":"clojure-design/idioms/#if-not-if-not","title":"<code>if-not</code> [[if-not]]","text":"<p>Use <code>if-not</code> instead of <code>(if (not ...) ...)</code>.</p> <p>[source,clojure] <pre><code>;; good\n(if-not pred\n  (foo))\n\n;; bad\n(if (not pred)\n  (foo))\n</code></pre></p>"},{"location":"clojure-design/idioms/#when-not-when-not","title":"<code>when-not</code> [[when-not]]","text":"<p>Use <code>when-not</code> instead of <code>(when (not ...) ...)</code>.</p> <p>[source,clojure] <pre><code>;; good\n(when-not pred\n  (foo)\n  (bar))\n\n;; bad\n(when (not pred)\n  (foo)\n  (bar))\n</code></pre></p>"},{"location":"clojure-design/idioms/#when-not-vs-if-not-when-not-instead-of-single-branch-if-not","title":"<code>when-not</code> vs <code>if-not</code> [[when-not-instead-of-single-branch-if-not]]","text":"<p>Use <code>when-not</code> instead of <code>(if-not ... (do ...))</code>.</p> <p>[source,clojure] <pre><code>;; good\n(when-not pred\n  (foo)\n  (bar))\n\n;; bad\n(if-not pred\n  (do\n    (foo)\n    (bar)))\n</code></pre></p>"},{"location":"clojure-design/idioms/#not-not-equal","title":"<code>not=</code> [[not-equal]]","text":"<p>Use <code>not=</code> instead of <code>(not (= ...))</code>.</p> <p>[source,clojure] <pre><code>;; good\n(not= foo bar)\n\n;; bad\n(not (= foo bar))\n</code></pre></p>"},{"location":"clojure-design/idioms/#printf-printf","title":"<code>printf</code> [[printf]]","text":"<p>Prefer <code>printf</code> over <code>(print (format ...))</code>.</p> <p>[source,clojure] <pre><code>;; good\n(printf \"Hello, %s!\\n\" name)\n\n;; ok\n(println (format \"Hello, %s!\" name))\n</code></pre></p>"},{"location":"clojure-design/idioms/#flexible-comparison-functions","title":"Flexible Comparison Functions","text":"<p>When doing comparisons, leverage the fact that Clojure's functions <code>&lt;</code>, <code>&gt;</code>, etc. accept a variable number of arguments.</p> <p>[source,clojure] <pre><code>;; good\n(&lt; 5 x 10)\n\n;; bad\n(and (&gt; x 5) (&lt; x 10))\n</code></pre></p>"},{"location":"clojure-design/idioms/#single-parameter-function-literal-single-param-fn-literal","title":"Single Parameter Function Literal [[single-param-fn-literal]]","text":"<p>Prefer <code>%</code> over <code>%1</code> in function literals with only one parameter.</p> <p>[source,clojure] <pre><code>;; good\n#(Math/round %)\n\n;; bad\n#(Math/round %1)\n</code></pre></p>"},{"location":"clojure-design/idioms/#multiple-parameters-function-literal-multiple-params-fn-literal","title":"Multiple Parameters Function Literal [[multiple-params-fn-literal]]","text":"<p>Prefer <code>%1</code> over <code>%</code> in function literals with more than one parameter.</p> <p>[source,clojure] <pre><code>;; good\n#(Math/pow %1 %2)\n\n;; bad\n#(Math/pow % %2)\n</code></pre></p>"},{"location":"clojure-design/idioms/#no-useless-anonymous-functions-no-useless-anonymous-fns","title":"No Useless Anonymous Functions [[no-useless-anonymous-fns]]","text":"<p>Don't wrap functions in anonymous functions when you don't need to.</p> <p>[source,clojure] <pre><code>;; good\n(filter even? (range 1 10))\n\n;; bad\n(filter #(even? %) (range 1 10))\n</code></pre></p>"},{"location":"clojure-design/idioms/#no-multiple-forms-in-function-literals-no-multiple-forms-fn-literals","title":"No Multiple Forms in Function Literals [[no-multiple-forms-fn-literals]]","text":"<p>Don't use function literals if the function body will consist of more than one form.</p> <p>[source,clojure] <pre><code>;; good\n(fn [x]\n  (println x)\n  (* x 2))\n\n;; bad (you need an explicit do form)\n#(do (println %)\n     (* % 2))\n</code></pre></p>"},{"location":"clojure-design/idioms/#anonymous-functions-vs-complement-comp-and-partial","title":"Anonymous Functions vs <code>complement</code>, <code>comp</code> and <code>partial</code>","text":"<p>Prefer anonymous functions over <code>complement</code>, <code>comp</code> and <code>partial</code>, as this results in simpler code most of the time.footnote:[You can read more on the subject https://ask.clojure.org/index.php/8373/when-should-prefer-comp-and-partial-to-anonymous-functions[here].]</p>"},{"location":"clojure-design/idioms/#complement-complement","title":"= <code>complement</code> [[complement]]","text":"<p>[source,clojure] <pre><code>;; good\n(filter #(not (some-pred? %)) coll)\n\n;; okish\n(filter (complement some-pred?) coll)\n</code></pre></p>"},{"location":"clojure-design/idioms/#comp-comp","title":"= <code>comp</code> [[comp]]","text":"<p>[source,clojure] <pre><code>;; Assuming `(:require [clojure.string :as str])`...\n\n;; good\n(map #(str/capitalize (str/trim %)) [\"top \" \" test \"])\n\n;; okish\n(map (comp str/capitalize str/trim) [\"top \" \" test \"])\n</code></pre></p> <p><code>comp</code> is quite useful when composing transducer chains, though.</p> <p>[source,clojure] <pre><code>;; good\n(def xf\n  (comp\n    (filter odd?)\n    (map inc)\n    (take 5)))\n</code></pre></p>"},{"location":"clojure-design/idioms/#partial-partial","title":"= <code>partial</code> [[partial]]","text":"<p>[source,clojure] <pre><code>;; good\n(map #(+ 5 %) (range 1 10))\n\n;; okish\n(map (partial + 5) (range 1 10))\n</code></pre></p>"},{"location":"clojure-design/idioms/#threading-macros-threading-macros","title":"Threading Macros [[threading-macros]]","text":"<p>Prefer the use of the threading macros <code>+-&gt;+</code> (thread-first) and <code>+-&gt;&gt;+</code> (thread-last) to heavy form nesting.</p> <p>[source,clojure] <pre><code>;; good\n(-&gt; [1 2 3]\n    reverse\n    (conj 4)\n    prn)\n\n;; not as good\n(prn (conj (reverse [1 2 3])\n           4))\n\n;; good\n(-&gt;&gt; (range 1 10)\n     (filter even?)\n     (map (partial * 2)))\n\n;; not as good\n(map (partial * 2)\n     (filter even? (range 1 10)))\n</code></pre></p>"},{"location":"clojure-design/idioms/#threading-macros-and-optional-parentheses","title":"Threading Macros and Optional Parentheses","text":"<p>Parentheses are not required when using the threading macros for functions having no argument specified, so use them only when necessary.</p> <p>[source,clojure] <pre><code>;; good\n(-&gt; x fizz :foo first frob)\n\n;; bad; parens add clutter and are not needed\n(-&gt; x (fizz) (:foo) (first) (frob))\n\n;; good, parens are necessary with an arg\n(-&gt; x\n    (fizz a b)\n    :foo\n    first\n    (frob x y))\n</code></pre></p>"},{"location":"clojure-design/idioms/#threading-macros-alignment","title":"Threading Macros Alignment","text":"<p>The arguments to the threading macros <code>+-&gt;+</code> (thread-first) and <code>+-&gt;&gt;+</code> (thread-last) should line up.</p> <p>[source,clojure] <pre><code>;; good\n(-&gt;&gt; (range)\n     (filter even?)\n     (take 5))\n\n;; bad\n(-&gt;&gt; (range)\n  (filter even?)\n  (take 5))\n</code></pre></p>"},{"location":"clojure-design/idioms/#default-cond-branch-else-keyword-in-cond","title":"Default <code>cond</code> Branch [[else-keyword-in-cond]]","text":"<p>Use <code>:else</code> as the catch-all test expression in <code>cond</code>.</p> <p>[source,clojure] <pre><code>;; good\n(cond\n  (neg? n) \"negative\"\n  (pos? n) \"positive\"\n  :else \"zero\")\n\n;; bad\n(cond\n  (neg? n) \"negative\"\n  (pos? n) \"positive\"\n  true \"zero\")\n</code></pre></p>"},{"location":"clojure-design/idioms/#condp-vs-cond-condp","title":"<code>condp</code> vs <code>cond</code> [[condp]]","text":"<p>Prefer <code>condp</code> instead of <code>cond</code> when the predicate &amp; expression don't change.</p> <p>[source,clojure] <pre><code>;; good\n(cond\n  (= x 10) :ten\n  (= x 20) :twenty\n  (= x 30) :thirty\n  :else :dunno)\n\n;; much better\n(condp = x\n  10 :ten\n  20 :twenty\n  30 :thirty\n  :dunno)\n</code></pre></p>"},{"location":"clojure-design/idioms/#case-vs-condcondp-case","title":"<code>case</code> vs <code>cond/condp</code> [[case]]","text":"<p>Prefer <code>case</code> instead of <code>cond</code> or <code>condp</code> when test expressions are compile-time constants.</p> <p>[source,clojure] <pre><code>;; good\n(cond\n  (= x 10) :ten\n  (= x 20) :twenty\n  (= x 30) :forty\n  :else :dunno)\n\n;; better\n(condp = x\n  10 :ten\n  20 :twenty\n  30 :forty\n  :dunno)\n\n;; best\n(case x\n  10 :ten\n  20 :twenty\n  30 :forty\n  :dunno)\n</code></pre></p>"},{"location":"clojure-design/idioms/#short-forms-in-cond-short-forms-in-cond","title":"Short Forms In Cond [[short-forms-in-cond]]","text":"<p>Use short forms in <code>cond</code> and related.  If not possible give visual hints for the pairwise grouping with comments or empty lines.</p> <p>[source,clojure] <pre><code>;; good\n(cond\n  (test1) (action1)\n  (test2) (action2)\n  :else   (default-action))\n\n;; ok-ish\n(cond\n  ;; test case 1\n  (test1)\n  (long-function-name-which-requires-a-new-line\n    (complicated-sub-form\n      (-&gt; 'which-spans multiple-lines)))\n\n  ;; test case 2\n  (test2)\n  (another-very-long-function-name\n    (yet-another-sub-form\n      (-&gt; 'which-spans multiple-lines)))\n\n  :else\n  (the-fall-through-default-case\n    (which-also-spans 'multiple\n                      'lines)))\n</code></pre></p>"},{"location":"clojure-design/idioms/#set-as-predicate-set-as-predicate","title":"Set As Predicate [[set-as-predicate]]","text":"<p>Use a <code>set</code> as a predicate when appropriate.</p> <p>[source,clojure] <pre><code>;; good\n(remove #{1} [0 1 2 3 4 5])\n\n;; bad\n(remove #(= % 1) [0 1 2 3 4 5])\n\n;; good\n(count (filter #{\\a \\e \\i \\o \\u} \"mary had a little lamb\"))\n\n;; bad\n(count (filter #(or (= % \\a)\n                    (= % \\e)\n                    (= % \\i)\n                    (= % \\o)\n                    (= % \\u))\n               \"mary had a little lamb\"))\n</code></pre></p>"},{"location":"clojure-design/idioms/#inc-and-dec-inc-and-dec","title":"<code>inc</code> and <code>dec</code> [[inc-and-dec]]","text":"<p>Use <code>(inc x)</code> &amp; <code>(dec x)</code> instead of <code>(+ x 1)</code> and <code>(- x 1)</code>.</p>"},{"location":"clojure-design/idioms/#pos-and-neg-pos-and-neg","title":"<code>pos?</code> and <code>neg?</code> [[pos-and-neg]]","text":"<p>Use <code>(pos? x)</code>, <code>(neg? x)</code> &amp; <code>(zero? x)</code> instead of <code>(&gt; x 0)</code>, <code>(&lt; x 0)</code> &amp; <code>(= x 0)</code>.</p>"},{"location":"clojure-design/idioms/#list-vs-cons-list-star-instead-of-nested-cons","title":"<code>list*</code> vs <code>cons</code> [[list-star-instead-of-nested-cons]]","text":"<p>Use <code>list*</code> instead of a series of nested <code>cons</code> invocations.</p> <p>[source,clojure] <pre><code>;; good\n(list* 1 2 3 [4 5])\n\n;; bad\n(cons 1 (cons 2 (cons 3 [4 5])))\n</code></pre></p>"},{"location":"clojure-design/idioms/#sugared-java-interop-sugared-java-interop","title":"Sugared Java Interop [[sugared-java-interop]]","text":"<p>Use the sugared Java interop forms.</p> <pre><code>;;; object creation\n;; good\n(java.util.ArrayList. 100)\n\n;; bad\n(new java.util.ArrayList 100)\n\n;;; static method invocation\n;; good\n(Math/pow 2 10)\n\n;; bad\n(. Math pow 2 10)\n\n;;; instance method invocation\n;; good\n(.substring \"hello\" 1 3)\n\n;; bad\n(. \"hello\" substring 1 3)\n\n;;; static field access\n;; good\nInteger/MAX_VALUE\n\n;; bad\n(. Integer MAX_VALUE)\n\n;;; instance field access\n;; good\n(.someField some-object)\n\n;; bad\n(. some-object someField)\n</code></pre>"},{"location":"clojure-design/idioms/#compact-metadata-notation-for-true-flags-compact-metadata-notation-for-true-flags","title":"Compact Metadata Notation For True Flags [[compact-metadata-notation-for-true-flags]]","text":"<p>Use the compact metadata notation for metadata that contains only slots whose keys are keywords and whose value is boolean <code>true</code>.</p> <p>[source,clojure] <pre><code>;; good\n(def ^:private a 5)\n\n;; bad\n(def ^{:private true} a 5)\n</code></pre></p>"},{"location":"clojure-design/idioms/#private","title":"Private","text":"<p>Denote private parts of your code.</p> <p>[source,clojure] <pre><code>;; good\n(defn- private-fun [] ...)\n\n(def ^:private private-var ...)\n\n;; bad\n(defn private-fun [] ...) ; not private at all\n\n(defn ^:private private-fun [] ...) ; overly verbose\n\n(def private-var ...) ; not private at all\n</code></pre></p>"},{"location":"clojure-design/idioms/#access-private-var-access-private-var","title":"Access Private Var [[access-private-var]]","text":"<p>To access a private var (e.g. for testing), use the <code>@#'some.ns/var</code> form.</p>"},{"location":"clojure-design/idioms/#attach-metadata-carefully-attach-metadata-carefully","title":"Attach Metadata Carefully [[attach-metadata-carefully]]","text":"<p>Be careful regarding what exactly you attach metadata to.</p> <p>[source,clojure] <pre><code>;; we attach the metadata to the var referenced by `a`\n(def ^:private a {})\n(meta a) ;=&gt; nil\n(meta #'a) ;=&gt; {:private true}\n\n;; we attach the metadata to the empty hash-map value\n(def a ^:private {})\n(meta a) ;=&gt; {:private true}\n(meta #'a) ;=&gt; nil\n</code></pre></p>"},{"location":"clojure-design/naming/","title":"Naming","text":"<ul> <li>functions (defn, fn)</li> <li>data (def)</li> <li>namespaces</li> <li>require aliases</li> <li>specifications</li> </ul>"},{"location":"clojure-repl/","title":"Clojure REPL","text":"<p>Use the Clojure repl to</p> <ul> <li>call functions from clojure core</li> <li>create symbol names (def) that represent a value</li> <li>write custom functions (defn) and call them with data</li> <li>see immediate results when evaluating code</li> </ul>"},{"location":"clojure-repl/#getting-started","title":"Getting Started","text":"<p> Install Clojure CLI and Practicalli Clojure CLI Config for a comprehensive set of developmet tools.</p> <p>Use a  terminal UI REPL as a quick way to get started, or set up a preferred  Clojure editor.</p> Editor Connected REPL <p>An  Editor connected REPL is recommended once working with Clojure projects</p> <p>Create a Clojure project from a template</p> <p><code>:project/create</code> alias from  Practicalli Clojure CLI Config will create a Clojure project structure  <pre><code>clojure -T:project/create :name github-name/project-name\n</code></pre></p>"},{"location":"clojure-repl/#terminal-ui-repl","title":"Terminal UI REPL","text":"<p>Rebel Readline provides a rich REPL experience, providing syntax highlighting, function signatures and documentation.</p> <p>The REPL can be used with or without a Clojure project.</p> <p>Start Rebel Readline REPL using the <code>:repl/rebel</code> alias provided by  Practicalli Clojure CLI Config</p> <pre><code>clojure -M:repl/rebel\n</code></pre> <p> Rebel REPL Terminal UI</p> <p> </p>"},{"location":"clojure-repl/#clojure-editors","title":"Clojure Editors","text":"<p>Clojure editors are the preferred way to write code and evaluating source code.  Working with source files is more effective than entering all expressions directly at a REPL prompt.</p> <p>Use an editor to jack-in (start) a Clojure REPL process and connect to the running REPL.</p> <p>Or connect to a running REPL process, e.g. Rebel Terminal UI (over a network repl, nREPL).</p> <p>Use an editor that is most familiar or comfortable to minimise the learning curve.</p> <p>Clojure editors should provide</p> <ul> <li>running / connecting to a REPL process</li> <li>evaluation results inline (instant feedback on code behaviour)</li> <li>syntax highlighting, including parens matching</li> <li>Structural editing, balancing parens (paredit / parinfer)</li> <li>data inspector to navigate large &amp; nested data, or connection to external  data inpector tools</li> </ul> <p> Clojure aware editors</p> <p></p>"},{"location":"code-challenges/","title":"Coding Challenges for Clojure","text":"<p>Coding challenges are an excellent way to start learning a new language.  The challenges allow you to focus on the language and not be concerned about the more general engineering aspects of software development.</p> <p>Challenges are there to explore a language and practice your understanding of how to assemble working code.  It is recommended to try different approaches to solving a challenges and even repeat the same challenges at a later date and see what additional approaches you have learned.</p> <p>Exercism.io and 4Ever-Clojure are highly recommended starting point for learning Clojure and does not require any installation or setup.  4Ever-Clojure is a new implementation of 4Clojure.com.</p>"},{"location":"code-challenges/#approach-to-solving-challenges","title":"Approach to solving challenges","text":"<p>Take a few minutes to digest the description of the challenge and make notes.</p> <p>Identify the simplest possible thing to do, solving the problem in many small pieces which encourages experimentation</p> <ul> <li>experiment, write code and evaluate to see what it does (optionally create a comment with the result)</li> <li>use a rich comment <code>(comment ,,,)</code> to capture multiple ideas and designs, even failed experiments can be useful (separates experiments from working code)</li> <li>continually evaluate code as expressions are written, to ensure their behaviour is understood (try different argument values for functions)</li> <li>try different shapes of data</li> <li>transform data shapes to keep function definitions simpler</li> </ul> <p>Once there is a working solution, refactor or try different approaches and evaluate the merit of alternative solutions</p> Challenge website Description Requirements 4Ever-Clojure Learning the core functions of the Clojure language Web Browser Exercism.io Coding exercises with mentor support Web Browser (local: Exercism CLI, Clojure CLI &amp; Clojure aware editor ClojureScript Koans Interactive exercises in a web browser Web Browser Simple Projects Challenge that can be solved in one session Clojure aware editor TDD Code Kata Challenge that can be solved in one session Clojure aware editor Advent of Code Yearly coding challenge with a seasonal theme Clojure aware editor CodeWars Mostly math-based coding challenges with Clojure variants Web Browser"},{"location":"code-challenges/advent-of-code/","title":"Advent Of Code","text":""},{"location":"code-challenges/advent-of-code/#advent-of-code","title":"Advent Of Code","text":"<p>Advent of Code is the annual coding challenge with a festive theme.  Each day there is a new challenge in two parts, the first fairly easy the second a little more involved.  The challenges are an investment of your time to complete them all, although even trying just a few is enough to help you think in different ways.</p> <p>Every programming language requires regular practice to maintain your skills.  A full time developer role gives lots of opportunities to practice every day, however, its often focused in around solving problems within a specific business domain, with little time to explore others.  The Advent of Code puts you in a different domain, so its great for extending your coding experiences.</p> <p>Solving challenges in a different language is another great way to extend your experiences, so here are some tips and examples for solving the advent of code in Clojure.</p>"},{"location":"code-challenges/advent-of-code/#solving-challenges","title":"Solving challenges","text":"<ul> <li>Keep the solution as simple as possible.  Its very easy to over-complicate the solution and end up simply confusing yourself.</li> <li>Don't try and make the perfect solution.  Write something that works, this will give you a nice ego boost.  Then you can experiment with the code and see if you can improve your approach.</li> <li>Break down the problem into the simplest thing you can solve first.  Trying to solve a problem all at once will quickly have you going around in circles.</li> <li>Keep all the code and make notes.  I use a a design journal in my projects to document my thinking process, capture decisions that worked and those that didn't work for this project.  The journal is a great way to cement learning from solving the challenge.</li> <li>Challenges are only accessible from their day of the month onwards.  There is a count-down clock displayed on the next challenge to open, so you know when it will be available.  Don't feel pressured to keep up with the challenges though, enjoy the experience and have fun, you will learn more that way.</li> </ul>"},{"location":"code-challenges/advent-of-code/#coding-video","title":"Coding video","text":"<p>A video guide to solving the first challenge of Advent of Code from 2018, trying out different solutions at increasing levels of abstraction.  With each level of abstraction it helps to think in a more functional way.</p> <p> </p>"},{"location":"code-challenges/advent-of-code/#creating-a-project-for-the-challenge","title":"Creating a project for the challenge","text":"<pre><code>clojure -T:project/create :template lib practicalli.advent-of-clojure-code/2019\n</code></pre> <p>Create a new Clojure file for each of the daily challenges.  It makes sense to keep both parts of each day in the same file.</p> <p>Practicalli Advent Of Code solutions repository</p> <p>practicalli/advent-of-clojure-code-2019</p>"},{"location":"code-challenges/advent-of-code/#useful-resources-and-examples","title":"Useful Resources And Examples","text":"<p>Videos and code solutions to many challenges from 2019 and past years.</p> <ul> <li>fdlk/advent-2019 - example Clojure solutions to the advent of code</li> <li>Awesome Advent Of Code - a collection of solutions in various languages</li> <li>Advent of Code 2018 video walk-through of Clojure solutions by Tim Pote and GitHub repository</li> </ul> <p>#adventofcode channel in the Clojurians slack channel discusses challenges and solutions, especially during December when the challenge takes place.</p>"},{"location":"code-challenges/koans/","title":"ClojureScript Koans","text":"<p>Koans are a collection of small challenges that slowly increase in complexity.  They are similar to the 4Clojure challenges in scope.</p>"},{"location":"code-challenges/koans/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"code-challenges/4ever-clojure/","title":"Coding Challenges: 4Clojure","text":"<p>4Ever-Clojure Challenges Website</p> <p>4Ever-Clojure is a simple website with 150 challenges to help discover the functions built-in to the Clojure language, the Clojure API.</p> <p>The website is self-contained with nothing to install, simply paste in the missing code and run the tests.  One piece of code should solve all the tests for that challenge.</p> <p>The Problem List shows the challenges categorized by experience level required, (Elementary, Easy, Medium, Hard) to solve them.  Start with the easiest problem or work your way through the challenges in any order you wish.  The Status column tracks your progress thorugh the challenges.</p> <p>Select the name of a challenge to see the description and one or more code tests that must pass.</p> <p>Enter the code that should be inserted where the <code>__</code> double underscore characters are.</p> <p>Press the Run button to see if the code satisfies the tests</p> <p>A dialog box is displayed showing how many tests have passed and failed</p> <p>Start learning the Clojure API</p> <p>There are over 600 functions in the <code>clojure.core</code> namespace alone, with additional functions in many other namespaces that make up the https://clojure.github.io/clojure/.  It is not required to learn all these functions to be productive in Clojure.</p> 4ever-clojure replaces 4Clojure <p>4Ever-Clojure is a new implementation of 4Clojure.com which has now been decommissioned</p>"},{"location":"code-challenges/4ever-clojure/#help-completing-the-challenges","title":"Help completing the challenges","text":"<p>Look at the Clojure Cheatsheet and Clojure API for an understanding of what functions are available in the core of the Clojure language.</p> <p>Search directly in ClojureDocs for functions.  Each function has a page that describes the function, shows the arguments it takes and provides many examples of its use.  At the end of the page are related functions too.</p> <p>Practicalli Code walk-through and solution journal</p> <p>practicalli/four-clojure code journals for the first 60 challenges contains a design journal showing how each challenge was solved and additional refactor or alternative approaches to the solution.</p> <p>Practicalli 4Clojure guides playlist provides video walk-through of the first 64 challenges, again with alternative solutions where relevant.</p> <p>An Internet search of <code>clojure topic</code>, where <code>topic</code> is a name of the thing you want to do, should return many examples of functions that could be useful to solving the challenge.  Or</p> <p>Help from the community</p> <p>Clojure community - getting help covers several sources of help from the Clojure community.</p>"},{"location":"code-challenges/4ever-clojure/#using-let-and-anonymous-functions","title":"Using let and anonymous functions","text":"<p>The solution submitted should be a single form, which is inserted in the test code where the <code>__</code> underscore placeholder is.  It is therefore not possible to define data with <code>def</code> or a separate function with <code>defn</code> to support the submitted solution.</p> <p>Use the anonymous function, <code>(fn [])</code>, to define behaviour.</p> <pre><code>(fn [value1 value2]\n  (* value1 value2))\n</code></pre> <p>Use let to bind a name to a value, so that value can be re-used throughout the expression.  <code>let</code> is also useful for breaking the algorithm into smaller pieces, making it easier to solve the challenge.</p> <pre><code>(let [name value]\n  (* 2 value (/ value 4) (+ value 3)))\n</code></pre> <p>It is common to combine <code>fn</code> and <code>let</code> to solve the challenges as they grow in complexity</p> <pre><code>(fn fibonacci [length-of-series]\n  (let [fib [1 1]]\n    (if (&lt; (count fib) length-of-series)\n      \"iterate... to implement\"\n      fib)))\n</code></pre> <ul> <li>fn - ClojureDocs</li> <li>let - ClojureDocs</li> <li>Fibonacci sequence guide - practicalli</li> </ul>"},{"location":"code-challenges/4ever-clojure/#my-function-is-not-working","title":"My function is not working","text":"<p>4Ever Clojure uses babashka/sci project to evaluate code on a JavaScript host.  Whist this should cover 99.9% of the Clojure API there may be some code that works in a Clojure (JVM) REPL that is not supported.</p> <p>Try the code in a Clojure REPL or create a Clojure project using the latest version of Clojure (1.11.x).</p>"},{"location":"code-challenges/4ever-clojure/#references","title":"References","text":"<ul> <li>4Ever-Clojure</li> <li>Clojure Cheatsheet - Clojure.org</li> <li>Clojure API - Clojure.org</li> <li>practicalli/four-clojure code journals for the first 60 challenges</li> <li>4Clojure video guides by Practicalli</li> <li>Clojure Core Library - ClojureDocs</li> <li>Clojure, The Essential Reference - Renzo Bogatti - Manning book published in 2020</li> </ul>"},{"location":"code-challenges/code-kata/","title":"Code Kata","text":"<p>A kata is a small challenge that you attempt to solve in different ways, to experiment with alternative solutions to a challenge and widen experience.</p> <p>Kata help gain understanding in a wider range of Clojure functions and ways to represent values in Clojure.</p> <p>Code Kata can also be used to practice a Test Driven Development (TDD) approach.</p>"},{"location":"code-challenges/code-kata/#guided-challenges","title":"Guided Challenges","text":"<p>Challenges with design journals that describe and demonstrate different design choices and constraints.</p> Project Topics Overview Recent song-list TDD Keep a list of recent songs played, without duplicates Salary Slip Generator TDD Generate play slips for an employee Palindrome transforming data structures"},{"location":"code-challenges/code-kata/#resources","title":"Resources","text":"<p>External sites with example kata challenges</p> <ul> <li>Awesome Kata collection</li> <li>Alice In Wonderland inspired Katas</li> </ul> <p>Code Kata Website</p> <p></p>"},{"location":"code-challenges/code-kata/recent-song-list/","title":"TDD Kata Recent Song-list","text":"<p>Create a recent song list to hold a unique set of songs that have been played.</p> <p>The most recently played song is at the start of the list, the least recently played song is the last in the list.</p> <ul> <li>A recently-used-list is initially empty.</li> <li>Songs in the list are unique, so repeatedly played songs should only appear once in the list</li> <li>Songs can be looked up by index, which counts from zero.</li> <li>The song list can be transitory (starting from empty each time) or persistent within a REPL session (examples use a transitory approach)</li> </ul> <p>Optional extras:</p> <ul> <li>Empty song names are not allowed.</li> <li>Add a limit to the number of songs the list contains, with the least recently added items dropped when that limit is reached.</li> </ul>"},{"location":"code-challenges/code-kata/recent-song-list/#create-project","title":"Create Project","text":"<p>Create a new project using clj-new</p> <pre><code>clojure -T:project/create practicalli/song-list\n</code></pre>"},{"location":"code-challenges/code-kata/recent-song-list/#run-repl","title":"Run REPL","text":"<p>Start a Clojure REPL via a Clojure editor or via the command line from the root of the project directory</p> <p>Start rich terminal UI Clojure REPL</p> <pre><code>clojure -M:repl/rebel\n</code></pre>"},{"location":"code-challenges/code-kata/recent-song-list/#unit-tests","title":"Unit Tests","text":"<p><code>clojure.test</code> library is part of Clojure standard library and is the most common way to write unit tests in Clojure</p> <p>Open <code>test/playground/song_list_test.clj</code> file in your editor and update the namespace definition to include <code>clojure.test</code></p> <p>Require clojure.test namespace</p> test/playground/song_list_test.clj<pre><code>(ns practicalli.song-list-test\n  (:require [clojure.test :refer [deftest is testing]]\n            [playground.song-list :as song-list]))\n</code></pre>"},{"location":"code-challenges/code-kata/recent-song-list/#run-tests","title":"Run Tests","text":"<p>Evaluate the <code>practicalli.song-list</code> and <code>practicalli.song-list-test</code> namespaces to load their code into the REPL</p> <p>Call the <code>run-tests</code> function in the REPL to get a report back on all of the tests in our current namespace (<code>song-list</code>)</p> Kaocha test runnerclojure.test runner <p> Practicall Clojure CLI Config provides the <code>:test/run</code> alias to run the Kaocha test runner.</p> <p>Kaocha test runner</p> <p>Open a command line in the root directory of the project and run the following command. <pre><code>clojure -X:test/run\n</code></pre></p> <p>Kaocha runs all the tests, stopping should a test fail.</p> <p>Kaocha test runner with file watch</p> <p>Use the <code>:test/watch</code> alias to automatically run tests when ever a file is saved <pre><code>clojure -X:test/run\n</code></pre></p> <p>Evaluate the project code and evaluate the <code>run-tests</code> function from <code>clojure.test</code> from within the REPL</p> <p>clojure.test runner</p> <pre><code>(run-tests)\n</code></pre>"},{"location":"code-challenges/code-kata/recent-song-list/#test-song-list-exists","title":"Test song-list exists","text":"<p>Write a test to see if a recent song list exists.</p> <p>This is an opportunity to think about what kind of data structure you want to use to hold your recent song list.</p> <p>Try write the code first and then check that code with the examples provided (click to expand each code example box)</p> Test song-list exists <p>A simple test that checks for a <code>recent-songs</code> list src/playground/song_list.clj<pre><code>(deftest song-list-exists-test\n  (testing \"Does a recent song list exist\"\n    (is (vector? song-list/recent-songs))))\n</code></pre> <code>recent-songs</code> should be defined in <code>src/playground/recent-song-list.clj</code> before running the test, otherwise a compilation error will be returned.</p>"},{"location":"code-challenges/code-kata/recent-song-list/#define-a-recent-song-list","title":"Define a recent song list","text":"<p>Edit <code>src/playground/song_list.clj</code> and define a name for the collection of recent songs</p> <p>Use an empty collection to start with.  Which collection type will you use though (hash-map <code>{}</code>, list <code>()</code>, set <code>#{}</code>, vector <code>[]</code>)?</p> recent-songs collection <p>Define a recent-song name for an empty vector src/playground/song_list.clj<pre><code>(def recent-songs [])\n</code></pre></p> Test First Approach <p>For a strict test first approach, a <code>recent-songs</code> name (symbol) would be defined that returns <code>false</code> or a falsy value, e.g. <code>nil</code></p> <p>A name (symbol) must be defined for use in the test so that the Clojure code can compile</p>"},{"location":"code-challenges/code-kata/recent-song-list/#test-song-list-is-empty","title":"Test song-list is empty","text":"<p>The recent song list should be empty to start with.</p> Check song list is empty <p>A simple test that compares an empty vector with the value of <code>recent-songs</code> src/playground/song_list.clj<pre><code>(deftest song-list-empty-test\n  (testing \"Is song list empty if we haven't added any songs\"\n    (is\n     (= [] song-list/recent-songs))))\n</code></pre></p> <p>Here is the same test using the <code>empty?</code> function instead of the <code>=</code> function.</p> <p>src/playground/song_list.clj<pre><code>(deftest song-list-empty-test\n  (testing \"Is song list empty if we haven't added any songs\"\n    (is\n     (empty? song-list/recent-songs))))\n</code></pre> Either of these tests could replace the test that the song list exists, as these tests would fail if the song list did not exist.</p>"},{"location":"code-challenges/code-kata/recent-song-list/#test-adding-a-song-to-the-list","title":"Test adding a song to the list","text":"<p>Add a song to the collection, for example <code>Tubular Bells - Mike Oldfield</code></p> Test adding a song to the list test/playground/song_list_test.clj<pre><code>(deftest add-songs-test\n\n  (testing \"add song returns a song list with entries\"\n    (is\n     (not (empty?\n           (add-song \"Barry Manilow - Love on the rocks\" song-list/recent-songs)))))\n\n  (testing \"add multiple song returns a song list with entries\"\n    (is\n     (not (empty?\n           (-&gt;&gt; song-list/recent-songs\n             (add-song \"Mike Oldfield - Tubular Bells Part 1\")\n             (add-song \"Barry Manilow - Love on the rocks\")\n             (add-song \"Phil Colins - Sususudio\" )))))))\n</code></pre> <p>Other songs are avialbe and Practicalli makes no recommendation as to what songs should be used or listened too.</p>"},{"location":"code-challenges/code-kata/recent-song-list/#function-to-add-song","title":"Function to add song","text":"<p>Create a function to add a song to the start of the song list.</p> Function to add song to list <p>The <code>add-song</code> function takes the name of a song and the song list to which it will be added.</p> <p>A Thread-last macro <code>-&gt;&gt;</code> is used to pass the song list over two functions.</p> <p>The <code>song-list</code> is first passed to the <code>remove</code> expression as its last argument.  This expression will remove any occurrence of the new song we want to add from the <code>song-list</code>.</p> <p>The results of the <code>remove</code> expression are then passed to the <code>cons</code> expression as its last argument.  The <code>cons</code> expression simply adds the new song to the start of the list, making it the most recent song.</p> src/playground/song_list.clj<pre><code>(def recent-songs [])\n\n(defn add-song [song song-list]\n  (cons song song-list))\n</code></pre> <p><code>recent-songs</code> is passed into the <code>add-song</code> function as an argument, <code>song-list</code> to keep the design of <code>add-song</code> function pure (no side-effects).  This design also provides greater scope to using the <code>add-song</code> function, as any song list can be added to, rather than hard-coding <code>recent-songs</code> list.</p>"},{"location":"code-challenges/code-kata/recent-song-list/#test-song-added-to-top-of-list","title":"Test song added to top of list","text":"<p>As the song list shows recently played songs, new songs added should be at the top of the list.</p> <p>The list should not contain duplicate entries for a song.</p> Test songs added to top of list test/playground/song_list_test.clj<pre><code>(deftest recently-added-song-first-test\n\n  (testing \"most recent song should be first in the list when empty list\"\n    (is (=\n         (first (add-song \"Daft Punk - Get Lucky\" recent-songs))\n         \"Daft Punk - Get Lucky\")))\n\n  (testing \"most recent song should be first in list when adding multiple songs\"\n    (is (=\n         (first\n          (-&gt;&gt; recent-songs\n               (add-song \"Daft Punk - Get Lucky\")\n               (add-song \"Pharrell Williams - Happy\")))\n         \"Pharrell Williams - Happy\")))\n\n  (testing \"most recent song should be first in list when adding a repeated song\"\n    (is (=\n         (first\n          (-&gt;&gt; recent-songs\n               (add-song \"Pharrell Williams - Happy\")\n               (add-song \"Daft Punk - Get Lucky\")\n               (add-song \"Pharrell Williams - Happy\")))\n         \"Pharrell Williams - Happy\")))\n\n  (testing \"most recent song should be first in list when adding a repeated song\"\n    (is (not=\n         (last\n          (-&gt;&gt; recent-songs\n               (add-song \"Pharrell Williams - Happy\")\n               (add-song \"Daft Punk - Get Lucky\")\n               (add-song \"Pharrell Williams - Happy\")))\n         \"Pharrell Williams - Happy\"))))\n</code></pre>"},{"location":"code-challenges/code-kata/recent-song-list/#add-song-to-start-of-list","title":"Add song to start of list","text":"<p>Create a function to add a song to the start of the song list.</p> Function to add song to list <p>The <code>add-song</code> function takes the name of a song and the song list to which it will be added.</p> <p>A Thread-last macro <code>-&gt;&gt;</code> is used to pass the song list over two functions.</p> <p>The <code>song-list</code> is first passed to the <code>remove</code> expression as its last argument.  This expression will remove any occurrence of the new song we want to add from the <code>song-list</code>.</p> <p>The results of the <code>remove</code> expression are then passed to the <code>cons</code> expression as its last argument.  The <code>cons</code> expression simply adds the new song to the start of the list, making it the most recent song.</p> src/playground/song_list.clj<pre><code>(def recent-songs [])\n\n(defn add-song [song song-list]\n  (-&gt;&gt; song-list\n       (remove #(= song %))\n       (cons song)))\n</code></pre> <p><code>recent-songs</code> is passed into the <code>add-song</code> function as an argument, <code>song-list</code> to keep the design of <code>add-song</code> function pure (no side-effects).  This design also provides greater scope to using the <code>add-song</code> function, as any song list can be added to, rather than hard-coding <code>recent-songs</code> list.</p>"},{"location":"code-challenges/code-kata/salary-slip-generator/","title":"Salary Slip Kata","text":"<p> Pracitcalli Clojure CLI Config provides the <code>:project/create</code> alias to create projects using deps-new project.</p> <pre><code>clojure -T:project/create :template app :name practicalli/salary-calculator\n</code></pre>"},{"location":"code-challenges/code-kata/salary-slip-generator/#problem-description","title":"Problem description","text":"<p>A typical salary slip contains employee details like employee id, employee name and their monthly salary details like their gross salary, national insurance contributions, tax-free allowance, taxable income and tax payable.</p> <p>Salary slips are generated each month for every employee.</p>"},{"location":"code-challenges/code-kata/salary-slip-generator/#acceptance-criteria","title":"Acceptance criteria","text":"<ul> <li>Salary slip generator should receive an employee with its Employee Id, Employee Name and Annual Gross Salary</li> <li>Salary slip should contain the Employee ID, Employee Name, Gross Salary, National Insurance contributions, Tax-free allowance, Taxable income and Tax payable for the month</li> <li>The entry point should be the following public function API</li> </ul> <pre><code>(defn salary-slip-generator\n  \"\"\n  [employee]\n  ,,,)\n</code></pre>"},{"location":"code-challenges/code-kata/salary-slip-generator/#iterations","title":"Iterations","text":"<p>Each iteration adds more rules to the calculation. Some iterations also introduce new fields to the salary slip.</p> <p>In a given iteration, all the salary slips contain the same number fields for each employee (if a tax or contribution does not apply for a given employee, just put \u00a30.00).</p> <p>This means that for each iteration you will need to add fields to the <code>SalarySlip</code> class. In the first iteration, <code>SalarySlip</code> only contains the Employee ID, Employee Name and Monthly Gross Salary.</p>"},{"location":"code-challenges/code-kata/salary-slip-generator/#iteration-1-for-an-annual-salary-of-500000","title":"Iteration 1: for an annual salary of \u00a35,000.00","text":"<p>This is the most basic case.</p> <ul> <li>Given I have an employee John J Doe with an annual gross salary of \u00a35,000.00</li> <li>When I generate a monthly salary slip for the employee</li> <li>Then the monthly salary slip should contain the below<pre><code>   Employee ID: 12345\n   Employee Name: John J Doe\n   Gross Salary: \u00a3416.67\n</code></pre> </li> </ul> <p>Calculation rules:</p> <ul> <li>Monthly Gross Salary: The monthly gross salary is the employee's annual gross salary divided by 12</li> </ul>"},{"location":"code-challenges/code-kata/salary-slip-generator/#iteration-2-for-an-annual-gross-salary-of-906000","title":"Iteration 2: for an annual gross salary of \u00a39,060.00","text":"<p>Here we introduce the National Insurance contribution</p> <p>The monthly salary slip should contain the below:</p> <pre><code>       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a3755.00\n       National Insurance contributions: \u00a310.00\n</code></pre> <p>Calculation rules:</p> <ul> <li>National Insurance contributions: Any amount of money earned above a gross annual salary of \u00a38,060.00 is subject to a National Insurance contribution of 12%</li> </ul>"},{"location":"code-challenges/code-kata/salary-slip-generator/#iteration-3-for-an-annual-gross-salary-of-1200000","title":"Iteration 3: for an annual gross salary of \u00a312,000.00","text":"<p>This employee also needs to pay taxes</p> <p>The monthly salary slip should contain the below:</p> <pre><code>       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a31,000.00\n       National Insurance contributions: \u00a339.40\n       Tax-free allowance: \u00a3916.67\n       Taxable income: \u00a383.33\n       Tax Payable: \u00a316.67\n</code></pre> <p>Calculation rules:</p> <ul> <li>Taxable income: Any amount of money earned above a gross annual salary of \u00a311,000.00 is taxed at 20%</li> </ul>"},{"location":"code-challenges/code-kata/salary-slip-generator/#iteration-4-for-an-annual-gross-salary-of-4500000","title":"Iteration 4: for an annual gross salary of \u00a345,000.00","text":"<p>This employee pays a higher band of National Insurance and Income Tax.</p> <p>The monthly salary slip should contain the below:</p> <pre><code>       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a33,750.00\n       National Insurance contributions: \u00a3352.73\n       Tax-free allowance: \u00a3916.67\n       Taxable income: \u00a32,833.33\n       Tax Payable: \u00a3600.00\n</code></pre> <p>Calculation rules:</p> <ul> <li>Taxable income (higher rate): Any amount of money earned above a gross annual salary of \u00a343,000.00 is taxed at 40%</li> <li>National Insurance (higher contributions): Any amount of money earned above a gross annual salary of \u00a343,000.00 is only subject to a 2% NI contribution</li> </ul>"},{"location":"code-challenges/code-kata/salary-slip-generator/#iteration-5-for-annual-gross-salaries-of-10100000-11100000-12200000-and-15000000","title":"Iteration 5: for annual gross salaries of \u00a3101,000.00; \u00a3111,000.00; \u00a3122,000.00 and \u00a3150,000.00","text":"<p>For high earners, the tax-free allowance decreases.</p> <p>The monthly salary slips should contain the below (respectively):</p> <pre><code>       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a38,416.67\n       National Insurance contributions: \u00a3446.07\n       Tax-free allowance: \u00a3875.00\n       Taxable income: \u00a37,541.67\n       Tax Payable: \u00a32,483.33\n\n\n       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a39,250.00\n       National Insurance contributions: \u00a3462.73\n       Tax-free allowance: \u00a3458.33\n       Taxable income: \u00a38,791.67\n       Tax Payable: \u00a32,983.33\n\n\n       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a310,166.67\n       National Insurance contributions: \u00a3481.07\n       Tax-free allowance: \u00a30.00\n       Taxable income: \u00a310,166.67\n       Tax Payable: \u00a33,533.33\n\n\n       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a312,500.00\n       National Insurance contributions: \u00a3527.73\n       Tax-free allowance: \u00a30.00\n       Taxable income: \u00a312,500.00\n       Tax Payable: \u00a34,466.67\n</code></pre> <p>Calculation rules:</p> <ul> <li>Tax-free allowance: When the Annual Gross Salary exceeds \u00a3100,000.00, the tax-free allowance starts decreasing. It decreases by \u00a31 for every \u00a32 earned over \u00a3100,000.00. And this excess is taxed at the Higher rate tax.</li> </ul>"},{"location":"code-challenges/code-kata/salary-slip-generator/#iteration-6-for-an-annual-gross-salary-of-16000000","title":"Iteration 6: for an annual gross salary of \u00a3160,000.00","text":"<p>The employee goes into the additional rate band.</p> <p>The monthly salary slip should contain the below:</p> <pre><code>      Employee ID: 12345\n      Employee Name: John J Doe\n      Gross Salary: \u00a313,333.33\n      National Insurance contributions: \u00a3544.40\n      Tax-free allowance: \u00a30.00\n      Taxable income: \u00a313,333.33\n      Tax Payable: \u00a34,841.67\n</code></pre> <p>Calculation rules:</p> <ul> <li>Income tax (additional rate band) : Any amount of money earned above a gross annual salary of \u00a3150,000.00 is taxed at 45%</li> </ul> Practicalli Salary Slip Kata <p>  ```clojure (ns salary-slip-kata.core)</p> <p>;; Developer Anarchy by Fred George ;; - made devs write the same solution in different languages ;; -- helps devs master the business domain ;; -- helps devs master technology domain</p> <p>(defn- national-insurance-contribution   \"Calculate the national insurance contribution due for a given annual salary.</p> <p>---------------------+-------------------------+--------   Band                 | NI deductible income    | NI Rate   ---------------------+-------------------------+--------   No contributions     | Up to \u00a38,060.00         |    0%   Basic contributions  | \u00a38,060.00 to \u00a343,000.00 |   12%   Higher contributions | over \u00a343,000.00         |    2%   ---------------------+-------------------------+-------- \"</p> <p>[annual-gross-salary]   ;; add a cond statement to return the calculate the value with respect to the band.   (* annual-gross-salary 0.12))</p> <p>;; taxable income ;; ---------------------+---------------------------+--------- ;; Band                 | Taxable income            | Tax rate ;; ---------------------+---------------------------+--------- ;; Personal Allowance*  | Up to \u00a311,000.00          |    0% ;; Basic rate           | \u00a311,000.00 to \u00a343,000.00  |   20% ;; Higher rate          | \u00a343,000.00 to \u00a3150,000.00 |   40% ;; Additional rate      | over \u00a3150,000.00          |   45% ;; ---------------------+---------------------------+---------</p> <p>(defn salary-slip   \"Creates a salary slip for a person</p> <p>Specifically for employee of 24K annual salary\"</p> <p>[{:keys [employee-id            employee-name            annual-gross-salary]}]   (let [tax-free-allowance 11000         taxable-income     (- annual-gross-salary                               tax-free-allowance)]     {:employee-id        employee-id      :employee-name      employee-name      :gross-salary       (/ annual-gross-salary 12)      :national-insurance (national-insurance-contribution annual-gross-salary)      :tax-free-allowance tax-free-allowance      :taxable-income     taxable-income      :tax-payable        (* taxable-income 0.20)}))     ```</p>"},{"location":"code-challenges/code-kata/palindrome/","title":"Project Palindrome","text":"<p>In this section we will create a simple Clojure project using Leiningen and build up a palindrome checker step by step.</p> <p>We will start with the simplest possible thing we can create and steadily add</p>"},{"location":"code-challenges/code-kata/palindrome/#what-is-a-palindrome","title":"What is a Palindrome","text":"<p>For this project it is assumed that a palindrome is a string of characters from the English alphabet and not any other language or an alphanumeric sequence.</p> <p>It is assumed that a palindrome is at least 3 characters long, meaning a single character cannot be a palindrome.  If a single character was a palindrome, then any valid sequence would contain at least as many palindromes as characters in that sequence.</p>"},{"location":"code-challenges/code-kata/palindrome/#task-set","title":"Task set","text":"<p>Write an algorithm to find the 3 longest unique palindromes in a string. For the 3 longest palindromes, report the palindrome, start index and length in descending order of length. Any tests should be included with the submission.</p> <p>For example, the output for string, \"sqrrqabccbatudefggfedvwhijkllkjihxymnnmzpop\" should be:</p> <pre><code>Text: hijkllkjih, Index: 23, Length: 10\nText: defggfed, Index: 13, Length: 8\nText: abccba, Index: 5 Length: 6\n</code></pre> <ul> <li>Check for a palindrome</li> <li>Generate a series of palindromes</li> </ul>"},{"location":"code-challenges/code-kata/palindrome/simple-palindrome-test/","title":"Simple palindrome test","text":""},{"location":"code-challenges/codewars/","title":"CodeWars","text":"<p>Coding challenges in various languages with ranking scoreboard, experience levels and voting on solutions.  Many of the challenges tend toward mathematics, so may require some background research before solving them.</p>"},{"location":"code-challenges/codewars/#requirements","title":"Requirements","text":"<p>Codewars is a web browser based system in which you can write code and run tests.  Sample unit tests are provided with each challenge, so its all self-contained.</p> <p>Create a free account and select the language you wish to attempt challenges in.  Two simple coding tests will need to be completed in order to access that specific language.</p>"},{"location":"code-challenges/codewars/#challenges-dashboard","title":"Challenges Dashboard","text":"<p>After logging in, the dashboard suggests a challenge for you at a suitable level.  8 kyu is the easiest level, the smaller the number the harder the challenge.</p> <p></p>"},{"location":"code-challenges/codewars/#tackling-a-challenge","title":"Tackling a challenge","text":"<p>Read the instructions and take a look at the sample tests.</p> <p>Many of the challenges have only a very basic explanation, so always review the sample unit tests to help with the understanding.  The sample tests are not necessarily the full suite of tests run when testing your solution, so there may be undocumented edge cases to solve</p> <p>The source and test code can be copied into a new project, as has been done with the practicalli/codewars-guides solutions</p> <pre><code>clojure -M:new lib practicalli/readability-is-king\n</code></pre> <p>Update the solution window with your solution and use the TEST button to run the sample unit tests.</p> <p>The ATTEMPT button will run all the unit tests for the challenge, which may be more than the sample tests.  If the attempt passes all the tests then the solution can be submitted an other solutions reviewed.</p> <p></p>"},{"location":"code-challenges/codewars/#tracking-progress","title":"Tracking progress","text":"<p>View your profile page to track your progress and revisit kata challenges already completed.</p> <p></p>"},{"location":"code-challenges/codewars/#references","title":"References","text":"<p>practicalli/codewars-guide - a repository of code solutions to CodeWars challenges, each challenge is its own Clojure CLI (deps.edn) project.</p> <p> YouTube: CodeWars video guides Unofficial Free Code Camp Clojure Challenges</p>"},{"location":"code-challenges/exercism/","title":"Exercism.io Challenges","text":"<p> Exercism Clojure Track</p> <p> Exercism.io is a learning platform for 12 programming languates which combines carefully crafted coding challenges and mentors who review and advise on solutions.</p> <p>Solve challenges via the built-in Exercism editor.</p> <p></p> <p>Or download each exercise locally using the  Exercism CLI, providing a  Clojure CLI configured project with a test runner.</p> <p>Use the  Exercism CLI to submit a solution for metor feedback.</p> Exercism embdedded Clojure editor <p>The Exercisim Clojure editor is powered by  babashka/sci</p>"},{"location":"code-challenges/exercism/#clojure-track","title":"Clojure Track","text":"<p>All the challenges are groups into specific  language tracks, including the  Clojure track</p> <p>Join the language track to be presented with available challenges and progress through that specific track.</p> <p></p>"},{"location":"code-challenges/exercism/#working-locally","title":"Working Locally","text":"<p> Exercism Guide to working locally</p> <p>Follow the  Practicalli Clojure CLI Install steps (Exercism includes a similar  Clojure CLI install guide)</p> <p>The  Exercism CLI can download a Clojure project containing the code for a specific challeng and submit the code back to exercism to confirm if the tests have passed and complete the challenge (or get feedback from a mentor).</p> Each challenge shows the download and submit commands <p>Each Exercise page shows the command to download the code for that specific exercise, which is of the form <pre><code>exercism download --exercise=exercise-name --track=clojure\n</code></pre></p> <p>Open the project in your  preferred Clojure editor and write a solution to solve the exercise.</p> <p><code>clojure -X:test</code> command in the root of the downloaded project will run the tests supplied by the exercise</p> Practicalli Test Runner aliases <p><code>clojure -X:test/run</code> runs the Kaocha test runner from the  Practicalli Clojure CLI Config</p> <p><code>clojure -X:test/watch</code> will automatically re-run tests when file changes are detected.</p> <p> Clojure test runner covers test runner options in more detail.</p> <p>Once the tests pass and you are happy with the solution, submit it to the Exercism website</p> <pre><code>exercism submit /path/to/src-file\n</code></pre>"},{"location":"code-challenges/exercism/#repl-workflow","title":"REPL Workflow","text":"<p>Use a REPL workflow to get instant feedback on code written to make the unit test assersions pass.</p> Terminal UIEditor connected REPL <p>Start a REPL via a Terminal UI in the root of the Exercism project</p> <pre><code>clojure -M:repl/rebel\n</code></pre> <p>Open the project in a  Clojure aware editor and connect to the REPL process.</p> <p>Open the project in a  Clojure aware editor and start a Clojure REPL, e.g. jack-in</p> <p>REPL experiments are typically written within a <code>comment</code> function, referred to a a Rich Comment.  This separates experimental code from finished designs.</p> <p>Disable Linter rules</p> <p>Disable Linter rules within the <code>comment</code> expression that are not useful for REPL experiments.</p> <p>It is common to have several implmentations of a function with the same name, so <code>:redefined-var</code> is disabled.</p> <p>Functions defined in the REPL experments are not ment to be used publicly (until they are copied/moved out of the comment form), so <code>:clojure-lsp/unused-public-var</code> lint rule is disabled <pre><code>#_{:clj-kondo/ignore [:redefined-var :clojure-lsp/unused-public-var]}\n(comment\n  ,,,\n)\n</code></pre></p>"},{"location":"code-challenges/exercism/#support","title":"Support","text":"<p>Mentors on the Exercism website will provide a review of your submissions and you can switch between mentor and practice modes as you prefer.</p> <p> practicalli/exercism-clojure-guides contains a design journal of solutions to several Clojure exercises.</p> <p>Ask for advice in the #exercism or #beginners channels of the Clojurians Slack community.</p>"},{"location":"code-challenges/exercism/hamming/","title":"Hamming","text":""},{"location":"code-challenges/exercism/hamming/#topics-covered","title":"Topics covered","text":"<p>Code for this solution on GitHub</p> <p>practicalli/exercism-clojure-guides contains the design journal and solution to this exercise and many others.</p>"},{"location":"code-challenges/exercism/hamming/#create-the-project","title":"Create the project","text":"<p>Download the RNA transcription exercise using the exercism CLI tool</p> <pre><code>exercism download --exercise=rna-transcription --track=clojure\n</code></pre> <p>Use the REPL workflow to explore solutions locally</p> <p>Open the project in a Clojure aware editor and start a REPL, using a rich comment form to experiment with code to solve the challenge.</p>"},{"location":"code-challenges/exercism/nucleotide-count/","title":"Nucleotide Count","text":"<p> Clojure Track: Nucleotide Count</p> <p>Given a string representing a DNA sequence, count how many of each nucleotide is present.</p> <p>If the string contains characters other than A, C, G, or T then an error should be throw.</p> <p>Represent a DNA sequence as an ordered collection of nucleotides, e.g. a string of characters such as \"ATTACG\".</p> <pre><code>\"GATTACA\" -&gt; 'A': 3, 'C': 1, 'G': 1, 'T': 2\n\"INVALID\" -&gt; error\n</code></pre> <p>DNA Nucleotide names</p> <p><code>A</code> is Adenine, <code>C</code> is Cytosine, <code>G</code> is Guanine and <code>T</code> is Thymine</p> <p>Code for this solution on GitHub</p> <p>practicalli/exercism-clojure-guides contains the design journal and solution to this exercise and many others.</p>"},{"location":"code-challenges/exercism/nucleotide-count/#create-the-project","title":"Create the project","text":"<p>Download the Nucleotide Count exercise using the exercism CLI tool</p> <pre><code>exercism download --exercise=nucleotide-count --track=clojure\n</code></pre> <p>Use the REPL workflow to explore solutions locally</p> <p>Open the project in a Clojure aware editor and start a REPL, using a rich comment form to experiment with code to solve the challenge.</p>"},{"location":"code-challenges/exercism/nucleotide-count/#starting-point","title":"Starting point","text":"<p>Unit test code calls functions from the <code>src</code> tree which must exist with the correct argument signature for the unit test code to compile successfully.</p> <p>Reviewing each assertion in the unit test code identifies the function definitions required.</p> Exercism Unit Tests <pre><code>(ns nucleotide-count-test\n  (:require [clojure.test :refer [deftest is]]\n            nucleotide-count))\n\n(deftest empty-dna-strand-has-no-adenosine\n  (is (= 0 (nucleotide-count/count-of-nucleotide-in-strand \\A, \"\"))))\n\n(deftest empty-dna-strand-has-no-nucleotides\n  (is (= {\\A 0, \\T 0, \\C 0, \\G 0}\n         (nucleotide-count/nucleotide-counts \"\"))))\n\n(deftest repetitive-cytidine-gets-counted\n  (is (= 5 (nucleotide-count/count-of-nucleotide-in-strand \\C \"CCCCC\"))))\n\n(deftest repetitive-sequence-has-only-guanosine\n  (is (= {\\A 0, \\T 0, \\C 0, \\G 8}\n         (nucleotide-count/nucleotide-counts \"GGGGGGGG\"))))\n\n(deftest counts-only-thymidine\n  (is (= 1 (nucleotide-count/count-of-nucleotide-in-strand \\T \"GGGGGTAACCCGG\"))))\n\n(deftest validates-nucleotides\n  (is (thrown? Throwable (nucleotide-count/count-of-nucleotide-in-strand \\X \"GACT\"))))\n\n(deftest counts-all-nucleotides\n  (let [s \"AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC\"]\n    (is (= {\\A 20, \\T 21, \\G 17, \\C 12}\n           (nucleotide-count/nucleotide-counts s)))))\n</code></pre> <p>Function definitions required to compile unit test code</p> src/nucleotide_count.clj<pre><code>(ns nucleotide-count)\n\n(defn count-of-nucleotide-in-strand\n  \"Count how many of a given nucleotide is in a strand\"\n  [nucleotide strand])\n\n(defn nucleotide-counts\n  \"Count all nucleotide in a strand\"\n  [strand])\n</code></pre>"},{"location":"code-challenges/exercism/nucleotide-count/#making-the-tests-pass","title":"Making the tests pass","text":"<p>Select one assertion from the unit tests and write code to make the test pass.</p> <p>Experiment with solutions in the <code>comment</code> form and add the chosen approach to the respective function definition.</p>"},{"location":"code-challenges/exercism/nucleotide-count/#counting-nucleotides","title":"Counting nucleotides","text":"<p>Use test data from the unit test code, e.g. <code>\"GGGGGTAACCCGG\"</code></p> <p>How often does a nucleotide appear</p> <p>Example</p> <pre><code>  (map\n    #(if (= % \\A) 1 0)\n    \"GGGGGTAACCCGG\")\n</code></pre> <p>Add the result to get the total count</p> <p>Example</p> <pre><code>  (count\n   (map\n     #(if (= % \\A) 1 0)\n     \"GGGGGTAACCCGG\"))\n</code></pre> <p>Is there a more elegant way?</p> <p>When only the matching nucleotide is in the strand, then all the elements of the strand can be counted.</p> <p><code>filter</code> the DNA strand with a predicate function (returns true/false) that returns only the matching nucleotide.</p> <p>Example</p> <pre><code>  (filter #(= % \\A) valid-nucleotides))\n</code></pre> <p>;; Count the elements in the returned sequence for the total</p> <p>Example</p> <pre><code>  (count\n   (filter #(= % \\A) valid-nucleotides))\n</code></pre> <p>Add this code into the starting function</p>"},{"location":"code-challenges/exercism/nucleotide-count/#run-unit-tests","title":"Run unit tests","text":"<p>Run the unit tests to see if they pass.  x should pass, x should fail.</p>"},{"location":"code-challenges/exercism/nucleotide-count/#nucleotide-occurances","title":"Nucleotide occurances","text":"<p>Count the occurances</p> <p>\"GGGGGTAACCCGG\"</p> <pre><code>   (count\n     (filter (fn [nucleotide] (= nucleotide \\A))\n             \"GGGGGTAACCCGG\"))\n</code></pre> <p>Define the data</p> <pre><code>  (def valid-nucleotides\n    \"Characters representing valid nucleotides\"\n    [\\A \\C \\G \\T])\n</code></pre> <p>Exception handling required</p> <pre><code>(throw (Throwable.)) if nucleotide is \\X\n</code></pre> <p>Or use a predicate with some (some element? in the sequence)</p> <pre><code>  (some #(= \\G %) valid-nucleotides)\n\n  (some #{\\G} valid-nucleotides)\n</code></pre> <pre><code>  (defn count-of-nucleotide-in-strand\n    [nucleotide strand]\n    (if (some #(= nucleotide %) valid-nucleotides)\n      (count\n       (filter #(= nucleotide %)\n               strand))\n      (throw (Throwable.))))\n\n  (count-of-nucleotide-in-strand \\T \"GGGGGTAACCCGG\")\n</code></pre> <p>Design the second function</p> <p>How often does a nucleotide appear</p> <pre><code>  (map\n    #(if (= % \\A) 1 0)\n    valid-nucleotides)\n</code></pre> <p>Add the result to get the total count</p> <p>Is there a more elegant way?</p> <pre><code>  (filter #(= % \\A) valid-nucleotides)\n</code></pre> <p>Count the elements in the returned sequence for the total</p> <p>Design the second function</p> <p>How often does a nucleotide appear</p> <p>NOTE: zero must be returned when there are no appearences</p> <p>Return value always in the form</p> <pre><code>  {\\A 20, \\T 21, \\G 17, \\C 12}\n</code></pre>"},{"location":"code-challenges/exercism/nucleotide-count/#hammock-time","title":"Hammock time...","text":"<ul> <li>How often does something appear,</li> <li>how frequenct is it?</li> <li>Is there a clojure standard library for that (approx 700 functions), review https://clojure-docs.org/</li> </ul> <pre><code>  (frequencies \"GGGGGAACCCGG\")\n</code></pre> <p>If there are missing nucleotides then there is no answer</p> <p>What if there is a starting point</p> <pre><code>  {\\A 0 \\C 0 \\G 0 \\T 0}\n</code></pre> <p>;; Then merge the result of frequencies</p> <pre><code>  (merge {\\A 0 \\C 0 \\G 0 \\T 0}\n         (frequencies \"GGGGGAACCCGG\"))\n</code></pre> <p>Update the function definition and run tests</p>"},{"location":"code-challenges/exercism/nucleotide-count/#solutions","title":"Solutions","text":"<p>There are many ways to solve a challenge and there is value trying different approaches to help learn more about the Clojure language.</p> <p>The following solution includes <code>filter</code> and <code>frequencies</code> functions which are commonly used functions from the Clojure standard library.</p> <p>Example Solution</p> src/nucleotide_count.clj<pre><code>(ns nucleotide-count)\n\n(def valid-nucleotides\n    \"Characters representing valid nucleotides\"\n    [\\A \\C \\G \\T])\n\n(defn count-of-nucleotide-in-strand\n  [nucleotide strand]\n  (if (some #(= nucleotide %) valid-nucleotides)\n    (count\n     (filter #(= nucleotide %)\n             strand))\n    (throw (Throwable.))))\n\n(defn nucleotide-counts\n  \"Count all nucleotide in a strand\"\n  [strand]\n  (merge {\\A 0 \\C 0 \\G 0 \\T 0}\n         (frequencies \"GGGGGAACCCGG\")))\n</code></pre>"},{"location":"code-challenges/exercism/rna-transcription/","title":"Exercise: RNA Transcription","text":"<p> Clojure Track: Nucleotide Count</p> <p>Given a DNA strand, return its RNA complement (per RNA transcription).</p> <p>Both DNA and RNA strands are a sequence of nucleotides.</p> <p>The four nucleotides found in DNA are adenine (A), cytosine (C), guanine (G) and thymine (T).</p> <p>The four nucleotides found in RNA are adenine (A), cytosine (C), guanine (G) and uracil (U).</p> <p>Given a DNA strand, its transcribed RNA strand is formed by replacing each nucleotide with its complement:</p> <ul> <li>G -&gt; C</li> <li>C -&gt; G</li> <li>T -&gt; A</li> <li>A -&gt; U</li> </ul> <p>Code for this solution on GitHub</p> <p>practicalli/exercism-clojure-guides contains the design journal and solution to this exercise and many others.</p>"},{"location":"code-challenges/exercism/rna-transcription/#create-the-project","title":"Create the project","text":"<p>Download the RNA transcription exercise using the exercism CLI tool</p> <pre><code>exercism download --exercise=rna-transcription --track=clojure\n</code></pre> <p>Use the REPL workflow to explore solutions locally</p> <p>Open the project in a Clojure aware editor and start a REPL, using a rich comment form to experiment with code to solve the challenge.</p>"},{"location":"code-challenges/exercism/rna-transcription/#designing-the-solution","title":"Designing the solution","text":"<p>To convert a collection of values, define a hash-map where the keys are the initial DNA values and the hash-map values are the transformed RNA values.  Using a hash-map in this way is often termed as a dictionary.</p> <p>A string is used as a collection of character values by many of the functions in <code>clojure.core</code>.  The dictionary uses characters for its keys and values.</p> <pre><code>{\\G \\C \\C \\G \\T \\A \\A \\U}\n</code></pre> <p>Use the <code>map</code> function to pass the dictionary over the dna string (collection of characters) to create the RNA transcription.</p> <p>Use an anonymous function to wrap the dictionary and pass each a character (nucleotide) from the DNA string in turn.</p> <pre><code>(defn to-rna\n  [dna]\n  (map (fn [nucleotide] (get {\\G \\C \\C \\G \\T \\A \\A \\U} nucleotide))\n       dna))\n</code></pre> <pre><code>(to-rna \"GCTA\")\n</code></pre> <p>The result is returned as a sequence of characters.</p> <p>Refactor the <code>to-rna</code> function and add <code>clojure.string/join</code> to return the RNA value as a string</p> <pre><code>(defn to-rna\n  [dna]\n  (clojure.string/join\n    (map (fn [nucleotide] (get {\\G \\C \\C \\G \\T \\A \\A \\U} nucleotide))\n         dna)))\n</code></pre> <p>Now the function returns a string rather than a collection of characters.</p> <pre><code>(to-rna \"GCTA\")\n</code></pre>"},{"location":"code-challenges/exercism/rna-transcription/#throwing-an-assertion-error-for-incorrect-nucleotide","title":"Throwing an assertion error for incorrect nucleotide","text":"<p>In the Exercism test suite, one test checks for an AssertionError when an incorrect nucleotide is passed as part of the DNA string.</p> <pre><code>(deftest it-validates-dna-strands\n  (is (thrown? AssertionError (rna-transcription/to-rna \"XCGFGGTDTTAA\"))))\n</code></pre> <p>The <code>throw</code> function can be use to return any of the Java errors. An assertion error would be thrown using the following code</p> <pre><code>(throw (AssertionError. \"Unknown nucleotide\"))\n</code></pre> <p>Refactor the <code>to-rna</code> function to throw an assertion error if a nucleotide if found that is not part of the dictionary.</p> <p>An <code>if</code> function could be used with a conditional to check if each nucleotide is one of the keys in the dictionary and throw an AssertionError if not found.  This would mean consulting the dictionary twice, once for the conditional check and once for the conversion.</p> <p>Is there a way to consult the dictionary once for each nucleotide?</p> <p>The <code>get</code> function can return a specific not-found value when a key is not found in a map.</p> <p>What if the <code>throw</code> function is used as the not-found value in the <code>get</code> function?</p> <pre><code>(defn to-rna\n  [dna]\n  (clojure.string/join\n    (map (fn [nucleotide ](get {\\G \\C \\C \\G \\T \\A \\A \\U} nucleotide\n                               (throw (AssertionError. \"Unknown nucleotide\")) ))\n         dna)))\n</code></pre> <p>Unfortunately this approach will evaluate the throw expression regardless of if the nucleotide is found in the dictionary, so calling this version of the function always fails.</p> <p>The <code>or</code> function evaluate the first expression and if a true value is returned then any additional expressions are skipped over.</p> <p>If the first expression returns false or a falsey value, i.e. <code>nil</code>, then the next expression is evaluated.</p> <p>Proposed Solution</p> <pre><code>(defn to-rna\n  [dna]\n  (clojure.string/join\n    (map (fn [nucleotide](or (get {\\G \\C \\C \\G \\T \\A \\A \\U} nucleotide)\n                             (throw (AssertionError. \"Unknown nucleotide\"))))\n         dna)))\n</code></pre> <p>Call the <code>to-rna</code> function with a DNA string from the unit test code</p> <pre><code>(to-rna \"GCTA\")\n</code></pre> <p>The function should return <code>\"CGAU\"</code></p> <p>Call the <code>to-rna</code> function with a DNA string that contains an invalid nucleotide.</p> <pre><code>(to-rna \"GCXA\")\n</code></pre> <p>An <code>AssertionError</code> is thrown as the <code>X</code> character does not exist in the dictionary hash-map, so the <code>get</code> expression returns <code>nil</code>.</p>"},{"location":"code-challenges/exercism/rna-transcription/#refactor","title":"Refactor","text":"<p>Now the function is solving unit tests, minor adjustments can be made to streamline the code.</p>"},{"location":"code-challenges/exercism/rna-transcription/#hash-map-as-function","title":"Hash map as function","text":"<p>A hash-map can be called as a function and takes a key as an argument.  This acts the same as the <code>get</code> function, returning the value  associated to a matching key, otherwise returning <code>nil</code> or the not-found value if specified.</p> <pre><code>(defn to-rna\n  [dna]\n  (clojure.string/join\n    (map (fn [nucleotide] (or ({\\G \\C \\C \\G \\T \\A \\A \\U} nucleotide)\n                              (throw (AssertionError. \"Unknown nucleotide\"))))\n         dna)))\n</code></pre>"},{"location":"code-challenges/exercism/rna-transcription/#anonymous-function","title":"Anonymous function","text":"<p>The anonymous function, <code>fn</code>, has a terse form.</p> <p><code>#(* %1 %2)</code> is the same as <code>(fn [value1 value2] (+ value1 value2))</code></p> <p>This syntax sugar is often use with <code>map</code>, <code>reduce</code>, <code>apply</code> functions as the behaviour tends to be compact and of single use.</p> <p>If the function definition is more complex or used elsewhere in the namespace, then the <code>defn</code> function should be used to define shared behavior.</p> <p>Solution with anonymous function</p> <pre><code>(defn to-rna\n  [dna]\n  (clojure.string/join\n    (map #(or ({\\G \\C \\C \\G \\T \\A \\A \\U} %)\n              (throw (AssertionError. \"Unknown nucleotide\")))\n         dna )))\n</code></pre>"},{"location":"code-challenges/exercism/rna-transcription/#named-dictionary-data","title":"Named dictionary data","text":"<p>Replace the hard-coded hash-map by defining a name for the dictionary.</p> <p>Define a name to represent the dictionary data</p> <pre><code>(def dictionary-dna-rna {\\G \\C \\C \\G \\T \\A \\A \\U})\n</code></pre> <p>Refactor the <code>to-rna</code> function to use the dictionary by name.</p> <p>Solution using named dictionary data</p> <pre><code>(defn to-rna\n  [dna]\n  (clojure.string/join\n    (map #(or (dictionary-dna-rna %)\n              (throw (AssertionError. \"Unknown nucleotide\")))\n         dna)))\n</code></pre>"},{"location":"code-challenges/exercism/rna-transcription/#making-the-function-pure","title":"Making the function pure","text":"<p>Its beyond the scope of the Exercism challenge, however, its recommended to use pure functions where possible.</p> <p>A pure function only uses data from its arguments.</p> <p>Adding a dictionary as an argument to the <code>to-rna</code> function would be simple.</p> <p>Pure function approach</p> <pre><code>(defn to-rna\n  [dictionary dna]\n  (clojure.string/join\n    (map #(or (dictionary %)\n              (throw (AssertionError. \"Unknown nucleotide\")))\n         dna )))\n</code></pre> <p>With a dictionary as an argument the function is also more usable, as other dictionaries could be used with the function.</p> <p>The function would now be called as follows</p> <pre><code>(to-rna dictionary-dna-rna \"GTGAC\")\n</code></pre>"},{"location":"code-challenges/exercism/space-age/","title":"Space Age","text":""},{"location":"code-challenges/exercism/space-age/#topics-covered","title":"Topics covered","text":"<p>Code for this solution on GitHub</p> <p>practicalli/exercism-clojure-guides contains the design journal and solution to this exercise and many others.</p>"},{"location":"code-challenges/exercism/space-age/#create-the-project","title":"Create the project","text":"<p>Download the RNA transcription exercise using the exercism CLI tool</p> <pre><code>exercism download --exercise=rna-transcription --track=clojure\n</code></pre> <p>Use the REPL workflow to explore solutions locally</p> <p>Open the project in a Clojure aware editor and start a REPL, using a rich comment form to experiment with code to solve the challenge.</p>"},{"location":"code-challenges/exercism/space-age/#challenge-introduction","title":"Challenge introduction","text":"<p>Given an age in seconds, calculate how old someone would be on:</p> <ul> <li>Earth: orbital period 365.25 Earth days, or 31557600 seconds</li> <li>Mercury: orbital period 0.2408467 Earth years</li> <li>Venus: orbital period 0.61519726 Earth years</li> <li>Mars: orbital period 1.8808158 Earth years</li> <li>Jupiter: orbital period 11.862615 Earth years</li> <li>Saturn: orbital period 29.447498 Earth years</li> <li>Uranus: orbital period 84.016846 Earth years</li> <li>Neptune: orbital period 164.79132 Earth years</li> </ul> <p>So if you were told someone were 1,000,000,000 seconds old, you should be able to say that they're 31.69 Earth-years old.</p>"},{"location":"code-challenges/exercism/bob/","title":"Index","text":""},{"location":"code-challenges/exercism/bob/#bob","title":"Bob","text":"<p>The Bob challenge involves writing a very basics example of a text parser, something that would be used for a text based adventure game.</p> <p>Bob is described as a lackadaisical teenager, so responses are very limited.  To create the Bob text parser we need to identify the rules that determine Bob's response.</p> <p>The instructions provide some basic rules:</p> <ul> <li>Bob answers 'Sure.' if you ask him a question.</li> <li>He answers 'Whoa, chill out!' if you yell at him.</li> <li>He answers 'Calm down, I know what I'm doing!' if you yell a question at him.</li> <li>He says 'Fine. Be that way!' if you address him without actually saying anything.</li> <li>He answers 'Whatever.' to anything else.</li> </ul> <p>It is important to also read through the supplied unit tests to elaborate on these rules.</p>"},{"location":"code-challenges/exercism/bob/#create-the-project","title":"Create the project","text":"<p>Download the Bob transcription exercise using the exercism CLI tool</p> <pre><code>exercism download --exercise=bob --track=clojure\n</code></pre> <p>To use the Clojure CLI tool instead of Leiningen, create a <code>deps.edn</code> file containing an empty hash-map, <code>{}</code> and clone  Practicalli Clojure CLI Config to <code>~/.clojure/</code>.</p>"},{"location":"code-challenges/exercism/bob/#rules-derived-from-the-unit-tests","title":"Rules derived from the Unit tests","text":"<p>Reviewing all the examples from the unit tests, there are 5 rules for the Bob parser</p> <p>These rules were discovered by searching through the unit test code for each reply that Bob should return, showing the tests for each reply.</p> <p>Each rule also had to ensure it did not create any false positives by being true for any other reply that Bob could make, especially the whatever reply.</p> Name Rule description question The phrase has a ? as the last alphanumeric character, not including whitespace shouting The phrase has uppercase alphabetic characters, but no lower case alphabetic characters shouting question A combination of question and shouting silence The phrase is empty or contains characters that are not alphanumeric whatever Any phrase that does not match any of the other rules"},{"location":"code-challenges/exercism/bob/#design-approach","title":"Design approach","text":"<p>There are two main approaches to solving this challenge.  The first is to use the <code>clojure.string</code> functions to check or transform the phrase given to Bob.  The second approach is to use regular expressions with functions such as <code>re-seq</code>, <code>re-find</code> and <code>re-matches</code>.</p> <p>Start by defining the rules as an expression that returns either true or false, using some of the example strings from the unit tests.</p> <p>Use a <code>let</code> expression to bind a name to each rule, e.g. <code>shouting?</code>, <code>question?</code>, <code>silence?</code>.  Then these names can be used in a simple <code>cond</code> expression to return the appropriate phrase.  Regardless of if using <code>clojure.string</code> or regular expressions, the <code>cond</code> code should be similar</p> <p>Once you have tried this challenge for yourself, take a look at the design journal for the clojure.string approach and the regular expression approach.</p> <p>Bob - clojure.string approach Bob - regular expression approach</p>"},{"location":"code-challenges/exercism/bob/bob-regular-expression-approach/","title":"Bob solution - regex","text":"<p>Solution to Bob challenge using regular expressions and the <code>re-matches</code> function.</p> <p>Using <code>re-matchers</code>, if the string matches the pattern, then the string is returned. Otherwise <code>nil</code> is returned</p> <p>The regular expressions cheatsheet from Mozilla Developer Network was very helpful in understanding regular expressions</p>"},{"location":"code-challenges/exercism/bob/bob-regular-expression-approach/#asking-bob-a-question","title":"Asking Bob a question?","text":"<p>The phrase passed to Bob is a question if the last alphanumeric character is a question mark. Using a simple regular expression we can check if the last character in the string a <code>?</code></p> <p><code>#\"\\?\"</code> is a literal regular expression pattern that will match a single <code>?</code> character</p> <p>So the regular expression pattern will match a single ? character</p> <pre><code>  (re-matches #\"\\?\" \"?\")\n</code></pre> <p>With other characters present though the pattern doesn't match.</p> <pre><code>  (re-matches #\"\\?\" \"Ready?\")\n</code></pre> <p>To match <code>?</code> with other characters,</p> <p><code>.</code> matches any single character except line terminators (new line, carriage return)</p> <pre><code>(re-matches #\".\\?\" \"R?\")\n</code></pre> <p><code>.*</code> matches any number of single characters one or more times,</p> <pre><code>(re-matches #\".*\\?\" \"?Ready\")\n</code></pre> <p><code>\\s</code> matches a single whitespace character and <code>\\s*</code> matches multiple whitespace characters</p> <pre><code>  (re-matches #\".*\\?$\" \"Okay if like my  spacebar  quite a bit?\")\n  ;; =&gt; \"Okay if like my  spacebar  quite a bit?\"\n</code></pre> <p><code>$</code> is a boundary assertion so the pattern only matches the ? at the end of a string and not in the middle.  However, this is not required as the <code>re-matches</code> uses groups and that manages the boundary assertion.</p> <p><code>re-matches</code> does not require the <code>$</code> as there is an implicit boundary</p> <pre><code>  (re-matches #\".*\\?\" \"Okay if like my ? spacebar  quite a bit\")\n</code></pre> <p>Match if there is a single space or space type character after the ?</p> <pre><code>  (re-matches #\".*\\?\\s\" \"Okay if like my  spacebar  quite a bit? \")\n  ;; =&gt; \"Okay if like my  spacebar  quite a bit? \"\n</code></pre> <p>Match if there are multiple space type characters after the ?</p> <pre><code>  (re-matches #\".*\\?\\s*\" \"Okay if like my  spacebar  quite a bit?   \")\n  ;; =&gt; \"Okay if like my  spacebar  quite a bit?   \"\n</code></pre> <p>Don't match if a question mark character is not at the end of the string</p> <pre><code>  (re-matches #\".*\\?\" \"Okay if like my ? spacebar  quite a bit\")\n</code></pre>"},{"location":"code-challenges/exercism/bob/bob-regular-expression-approach/#shouting-a-question-at-bob","title":"Shouting a question at Bob","text":"<p><code>[^a-z]</code> matches if there are no lower case alphabetic characters.  The <code>^</code> at the start of the pattern negated the pattern.</p> <p><code>*</code> any number of the proceeding pattern</p> <p><code>[A-Z]+</code> any number of upper case alphabetic characters</p> <p>When a phrase has all uppercase characters then we have a match</p> <pre><code>  (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" \"HELLO\")\n</code></pre> <p>If there are lower case characters, even if there are uppercase characters, the pattern does not match.</p> <pre><code>  (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" \"Hello\")\n</code></pre> <p>If the characters are all uppercase then the pattern matches, even if there are other non-alphabetic characters</p> <pre><code>  (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" \"ABC 1 2 3\")\n</code></pre>"},{"location":"code-challenges/exercism/bob/bob-regular-expression-approach/#silence-of-the-bob","title":"Silence of the Bob","text":"<p><code>\\s</code> matches any single whitespace character, including space, tab, form feed, line feed, and other Unicode spaces.</p> <pre><code>(re-matches #\"\\s*\" \"  \\t\\t\\t\")\n</code></pre>"},{"location":"code-challenges/exercism/bob/bob-regular-expression-approach/#solution-using-regular-expressions","title":"Solution using regular expressions","text":"<p>The <code>re-matches</code> expressions with regular expressions patterns can be put into a let expression.  The names are bound to the re-matches expressions which evaluated to either <code>true</code> or <code>false</code></p> <p>The names from the let are used with a <code>cond</code> function as conditions, returning the relevant reply from Bob.</p> <p>For the shouting question, the <code>and</code> is used to check if two names are both true.</p> <pre><code>(defn response-for\n  [phrase]\n  (let [;; A ? at the end of the phrase, not counting whitespace\n        question (re-matches #\".*\\?\\s*\" phrase)\n\n        ;; No lower case characters, at least one upper case character\n        yelling (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" phrase)\n\n        ;; The entire string is whitespace\n        silence (re-matches #\"\\s*\" phrase)]\n\n    (cond\n      silence                \"Fine. Be that way!\"\n      (and question yelling) \"Calm down, I know what I'm doing!\"\n      question               \"Sure.\"\n      yelling                \"Whoa, chill out!\"\n      :whatever              \"Whatever.\")))\n</code></pre>"},{"location":"code-challenges/exercism/bob/bob-string-approach/","title":"Bob string approach","text":"<p>Solution to Bob challenge using <code>clojure.string</code> functions and Character class from Java.</p>"},{"location":"code-challenges/exercism/bob/bob-string-approach/#asking-bob-a-question","title":"Asking Bob a question?","text":"<p>The phrase passed to Bob is a question if the last alphanumeric character is a question mark.</p> <p>Using a simple comparison we can check if the last character in the string a <code>?</code></p> <pre><code>(= \\? (last \"this is a question?\"))\n</code></pre> <p>However if there is whitespace after the question mark then the <code>last</code> character is a whitespace and so the expression returns false</p> <pre><code>  (= \\? (last \"this is still a question? \"))\n</code></pre> <p><code>clojure.string/trimr</code> will remove all the trailing whitespace from the right side of a string.  Once trimmed, then our initial comparison code will work again.</p> <pre><code>  (= \\? (last (clojure.string/trimr \"this is still a question? \")))\n</code></pre>"},{"location":"code-challenges/exercism/bob/bob-string-approach/#shouting-at-bob","title":"Shouting at Bob","text":"<p>Unfortunately the  clojure.string API does not have a function to check if a string is in capital letters.  There is an <code>upper-case</code> function, so a comparison can be made  with the original string and the string returned from <code>clojure.string/upper-case</code>.</p> <p>Convert the string to uppercase</p> <pre><code>(clojure.string/upper-case \"watch out!\")\n</code></pre> <p>compare the uppercase version of the string with the original, if they are equal, then the original string must have been in upper case</p> <pre><code>  (= \"WATCH OUT!\"\n     (clojure.string/upper-case \"WATCH OUT!\"))\n</code></pre> <pre><code>  (= \"watch out!\"\n     (clojure.string/upper-case \"watch out!\"))\n</code></pre> <p>There is a flaw in this approach thought, as it will give false positives for strings that should return the 'Whatever' response</p> <pre><code>  (= \"1, 2, 3\"\n     (clojure.string/upper-case \"1, 2, 3\"))\n</code></pre> <p>Refined rule to check that the phrase contains alphabetic characters, otherwise it is not shouting.</p> <p>The java.lang.Character class has a method called isLetter that determines if a character is a letter.</p> <p>The Classes and methods in <code>java.lang</code> are always available within a Clojure project, without the need for specifically importing the library.</p> <p><code>Character/isLetter</code> can be called as a function in Clojure, passing in a character type.</p> <pre><code>(Character/isLetter \\a)\n</code></pre> <p>To support all Unicode characters there is an isLetter method that takes an integer type.  As there could be any kind of characters in the phrase, we will use the int version.  This required conversing the character to an int first before calling <code>Character/isLetter</code></p> <pre><code>(Character/isLetter (int \\a))\n</code></pre> <p>the <code>some</code> function is used to iterate over all the characters in the phrase. As soon as a letter is found it returns true, so does not need to process the whole phrase unless no letter is found.</p> <pre><code>(some #(Character/isLetter (int %)) phrase)\n</code></pre>"},{"location":"code-challenges/exercism/bob/bob-string-approach/#silence-of-the-bob","title":"Silence of the Bob","text":"<p><code>clojure.string/blank?</code> is a predicate function that returns true if a string is empty or contains only whitespace.  It also returns true for a <code>nil</code> value.</p>"},{"location":"code-challenges/exercism/bob/bob-string-approach/#final-solution","title":"Final solution","text":"<p>Each of the rules is bound to a name that represents either a true or false value returned from each expression.</p> <p>The <code>cond</code> expression then evaluates the local names to see if they are true or false.  The first true value found returns the string associated with the name.</p> <p>For the shouting question, the <code>and</code> is used to check if two names are both true.</p> <pre><code>(defn response-for [phrase]\n  (let [phrase    (string/trimr phrase)\n        silence?  (string/blank? phrase)\n        question? (= \\? (last phrase))\n        letters?  (some #(Character/isLetter (int %)) phrase)\n        shouting? (and (= phrase (string/upper-case phrase))\n                       letters?)]\n    (cond\n      (and shouting? question?) \"Calm down, I know what I'm doing!\"\n      silence?                  \"Fine. Be that way!\"\n      shouting?                 \"Whoa, chill out!\"\n      question?                 \"Sure.\"\n      :else                     \"Whatever.\")))\n</code></pre> <p>The first let binding, <code>phrase</code> over-rides the name of the argument to the function.  This is not that common an approach as over-riding can lead to confusion.  However, in this relatively simple example it feels okay to do.  The over-ride is the first let binding and it is preparing the string for all the other let bindings to use.</p> <p>Over-riding names of functions from the Clojure standard library is not recommended as this does lead to much confusion.</p>"},{"location":"code-kata/","title":"Kata challenges","text":"<p>A kata is a small challenge that you attempt to solve in different ways, so experiment with your solutions to these challenges.</p> <p>Kata are often coupled with Test Driven Development approach.</p> Project Topics Overview Recent song-list TDD Keep a list of recent songs played, without duplicates Salary Slip Generator TDD Generate play slips for an employee <p>Code Kata Website</p> <p></p>"},{"location":"code-kata/#suggested-kata-exercises","title":"Suggested kata exercises","text":"<ul> <li>String Calculator</li> <li>Bowling Game</li> <li>FizzBuzz</li> <li>Odd Even</li> <li>The Calc Stat</li> <li>The Leap Year</li> <li>The Prime Factor</li> <li>The Recently Used List  (recent song list)</li> <li>The Word Wrap</li> <li>The Natural String Sorting</li> </ul>"},{"location":"code-kata/recent-song-list/","title":"TDD Kata Recent Song-list","text":"<p>Create a recent song list to hold a unique set of songs that have been played.</p> <p>The most recently played song is at the start of the list, the least recently played song is the last in the list.</p> <ul> <li>A recently-used-list is initially empty.</li> <li>Songs in the list are unique, so repeatedly played songs should only appear once in the list</li> <li>Songs can be looked up by index, which counts from zero.</li> <li>The song list can be transitory (starting from empty each time) or persistent within a REPL session (examples use a transitory approach)</li> </ul> <p>Optional extras:</p> <ul> <li>Empty song names are not allowed.</li> <li>Add a limit to the number of songs the list contains, with the least recently added items dropped when that limit is reached.</li> </ul>"},{"location":"code-kata/recent-song-list/#create-project","title":"Create Project","text":"<p>Create a new project using clj-new</p> <pre><code>clojure -T:project/create practicalli/song-list\n</code></pre>"},{"location":"code-kata/recent-song-list/#run-repl","title":"Run REPL","text":"<p>Start a Clojure REPL via a Clojure editor or via the command line from the root of the project directory</p> <p>Start rich terminal UI Clojure REPL</p> <pre><code>clojure -M:repl/rebel\n</code></pre>"},{"location":"code-kata/recent-song-list/#unit-tests","title":"Unit Tests","text":"<p><code>clojure.test</code> library is part of Clojure standard library and is the most common way to write unit tests in Clojure</p> <p>Open <code>test/playground/song_list_test.clj</code> file in your editor and update the namespace definition to include <code>clojure.test</code></p> <p>Require clojure.test namespace</p> test/playground/song_list_test.clj<pre><code>(ns practicalli.song-list-test\n  (:require [clojure.test :refer [deftest is testing]]\n            [playground.song-list :as song-list]))\n</code></pre>"},{"location":"code-kata/recent-song-list/#run-tests","title":"Run Tests","text":"<p>Evaluate the <code>practicalli.song-list</code> and <code>practicalli.song-list-test</code> namespaces to load their code into the REPL</p> <p>Call the <code>run-tests</code> function in the REPL to get a report back on all of the tests in our current namespace (<code>song-list</code>)</p> Kaocha test runnerclojure.test runner <p> Practicall Clojure CLI Config provides the <code>:test/run</code> alias to run the Kaocha test runner.</p> <p>Kaocha test runner</p> <p>Open a command line in the root directory of the project and run the following command. <pre><code>clojure -X:test/run\n</code></pre></p> <p>Kaocha runs all the tests, stopping should a test fail.</p> <p>Kaocha test runner with file watch</p> <p>Use the <code>:test/watch</code> alias to automatically run tests when ever a file is saved <pre><code>clojure -X:test/run\n</code></pre></p> <p>Evaluate the project code and evaluate the <code>run-tests</code> function from <code>clojure.test</code> from within the REPL</p> <p>clojure.test runner</p> <pre><code>(run-tests)\n</code></pre>"},{"location":"code-kata/recent-song-list/#test-song-list-exists","title":"Test song-list exists","text":"<p>Write a test to see if a recent song list exists.</p> <p>This is an opportunity to think about what kind of data structure you want to use to hold your recent song list.</p> <p>Try write the code first and then check that code with the examples provided (click to expand each code example box)</p> Test song-list exists <p>A simple test that checks for a <code>recent-songs</code> list src/playground/song_list.clj<pre><code>(deftest song-list-exists-test\n  (testing \"Does a recent song list exist\"\n    (is (vector? song-list/recent-songs))))\n</code></pre> <code>recent-songs</code> should be defined in <code>src/playground/recent-song-list.clj</code> before running the test, otherwise a compilation error will be returned.</p>"},{"location":"code-kata/recent-song-list/#define-a-recent-song-list","title":"Define a recent song list","text":"<p>Edit <code>src/playground/song_list.clj</code> and define a name for the collection of recent songs</p> <p>Use an empty collection to start with.  Which collection type will you use though (hash-map <code>{}</code>, list <code>()</code>, set <code>#{}</code>, vector <code>[]</code>)?</p> recent-songs collection <p>Define a recent-song name for an empty vector src/playground/song_list.clj<pre><code>(def recent-songs [])\n</code></pre></p> Test First Approach <p>For a strict test first approach, a <code>recent-songs</code> name (symbol) would be defined that returns <code>false</code> or a falsy value, e.g. <code>nil</code></p> <p>A name (symbol) must be defined for use in the test so that the Clojure code can compile</p>"},{"location":"code-kata/recent-song-list/#test-song-list-is-empty","title":"Test song-list is empty","text":"<p>The recent song list should be empty to start with.</p> Check song list is empty <p>A simple test that compares an empty vector with the value of <code>recent-songs</code> src/playground/song_list.clj<pre><code>(deftest song-list-empty-test\n  (testing \"Is song list empty if we haven't added any songs\"\n    (is\n     (= [] song-list/recent-songs))))\n</code></pre></p> <p>Here is the same test using the <code>empty?</code> function instead of the <code>=</code> function.</p> <p>src/playground/song_list.clj<pre><code>(deftest song-list-empty-test\n  (testing \"Is song list empty if we haven't added any songs\"\n    (is\n     (empty? song-list/recent-songs))))\n</code></pre> Either of these tests could replace the test that the song list exists, as these tests would fail if the song list did not exist.</p>"},{"location":"code-kata/recent-song-list/#test-adding-a-song-to-the-list","title":"Test adding a song to the list","text":"<p>Add a song to the collection, for example <code>Tubular Bells - Mike Oldfield</code></p> Test adding a song to the list test/playground/song_list_test.clj<pre><code>(deftest add-songs-test\n\n  (testing \"add song returns a song list with entries\"\n    (is\n     (not (empty?\n           (add-song \"Barry Manilow - Love on the rocks\" song-list/recent-songs)))))\n\n  (testing \"add multiple song returns a song list with entries\"\n    (is\n     (not (empty?\n           (-&gt;&gt; song-list/recent-songs\n             (add-song \"Mike Oldfield - Tubular Bells Part 1\")\n             (add-song \"Barry Manilow - Love on the rocks\")\n             (add-song \"Phil Colins - Sususudio\" )))))))\n</code></pre> <p>Other songs are avialbe and Practicalli makes no recommendation as to what songs should be used or listened too.</p>"},{"location":"code-kata/recent-song-list/#function-to-add-song","title":"Function to add song","text":"<p>Create a function to add a song to the start of the song list.</p> Function to add song to list <p>The <code>add-song</code> function takes the name of a song and the song list to which it will be added.</p> <p>A Thread-last macro <code>-&gt;&gt;</code> is used to pass the song list over two functions.</p> <p>The <code>song-list</code> is first passed to the <code>remove</code> expression as its last argument.  This expression will remove any occurrence of the new song we want to add from the <code>song-list</code>.</p> <p>The results of the <code>remove</code> expression are then passed to the <code>cons</code> expression as its last argument.  The <code>cons</code> expression simply adds the new song to the start of the list, making it the most recent song.</p> src/playground/song_list.clj<pre><code>(def recent-songs [])\n\n(defn add-song [song song-list]\n  (cons song song-list))\n</code></pre> <p><code>recent-songs</code> is passed into the <code>add-song</code> function as an argument, <code>song-list</code> to keep the design of <code>add-song</code> function pure (no side-effects).  This design also provides greater scope to using the <code>add-song</code> function, as any song list can be added to, rather than hard-coding <code>recent-songs</code> list.</p>"},{"location":"code-kata/recent-song-list/#test-song-added-to-top-of-list","title":"Test song added to top of list","text":"<p>As the song list shows recently played songs, new songs added should be at the top of the list.</p> <p>The list should not contain duplicate entries for a song.</p> Test songs added to top of list test/playground/song_list_test.clj<pre><code>(deftest recently-added-song-first-test\n\n  (testing \"most recent song should be first in the list when empty list\"\n    (is (=\n         (first (add-song \"Daft Punk - Get Lucky\" recent-songs))\n         \"Daft Punk - Get Lucky\")))\n\n  (testing \"most recent song should be first in list when adding multiple songs\"\n    (is (=\n         (first\n          (-&gt;&gt; recent-songs\n               (add-song \"Daft Punk - Get Lucky\")\n               (add-song \"Pharrell Williams - Happy\")))\n         \"Pharrell Williams - Happy\")))\n\n  (testing \"most recent song should be first in list when adding a repeated song\"\n    (is (=\n         (first\n          (-&gt;&gt; recent-songs\n               (add-song \"Pharrell Williams - Happy\")\n               (add-song \"Daft Punk - Get Lucky\")\n               (add-song \"Pharrell Williams - Happy\")))\n         \"Pharrell Williams - Happy\")))\n\n  (testing \"most recent song should be first in list when adding a repeated song\"\n    (is (not=\n         (last\n          (-&gt;&gt; recent-songs\n               (add-song \"Pharrell Williams - Happy\")\n               (add-song \"Daft Punk - Get Lucky\")\n               (add-song \"Pharrell Williams - Happy\")))\n         \"Pharrell Williams - Happy\"))))\n</code></pre>"},{"location":"code-kata/recent-song-list/#add-song-to-start-of-list","title":"Add song to start of list","text":"<p>Create a function to add a song to the start of the song list.</p> Function to add song to list <p>The <code>add-song</code> function takes the name of a song and the song list to which it will be added.</p> <p>A Thread-last macro <code>-&gt;&gt;</code> is used to pass the song list over two functions.</p> <p>The <code>song-list</code> is first passed to the <code>remove</code> expression as its last argument.  This expression will remove any occurrence of the new song we want to add from the <code>song-list</code>.</p> <p>The results of the <code>remove</code> expression are then passed to the <code>cons</code> expression as its last argument.  The <code>cons</code> expression simply adds the new song to the start of the list, making it the most recent song.</p> src/playground/song_list.clj<pre><code>(def recent-songs [])\n\n(defn add-song [song song-list]\n  (-&gt;&gt; song-list\n       (remove #(= song %))\n       (cons song)))\n</code></pre> <p><code>recent-songs</code> is passed into the <code>add-song</code> function as an argument, <code>song-list</code> to keep the design of <code>add-song</code> function pure (no side-effects).  This design also provides greater scope to using the <code>add-song</code> function, as any song list can be added to, rather than hard-coding <code>recent-songs</code> list.</p>"},{"location":"code-kata/salary-slip-generator/","title":"Salary Slip Kata","text":"<p> Pracitcalli Clojure CLI Config provides the <code>:project/create</code> alias to create projects using deps-new project.</p> <pre><code>clojure -T:project/create :template app :name practicalli/salary-calculator\n</code></pre>"},{"location":"code-kata/salary-slip-generator/#problem-description","title":"Problem description","text":"<p>A typical salary slip contains employee details like employee id, employee name and their monthly salary details like their gross salary, national insurance contributions, tax-free allowance, taxable income and tax payable.</p> <p>Salary slips are generated each month for every employee.</p>"},{"location":"code-kata/salary-slip-generator/#acceptance-criteria","title":"Acceptance criteria","text":"<ul> <li>Salary slip generator should receive an employee with its Employee Id, Employee Name and Annual Gross Salary</li> <li>Salary slip should contain the Employee ID, Employee Name, Gross Salary, National Insurance contributions, Tax-free allowance, Taxable income and Tax payable for the month</li> <li>The entry point should be the following public function API</li> </ul> <pre><code>(defn salary-slip-generator\n  \"\"\n  [employee]\n  ,,,)\n</code></pre>"},{"location":"code-kata/salary-slip-generator/#iterations","title":"Iterations","text":"<p>Each iteration adds more rules to the calculation. Some iterations also introduce new fields to the salary slip.</p> <p>In a given iteration, all the salary slips contain the same number fields for each employee (if a tax or contribution does not apply for a given employee, just put \u00a30.00).</p> <p>This means that for each iteration you will need to add fields to the <code>SalarySlip</code> class. In the first iteration, <code>SalarySlip</code> only contains the Employee ID, Employee Name and Monthly Gross Salary.</p>"},{"location":"code-kata/salary-slip-generator/#iteration-1-for-an-annual-salary-of-500000","title":"Iteration 1: for an annual salary of \u00a35,000.00","text":"<p>This is the most basic case.</p> <ul> <li>Given I have an employee John J Doe with an annual gross salary of \u00a35,000.00</li> <li>When I generate a monthly salary slip for the employee</li> <li>Then the monthly salary slip should contain the below<pre><code>   Employee ID: 12345\n   Employee Name: John J Doe\n   Gross Salary: \u00a3416.67\n</code></pre> </li> </ul> <p>Calculation rules:</p> <ul> <li>Monthly Gross Salary: The monthly gross salary is the employee's annual gross salary divided by 12</li> </ul>"},{"location":"code-kata/salary-slip-generator/#iteration-2-for-an-annual-gross-salary-of-906000","title":"Iteration 2: for an annual gross salary of \u00a39,060.00","text":"<p>Here we introduce the National Insurance contribution</p> <p>The monthly salary slip should contain the below:</p> <pre><code>       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a3755.00\n       National Insurance contributions: \u00a310.00\n</code></pre> <p>Calculation rules:</p> <ul> <li>National Insurance contributions: Any amount of money earned above a gross annual salary of \u00a38,060.00 is subject to a National Insurance contribution of 12%</li> </ul>"},{"location":"code-kata/salary-slip-generator/#iteration-3-for-an-annual-gross-salary-of-1200000","title":"Iteration 3: for an annual gross salary of \u00a312,000.00","text":"<p>This employee also needs to pay taxes</p> <p>The monthly salary slip should contain the below:</p> <pre><code>       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a31,000.00\n       National Insurance contributions: \u00a339.40\n       Tax-free allowance: \u00a3916.67\n       Taxable income: \u00a383.33\n       Tax Payable: \u00a316.67\n</code></pre> <p>Calculation rules:</p> <ul> <li>Taxable income: Any amount of money earned above a gross annual salary of \u00a311,000.00 is taxed at 20%</li> </ul>"},{"location":"code-kata/salary-slip-generator/#iteration-4-for-an-annual-gross-salary-of-4500000","title":"Iteration 4: for an annual gross salary of \u00a345,000.00","text":"<p>This employee pays a higher band of National Insurance and Income Tax.</p> <p>The monthly salary slip should contain the below:</p> <pre><code>       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a33,750.00\n       National Insurance contributions: \u00a3352.73\n       Tax-free allowance: \u00a3916.67\n       Taxable income: \u00a32,833.33\n       Tax Payable: \u00a3600.00\n</code></pre> <p>Calculation rules:</p> <ul> <li>Taxable income (higher rate): Any amount of money earned above a gross annual salary of \u00a343,000.00 is taxed at 40%</li> <li>National Insurance (higher contributions): Any amount of money earned above a gross annual salary of \u00a343,000.00 is only subject to a 2% NI contribution</li> </ul>"},{"location":"code-kata/salary-slip-generator/#iteration-5-for-annual-gross-salaries-of-10100000-11100000-12200000-and-15000000","title":"Iteration 5: for annual gross salaries of \u00a3101,000.00; \u00a3111,000.00; \u00a3122,000.00 and \u00a3150,000.00","text":"<p>For high earners, the tax-free allowance decreases.</p> <p>The monthly salary slips should contain the below (respectively):</p> <pre><code>       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a38,416.67\n       National Insurance contributions: \u00a3446.07\n       Tax-free allowance: \u00a3875.00\n       Taxable income: \u00a37,541.67\n       Tax Payable: \u00a32,483.33\n\n\n       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a39,250.00\n       National Insurance contributions: \u00a3462.73\n       Tax-free allowance: \u00a3458.33\n       Taxable income: \u00a38,791.67\n       Tax Payable: \u00a32,983.33\n\n\n       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a310,166.67\n       National Insurance contributions: \u00a3481.07\n       Tax-free allowance: \u00a30.00\n       Taxable income: \u00a310,166.67\n       Tax Payable: \u00a33,533.33\n\n\n       Employee ID: 12345\n       Employee Name: John J Doe\n       Gross Salary: \u00a312,500.00\n       National Insurance contributions: \u00a3527.73\n       Tax-free allowance: \u00a30.00\n       Taxable income: \u00a312,500.00\n       Tax Payable: \u00a34,466.67\n</code></pre> <p>Calculation rules:</p> <ul> <li>Tax-free allowance: When the Annual Gross Salary exceeds \u00a3100,000.00, the tax-free allowance starts decreasing. It decreases by \u00a31 for every \u00a32 earned over \u00a3100,000.00. And this excess is taxed at the Higher rate tax.</li> </ul>"},{"location":"code-kata/salary-slip-generator/#iteration-6-for-an-annual-gross-salary-of-16000000","title":"Iteration 6: for an annual gross salary of \u00a3160,000.00","text":"<p>The employee goes into the additional rate band.</p> <p>The monthly salary slip should contain the below:</p> <pre><code>      Employee ID: 12345\n      Employee Name: John J Doe\n      Gross Salary: \u00a313,333.33\n      National Insurance contributions: \u00a3544.40\n      Tax-free allowance: \u00a30.00\n      Taxable income: \u00a313,333.33\n      Tax Payable: \u00a34,841.67\n</code></pre> <p>Calculation rules:</p> <ul> <li>Income tax (additional rate band) : Any amount of money earned above a gross annual salary of \u00a3150,000.00 is taxed at 45%</li> </ul> Practicalli Salary Slip Kata <p>  ```clojure (ns salary-slip-kata.core)</p> <p>;; Developer Anarchy by Fred George ;; - made devs write the same solution in different languages ;; -- helps devs master the business domain ;; -- helps devs master technology domain</p> <p>(defn- national-insurance-contribution   \"Calculate the national insurance contribution due for a given annual salary.</p> <p>---------------------+-------------------------+--------   Band                 | NI deductible income    | NI Rate   ---------------------+-------------------------+--------   No contributions     | Up to \u00a38,060.00         |    0%   Basic contributions  | \u00a38,060.00 to \u00a343,000.00 |   12%   Higher contributions | over \u00a343,000.00         |    2%   ---------------------+-------------------------+-------- \"</p> <p>[annual-gross-salary]   ;; add a cond statement to return the calculate the value with respect to the band.   (* annual-gross-salary 0.12))</p> <p>;; taxable income ;; ---------------------+---------------------------+--------- ;; Band                 | Taxable income            | Tax rate ;; ---------------------+---------------------------+--------- ;; Personal Allowance*  | Up to \u00a311,000.00          |    0% ;; Basic rate           | \u00a311,000.00 to \u00a343,000.00  |   20% ;; Higher rate          | \u00a343,000.00 to \u00a3150,000.00 |   40% ;; Additional rate      | over \u00a3150,000.00          |   45% ;; ---------------------+---------------------------+---------</p> <p>(defn salary-slip   \"Creates a salary slip for a person</p> <p>Specifically for employee of 24K annual salary\"</p> <p>[{:keys [employee-id            employee-name            annual-gross-salary]}]   (let [tax-free-allowance 11000         taxable-income     (- annual-gross-salary                               tax-free-allowance)]     {:employee-id        employee-id      :employee-name      employee-name      :gross-salary       (/ annual-gross-salary 12)      :national-insurance (national-insurance-contribution annual-gross-salary)      :tax-free-allowance tax-free-allowance      :taxable-income     taxable-income      :tax-payable        (* taxable-income 0.20)}))     ```</p>"},{"location":"code-kata/tripple-lock/","title":"Code Kata: Combination Lock","text":"<p>An exercise to become more comfortable with the concept of List Comprehension</p> <p>Lisp comprehension</p> <p>In Clojure, list comprehension is via the for function</p> <ul> <li>Clojure docs: for</li> <li>Reference: Lisp Comprehension in Clojure - Clojure, practicalli</li> </ul> <p>The range function can generate a sequence of numbers, so could be used to create each tumbler.</p> <p>Combinations can be returned as a collection, eg. a vector.</p> <pre><code>(for [tumbler-1 (range 10)\n      tumbler-2 (range 10)\n      tumbler-3 (range 10)]\n [tumbler-1 tumbler-2 tumbler-3])\n</code></pre>"},{"location":"code-kata/tripple-lock/#notegenerate-all-the-combinations-for-a-lock-with-3-combination-tumblers","title":"Note::Generate all the combinations for a lock with 3 combination tumblers","text":"<p>Each combination is made up of three numbers (the tumblers). Each number is between 0 and 9 </p>"},{"location":"code-kata/tripple-lock/#alternative-exercises","title":"Alternative Exercises","text":"<p>Here are some exercises that could also be solved with list comprehension</p> <ul> <li>Fizzbuzz</li> </ul>"},{"location":"colours-and-shapes/","title":"Colours and Shapes","text":"<p>The Colours and Shapes in Clojure learning path uses an interactive website called Maria.cloud.  It lets you write code and see the results straight away.  You can also make your own note and save them once you have taken a copy.</p>"},{"location":"colours-and-shapes/#hintrequirements","title":"Hint::Requirements","text":"<p>We will ask you to login to Maria.cloud with your GitHub account.</p> <p>Please create a free GitHub account if you do not already have one.</p>"},{"location":"colours-and-shapes/#sign-in-to-mariacloud","title":"Sign-in to Maria.cloud","text":"<p>Open the Maria.cloud website and sign-in using the same GitHub account.</p> <p>You may be prompted to authorize Maria.cloud access to your GitHub account.  This is safe (and can be revoked after the event)</p> <p></p>"},{"location":"colours-and-shapes/#open-and-duplicate-the-clojurebridge-london-curriculum","title":"Open and duplicate the ClojureBridge London curriculum","text":"<p>Click on the start here link for the Feb 2020 London ClojureBridge event</p> <p></p> <p>Press the duplicate button to create your own copy (so you can save all your code)</p> <p></p> <p>You should now have your own copy, as show in the top bar</p> <p></p>"},{"location":"colours-and-shapes/#hintduplicate-not-working","title":"Hint::Duplicate not working?","text":"<p>Try logging out of maria.cloud and then logging back in again (I know, but it might work)</p> <p>If you are using Chrome, try using an Incognito browser tab or window. Or try Firefox browser.</p>"},{"location":"first-steps/","title":"First Steps in Clojure","text":"<p>Start a Clojure REPL and evalute the code examples in this section to gain experience with Clojure.</p> <p>Hello World is a common first line of code in any new language.</p> <p>From this humble beginning the following concepts are introduced.</p> <ul> <li>fundamental syntax</li> <li>expressions</li> <li>calling functions and arguments</li> <li>implicity types</li> <li>homoiconicity</li> </ul> <p>Exercises</p>"},{"location":"first-steps/#mathematics","title":"Mathematics","text":"<ul> <li>number representations</li> <li>integer, double, float, ratio, BigInt, BigDecimal, E, M</li> <li>clojure.core math functions</li> <li>Java math functions</li> </ul> <p>Exercises</p> <ul> <li>Age of Languages</li> <li>Convert time to numbers</li> </ul>"},{"location":"first-steps/date-time/","title":"Dates and Time","text":"<p>Introduction to Java Interoperability</p> <p>Use cases for dates and times</p> <ul> <li>timestamps on log events</li> <li>calendars</li> <li>tracking work</li> <li>calculating time between two date stamps</li> </ul> <p>Java Time available by default</p> <p><code>java.time</code> namespace is available on the class path by default, <code>require</code> or <code>import</code> expressions are not required.</p>"},{"location":"first-steps/date-time/#current-data-time","title":"Current data time","text":"<p>Create a date and time stamp with the current data and time for the Operating System timezone.</p> <pre><code>(java.time.LocalDateTime/now)\n</code></pre> <p>A Java time object is returned</p> <pre><code>#object[java.time.LocalDateTime 0xf36f34d \"2023-07-13T13:32:22.483261516\"]\n</code></pre> <p>Current date</p> <pre><code>(java.time.LocalDate/now)\n\n;; =&gt; #object[java.time.LocalDate 0x5814b4fb \"2023-07-13\"]\n</code></pre> <p>Instant</p> <pre><code>(java.time.Instant/now)\n;; =&gt; #object[java.time.Instant 0x3684d2c0 \"2023-07-13T13:02:27.889805413Z\"]\n</code></pre>"},{"location":"first-steps/date-time/#clojure-spec","title":"Clojure Spec","text":"<p>use Clojure Spec to define a data structure containing a java.time.LocalDate element</p> <pre><code>(spec/def :employee/first-name string?)\n(spec/def :employee/last-name string?)\n(spec/def :employee/birth-date #(instance? java.time.LocalDate %))\n\n(spec/def :employee/person\n  (s/keys :req [:employee/first-name\n                :employee/last-name\n                :employee/birth-date]))\n\n(def jenny #:ex{:first-name \"Jenny\"\n             :last-name  \"Barnes\"\n             :birth-date (java.time.LocalDate/parse \"1910-03-15\")})\n</code></pre> <p>Check to see if Jenny is a valid employee</p> <pre><code>(s/valid? :employee/person jenny)\n;; =&gt; true\n</code></pre>"},{"location":"first-steps/functions/","title":"Functions","text":"<p>The Clojure Standard Library contains hundreds of functions for writing custom applications and services.</p> <p><code>defn</code> function is used to define functions</p> <pre><code>(defn hello-world \n  [name]\n  (str \"Hello\" name \", welcome to Clojure\")\n</code></pre> <p>Evaluate the <code>hello-world</code> function definition expression, then call the <code>hello-world</code> function with an argument</p> <pre><code>(hello-world \"Jenny\")\n</code></pre> <p>The last expression in a function definition is returned when the function is called.  An explicity return expression is not required.</p> <p>Function definition must be evaluated before use</p> <p>In a Clojure source code file, the function definition code must be written before any code that calls that function, otherwise a symbol not found error will occur</p> <p>During development, experimental code can be written after it is called as long as that definition has been evaluated in the REPL.  e.g. a new design for a function could be written in a rich comment, <code>(comment ,,,)</code> at the bottom of the source code file and evaluated to replace a definition further up in the source code file.  If the new design for the function is preferred its code would replace the original definition.  If the new design is interesting but not desired, it could be kept as part of a design journal.</p> Avoid using declare <p><code>declare</code> allows for a symbol to be defined without a value.  A function name could be defined at the top of a Clojure source code file with the function definition, <code>defn</code>, occuring lower down in the file after code that calls the function.</p> <p>It is commonly viewed as a need to refactor the design if <code>declare</code> is required, e.g. two functions call each other.  Function definitions should be defined so that <code>declare</code> is not required, typically by extracting code into other functions.</p>"},{"location":"first-steps/functions/#function-arguments","title":"Function arguments","text":"<p>Argument names are defined in a vector, <code>[]</code></p> <p>Functions are limited to recieving 26 arguments. In reality a minimal number should be passed or multiple values passed as a collection.</p> <p><code>&amp; arguments</code> in the function definition will take zero or more values, placing all values into a vector, <code>[]</code></p> <p><code>:as</code> to group all arguments as one collection of values  </p> <p>none, one, or many arguments</p> <p>Practicalli recommends designing a function to recieve either no arguments, one argument or many arguments</p> <p>A hash-map can be considered one argument that abstracts many arguments.</p> <p>hash-maps as arguments</p> <p>Pass a hash-map as an argument to a function provides scope for growth.</p> <p>Keys can be added to the hash-map to extend the capabilities of the function without breaking existing calls to the function.</p> <p>Using keys and values provides more context as to the purpose of the arguments passed.</p> <p>unnamed arguments</p> <p><code>_</code> is used as an argument name when an argument has to be passed to a function, but the function is not going to use the argument.</p> <p><code>_</code> may be used to represent the request hash-map passed to handler functions in Clojure services and APIs.</p>"},{"location":"first-steps/functions/#destructure-arguments","title":"Destructure arguments","text":"<p>Associative destructuring is the most common approach to function definition design</p> <p><code>:keys</code> declaration generates local names from the matching keywords given in a vector, <code>[]</code></p> <pre><code>(defn destructure-arguments\n  [{:keys [a b c]}]\n  (str \"Extracted keys have the values:\" a b c)\n)\n</code></pre>"},{"location":"first-steps/functions/#function-specifications","title":"Function specifications","text":"<p><code>clojure.spec</code> can be used to instrument a function, checking the correct types of values are passed as arguments.</p>"},{"location":"first-steps/hello-world/","title":"Hello World","text":"<p>Writing code to print out hello world is a common first step with any new language.</p> <p>Use the <code>println</code> function from clojure.core to accomplish this task.</p> <p>Enter the following code at the REPL prompt:</p> <pre><code>(println \"Hello World\")\n</code></pre> <p>Expected result</p> <pre><code>Hello World\nnil \n</code></pre> <p><code>Hello World</code> is printed, followed by a <code>nil</code> value.</p> <p>println is a side-effect function</p> <p><code>println</code> is considered a function that creates a side-effect, as it sends information to the standard out process rather than returning a value.</p> <p><code>nil</code> is the default return value if an expression does not return a value.</p>"},{"location":"first-steps/hello-world/#a-clojure-expression","title":"A Clojure Expression","text":"<p><code>()</code> are used to define a Clojure expression.</p> <p><code>()</code> means a list of elements, the first element is a call to a function and all other elements are passed as arguments to the function.</p> Homoiconicity - one represent for code and data <p>Clojure is homoiconic as code and data share the same representation, i.e. use the same iconography.</p> <p>A <code>()</code> list is a data structure, a collection of data values.</p> <p>A <code>()</code> list is also used to represent code behaviour (algorithms), e.g calling built-in or custom functions.</p> <p>A function call returns a data value (nil is also a value).</p>"},{"location":"first-steps/hello-world/#return-a-value","title":"Return a value","text":"<p>Expressions and Function calls always return a value, the <code>nil</code> value being returned by default.</p> <p>An explicit return form is not required, the result of the last expression is returned.</p> <p>Enter the following code at the REPL prompt:</p> <pre><code>(str \"Hello World\")\n</code></pre> <p>Expected result</p> <pre><code>\"Hello World\"\n</code></pre> <p><code>Hello World</code> is returned as a data value, instead of the default <code>nil</code> return value.</p> <p>The example is a single expression, so the value created by evaluating the expresion is returned.</p> <p><code>clojure.core/str</code> is a function that takes one or more values and return a string.  The values do not need to be strings as Clojure will dynamically convert them.</p> <p>Join strings and a numeric value</p> <pre><code>(str \"hello world\" \" \" 2)\n</code></pre> <p>Expected result</p> <pre><code>\"hello world 2\"\n</code></pre> <p>Join strings and the result of a function call</p> <pre><code>(str \"hello world\" \" \" (+ 1 2))\n</code></pre> <p>Expected result</p> <pre><code>\"hello world 3\"\n</code></pre> <p><code>+</code> is the name of a function, its qualified name is <code>clojure.core/+</code>.  <code>+</code> takes zero or more arguments, adds the values together and returns the result.</p> <p>A function call always returns a value so can be used as an argument to another funciton, or anywhere a value would be used.</p> <p>Implicit types</p> <p>Clojure uses types underneath and infers the type of something by its literal shape</p> <p><code>\"string\"</code> is a string type, <code>java.lang.String</code></p> <p><code>123</code> is an Integer value, <code>java.lang.Long</code></p> <p><code>3.14</code> is a Decimal value, <code>java.lang.Double</code></p> <p><code>22/7</code> is a Ratio value, <code>clojure.lang.Ratio</code> (used to preserve accuracy of data)</p>"},{"location":"first-steps/maths/","title":"Numbers and Mathematics","text":"<p>Computers were designed to run lots of calculations, so its easy to do maths.  You can use the following basic math functions:</p> <ul> <li><code>+</code> add numbers together</li> <li><code>-</code> subtract numbers from each other</li> <li><code>*</code> multiply numbers together</li> <li><code>/</code> divide numbers</li> </ul> <p>Look at these examples of Clojure code and their equivalent math expression:</p> <pre><code>(+ 1 1)         ;=&gt; 1 + 1 = 2\n(- 12 4 1)      ;=&gt; 12 - 4 - 1 = 7\n(* 13 2 10 2)   ;=&gt; 13 * 2 * 10 * 2 = 520\n(/ 27 9)        ;=&gt; 27 / 9 = 3\n(+ 4/3 7/8)   ;=&gt; 53/24 Ratio value \n(- 9 4.2 1/2) ;=&gt; 4.3   Ratio cast to Double\n</code></pre> <p>Math looks a little different in Clojure because <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> are functions, which take numbers as arguments.</p> <p>Number representations</p> <p><code>123</code> is an Integer value, <code>java.lang.Long</code></p> <p><code>3.14</code> is a Decimal value, <code>java.lang.Double</code></p> <p><code>22/7</code> is a Ratio value, <code>clojure.lang.Ratio</code> (used to preserve accuracy of data)</p>"},{"location":"first-steps/maths/#ratios","title":"Ratios","text":"<p>Mathematics includes the fraction, e.g. 22/7, to express what would otherwise be decimal values with potentially less accuracy.  </p> <p>Clojure provides the ratio type and values can be litterally expressed as a fraction.</p> <p>Computers cannot perfectly represent all floats, but ratios are always exact.</p> <pre><code>1/2\n-7/3\n</code></pre> Denominator must not be zero <p>The denominator of a ratio cannot be equal to <code>0</code>, as this would be equivalent to dividing by zero.</p> <p> Clojure Ratio type  Fraction - Wikipedia</p>"},{"location":"first-steps/maths/#prefix-notation","title":"Prefix notation","text":"<p>In Clojure, <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> appear before two numbers. This is called prefix notation. What you're used to seeing is called infix notation, as the arithmetic operator is in-between the two operands.</p> <p>Languages such as JavaScript use infix notation, while Clojure only uses prefix notation.</p> <p>Prefix notation is useful for many reasons. Look at this example of an infix expression and the prefix equivalent:</p> <pre><code>Infix:  1 + 2 * 3 / 4 + 5 - 6 * 7 / 8 + 9\n\nPrefix: (+ (- (+ (+ 1 (/ (* 2 3) 4)) 5) (/ (* 6 7) 8)) 9)\n</code></pre>"},{"location":"first-steps/maths/#benefits-of-prefix-notation","title":"Benefits of prefix notation","text":"<p>Imagine both the above expressions are unclear.  However in the prefix version you do not have to ever think about the precedence of operators.</p> <p>Because each expression has the operator before all the operands and the entire expression is wrapped in parentheses, all precedence is explicit.</p> <pre><code>Infix:  1 + 2 / 3\nPrefix: (+ 1 (/ 2 3))\n</code></pre>"},{"location":"first-steps/maths/#less-repetitive","title":"Less repetitive","text":"<p>Another reason prefix notation can be nice is that it can make long expressions less repetitive.</p> <p>With prefix notation, if we plan to use the same operator on many operands, we do not have to repeat the operator between them.</p> <pre><code>Infix:  1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9\nPrefix: (+ 1 2 3 4 5 6 7 8 9)\n</code></pre>"},{"location":"first-steps/maths/#exercises","title":"Exercises","text":"<p>Start a Clojure REPL and solve math related exercises.</p>"},{"location":"first-steps/maths/#age-of-languages","title":"Age of Languages","text":"<p>Clojure was 16 years old in 2023, so its age can be represented as the number <code>16</code></p> <p>Write an expression to calculate the total number of years from all the following languages</p> <ul> <li>Clojure (16 years)</li> <li>Haskell (33 years)</li> <li>Python (32 years)</li> <li>Javascript (27 years)</li> <li>Java (28 years)</li> <li>Ruby (28 years)</li> <li>C (51 years)</li> <li>C++ (40 years)</li> <li>Lisp (65 years)</li> <li>Fortran (66 years)</li> </ul> <p>Language ages as raw data</p> <pre><code>16 33 32 27 28 28 51 40 65 66\n</code></pre> Example solution <p>The simplest way to calculate the total is to add the age of each language together</p> <p><code>clojure.core/+</code> adds all the ages together</p> <pre><code>(+ 16 33 32 27 28 28 51 40 65 66)\n</code></pre> <p>As two values the same a function call to <code>clojure.core/*</code> could be used instead </p> <pre><code>(+ 16 33 32 27 (* 28 2) 51 40 65 66)\n</code></pre>"},{"location":"first-steps/maths/#average-age","title":"Average age","text":"<p>Calculate the average age of the 10 programming languages</p> <p>Write an expression to divide the total age of all languages by 10, as there are 10 languages.</p> <p>Add the ages of all the programming languages.  </p> <p>Wrap that expression with another to divide that total age with the number of languages</p> Example Solution <pre><code>(/ (+ 16 33 32 27 28 28 51 40 65 66)\n   10)\n</code></pre>"},{"location":"first-steps/name-association/","title":"Name association","text":"<p><code>def</code> function associates a name (symbol) with a value, allowing the name to be used as a placeholder for the value.</p> <p>Define a name for a simple value</p> <p>Define <code>first-name</code> as a name (symbol) that is associated with (bound to) the value \"Jenny\"</p> <p><pre><code>(def first-name \"Jenny\")\n</code></pre> Names (symbols) in Clojure that have multiple words use the <code>kebab-case</code> style (like a  shish kebab where words are skewered with dashes) </p> <p><code>def</code> has the scope of the namespace, so can with functions within that namespace or where the namespace of the def has been required.</p> <p>Define and use a name</p> <p><pre><code>(ns practicalli.playground)\n\n(def language-ages [16 33 32 27 28 28 51 40 65 66])\n\n(/ (apply + language-ages)\n   (count language-ages))\n</code></pre> <code>language-ages</code> is defined as a collection of number values representing the age of ten different programming languages.</p> <p><code>apply</code> uses <code>+</code> function to add all the language ages together to get a total age</p> <p><code>count</code> returns the number of values in the collection and that value divides the total age to get the average age.</p> <p>The value in a <code>def</code> expression is evaluated, so can be a simple value, an expression or a function call.</p> <p>def with a calcualted value</p> <pre><code>(def seconds-in-one-hour (partial * 60 60))\n</code></pre> Values of def are cached in the REPL <p>When a <code>def</code> expression is first evaluated the value is cached in the REPL state.</p> <p>When evaluating the name created by the def, the cached value is used.  Only when the <code>def</code> expression is evaluated again is the value potentially changed.</p> <p>Where the value is an expression, the resulting value from evaluating the expresison is associated with the name.  So the name (symbol) can act as simple cache within the REPL.</p> <p>def with a partial function</p> <p><pre><code>(def hours-&gt;seconds (partial * 60 60))\n</code></pre> <code>partial</code> is an example of a lazyly evaluated form, so the name <code>hours-&gt;seconds</code> will be bound to the value <code>(partial * 60 60)</code> </p> <p>The Clojure idiom is to use an anonymous function, in this example the short form of the anonymous function.</p> <pre><code>(def hours-&gt;seconds #(* 60 60 %))\n</code></pre>"},{"location":"first-steps/name-association/#local-names","title":"Local names","text":"<p><code>let</code> associates (binds) names to values within the scope of its own expression.  Outside the <code>let</code> expression the name is out of scope.</p> <pre><code>(let [name value]\n  name)\n</code></pre> <p><code>let</code> is used inside a function definition to hold values, mainly to simplify the code reqiured within that function.</p> <p><code>let</code> can reduce duplication by associating the result of an expression to a name and using that name where ever that value is required.</p> <p>A name can use other names associated to values in the let, as long as they preceed the name.  </p> <p>avoid using def for local names</p> <p><code>let</code> should always be used within function definitions.</p> <p><code>def</code> expression should not be used within a function definition as namespace scope should not be mixed in with local scope.  Use an <code>atom</code>, <code>println</code> or <code>tap&gt;</code> if values need to be captured other than those returned by the function.</p> <p>use let for REPL experiments</p> <p><code>let</code> expression can be very useful for REPL experiments, defining a known state to evaluate expressions. </p> <p>There\u2019s an old bit of wisdom that contends that naming things is one of the two hardest problems in programming. Difficult or not, putting names to values is something programmers do constantly. But in programs not all names are created equal. Sometimes we want to name a value that is going to stick around for a long time and we want that name to be widely visible. But sometimes we want a temporary name, a name that we can use right here, right now and then dispose of without another thought. The good news is that we have the first kind of names, the long-lasting ones, covered: that\u2019s what def\u2014and if you think about it, defn\u2014are for.</p> <p>So in this chapter we\u2019ll look at let, which takes care of those local, temporary naming chores. We\u2019ll see how, along with enabling you to mix intention-revealing names into your code, let is also surprising helpful in writing higher-order functions. We\u2019ll also explore how if-let and when-let enable you to combine a let with an if and a when. And, as usual, we\u2019ll look at some uses of let in real-world programs and at some of the ways you can let yourself in for trouble.</p>"},{"location":"first-steps/name-association/#a-local-temporary-place-for-your-stuff","title":"A Local, Temporary Place for Your Stuff","text":"<p>We\u2019ll begin our exploration of local naming in Clojure by imagining that our book store runs periodic specials. Every now and then we offer our customers a percentage discount on their book purchases. Unfortunately, our deal does come with some fine print: there\u2019s a minimum charge for each order that overrides the discount.</p> <p>Armed with our hard-won knowledge of functions and if, it\u2019s not difficult to turn this discount policy into Clojure code:</p> <p>let/examples.clj \u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200bif\u200b (&gt; ( amount (- 1.0 discount-percent)) min-charge) \u200b       ( amount (- 1.0 discount-percent)) \u200b       min-charge)) As a bit of everyday software engineering, compute-discount-amount is a mixed bag. On the plus side, it does work. Unfortunately, compute-discount-amount is hardly a model of clarity. Come back to this code after a few months\u2019 absence, and there\u2019s a fair chance you\u2019ll be muttering, Wait, what times who is greater than huh?</p> <p>Clearly a bit of intention-revealing naming is called for. The code would be a lot easier to follow if we could bind a symbol\u2014perhaps called discounted-amount\u2014to the appropriate value and have that binding disappear once we\u2019re done computing discounts. But how?</p> <p>You might be tempted to do something like this:</p> <p>\u200b   \u200b;; Don't do this!\u200b \u200b  \u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200bdef\u200b discounted-amount (* amount (- 1.0 discount-percent)))   \u200b; NOOOOO!\u200b \u200b     (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b       discounted-amount \u200b       min-charge)) There are two reasons that you should avoid using def like this, inside of a function. The first reason is that, as we have seen, symbols bound with def have reasonably global visibility. Calling this version of compute-discount-amount will have the ugly side effect of changing the value bound to discounted-amount, and that change will be visible outside of the function:</p> <p>\u200b   \u200b;; A nasty side effect is brewing here.\u200b \u200b  \u200b   (\u200bdef\u200b discounted-amount \u200b\"Some random string.\"\u200b) \u200b  \u200b   (compute-discount-amount 10.0 0.20 1.0) \u200b  \u200b   discounted-amount   \u200b; Is now 8.00\u200b The second, more philosophical reason is that using def this way is actually misusing it: def is designed to bind more or less global symbols to their more or less stable values. Instead of def you should use let for your local-naming needs:</p> <p>\u200b   \u200b;; Do use let!\u200b \u200b  \u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200blet\u200b [discounted-amount (* amount (- 1.0 discount-percent))] \u200b       (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b         discounted-amount \u200b         min-charge))) The mechanics of let couldn\u2019t be simpler: you call let like a function, passing in a name and a value\u2014wrapped in square brackets\u2014followed by an expression. In essence you say, Execute this expression with this symbol bound to this value. In our example, the symbol was discounted-amount and the value was the order amount less the percentage discount. As you can probably figure out from the example, the value returned by the let is the value computed by the expression\u2014the body\u2014of the let. Critically, the bindings manufactured by let go away once the let is done, so that you can get on with the rest of the code without littering your mental landscape with stray names.</p> <p>One nice feature of let is that you can bind multiple names inside a single let. We could, for example, make the code a bit clearer by doing the percentage-off calculation in two steps:</p> <p>\u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200blet\u200b [discount (* amount discount-percent) \u200b           discounted-amount (- amount discount)] \u200b       (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b         discounted-amount \u200b         min-charge))) The rule is that let will bind each name to its corresponding value, starting with the first one. Each name becomes available immediately after it\u2019s bound, which is why we can use discount to compute discounted-amount.</p> <p>You can also have more than one expression inside the body of the let. If, for example, you wanted to print our intermediate values for debugging purposes, you could do this:</p> <p>\u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200blet\u200b [discount (* amount discount-percent) \u200b           discounted-amount (- amount discount)] \u200b       (println \u200b\"Discount:\"\u200b discount) \u200b       (println \u200b\"Discounted amount\"\u200b discounted-amount) \u200b       (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b         discounted-amount \u200b         min-charge))) Keep in mind that while all the expressions in the body of a let get evaluated, only the last expression has anything to say about the value returned by the let.</p>"},{"location":"first-steps/name-association/#let-over-fn","title":"Let Over Fn","text":"<p>While the ideas behind let aren\u2019t terribly challenging\u2014it binds names to values in a purely local and temporary way\u2014let does have some hidden superpowers, which only become visible when you combine it with fn. To get a glimpse of these hidden powers, imagine our book discounts are customer-dependent. Somewhere we have a map of the user\u2019s name to the discount that user gets:</p> <p>\u200b   (\u200bdef\u200b user-discounts \u200b     {\u200b\"Nicholas\"\u200b 0.10 \u200b\"Jonathan\"\u200b 0.07 \u200b\"Felicia\"\u200b 0.05}) We could certainly add some parameters to compute-discount-amount to deal with this:</p> <p>\u200b   (\u200bdefn\u200b compute-discount-amount [amount user-name user-discounts min-charge] \u200b     (\u200blet\u200b [discount-percent (user-discounts user-name) \u200b           discount (* amount discount-percent) \u200b           discounted-amount (- amount discount)] \u200b       (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b         discounted-amount \u200b         min-charge))) The trouble with this approach is that we now have to carry the \u201cuser names and discounts\u201d table around every time we want to compute a price. If all that extra lifting turns out to be a problem, a better strategy might be to create a higher-level function, one that produces variants of the compute-discount-amount function tailored to a particular customer:</p> <p>\u200b   (\u200bdefn\u200b mk-discount-price-f [user-name user-discounts min-charge] \u200b     (\u200blet\u200b [discount-percent (user-discounts user-name)] \u200b       (\u200bfn\u200b [amount] \u200b         (\u200blet\u200b [discount (* amount discount-percent) \u200b               discounted-amount (- amount discount)] \u200b           (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b             discounted-amount \u200b             min-charge))))) \u200b  \u200b   \u200b;; Get a price function for Felicia.\u200b \u200b  \u200b   (\u200bdef\u200b compute-felicia-price (mk-discount-price-f \u200b\"Felicia\"\u200b user-discounts 10.0)) \u200b  \u200b   \u200b;; ...and sometime later compute a price\u200b \u200b  \u200b   (compute-felicia-price 20.0) There are quite a few moving parts in mk-discount-price-f, but it\u2019s just a combination of features we\u2019ve already seen. The first thing mk-discount-price-f does, in that initial let, is look up the discount percentage for the user. With the percentage rate in hand, mk-discount-price-f then constructs an anonymous function with an fn whose body is nearly identical to compute-discount-amount.</p> <p>The interesting thing about mk-discount-price-f is how discount-percent gets bound in the initial let, outside of the fn and then used inside the fn. That means that while discount-percent is only visible inside the body of the let, it can live on long after the call to mk-discount-price-f has completed, buried inside of the anonymous function.</p> <p>This compute it in a let, use it in an fn is such a great way to build anonymous functions that are both efficient and clear. It\u2019s efficient because you can use the outside let to compute everything you need to construct the anonymous function. And it\u2019s clear because inside of the anonymous function you can use descriptive names for those precomputed values.</p>"},{"location":"first-steps/name-association/#variations-on-the-theme","title":"Variations on the Theme","text":"<p>In addition to the plain vanilla version of let that we\u2019ve looked at so far, Clojure comes packaged with a couple of handy variations. The most commonly used of these is probably if-let. As you might guess from the name, if-let is an if and a let rolled into one. To see if-let in action, imagine that we decide to represent anonymous books with our now-familiar book map, sans the :author key:</p> <p>\u200b   (\u200bdef\u200b anonymous-book \u200b     {:title \u200b\"Sir Gawain and the Green Knight\"\u200b}) \u200b  \u200b   (\u200bdef\u200b with-author \u200b     {:title \u200b\"Once and Future King\"\u200b :author \u200b\"White\"\u200b}) Now imagine we needed to write a function that will return the uppercase version of the author\u2019s name, or nil if there is no author. The twist is that we need to avoid computing the uppercase version of nil, which will blow up with an exception. Given that, we might do something like this:</p> <p>\u200b   (\u200bdefn\u200b uppercase-author [book] \u200b     (\u200blet\u200b [author (:author book)] \u200b       (\u200bif\u200b author \u200b         (.toUpperCase author)))) That will work, but we can say it a bit more succinctly with if-let:</p> <p>\u200b   (\u200bdefn\u200b uppercase-author [book] \u200b     (if-let [author (:author book)] \u200b       (.toUpperCase author))) In essence, if-let takes a single binding and uses the value bound\u2014in the example, the author\u2019s name\u2014as the condition of an if. Like a plain if, if-let will take a second expression, for the else case:</p> <p>\u200b   (\u200bdefn\u200b uppercase-author [book] \u200b     (if-let [author (:author book)] \u200b       (.toUpperCase author) \u200b       \u200b\"ANONYMOUS\"\u200b)) And if you think it would make more sense to call it let-if, well, me too.</p> <p>Unsurprisingly, there is also a when-let which does about what you would expect:</p> <p>\u200b   (\u200bdefn\u200b uppercase-author [book] \u200b     (when-let [author (:author book)] \u200b       (.toUpperCase author))) There really is nothing terribly deep about if-let and when-let: They are just the kinds of things that grow out of the observation that people frequently combine let with if and when.</p>"},{"location":"first-steps/name-association/#in-the-wild","title":"In the Wild","text":"<p>Real-life Clojure functions are full of let expressions. In fact, let is one of the most commonly used Clojure features, up there with defn and def. If, for example, you look at the Ring source code you will find the parse-params function. Here\u2019s a slightly simplified version of it:</p> <p>\u200b   (\u200bdefn\u200b parse-params [params encoding] \u200b     (\u200blet\u200b [params (codec/form-decode params encoding)] \u200b       (\u200bif\u200b (map? params) params {}))) Without diving into the belts and pulleys of Ring, we can deduce that parse-params decodes some raw parameter data into a value that is either a map or something else, presumably nil. Once it has the result of that decoding bound to params\u2014courtesy of let\u2014it proceeds to return the decoded value if it is indeed a map, or an empty map if it\u2019s not.</p> <p>If you dig around in Ring some more you\u2019ll discover the assoc-query-params function, which uses parse-params. Here is a slightly simplified version of that function, which has a vanilla let embedded in an if-let:</p> <p>\u200b   (\u200bdefn\u200b assoc-query-params \u200b     \u200b\"Parse and assoc parameters from the query string\u200b \u200b   \u200b  with the request.\"\u200b \u200b     [request encoding] \u200b     (merge-with merge request \u200b       (if-let [query-string (:query-string request)] \u200b         (\u200blet\u200b [params (parse-params query-string encoding)] \u200b           {:query-params params, :params params}) \u200b         {:query-params {}, :params {}}))) Pull the query string out of the request and call it query-string and, if you actually got something, proceed to parse the parameters and call the result in params and then \u2026 well, you get the picture.</p> <p>For a truly imposing example of a let, we need to look no further than this, from Incanter[14]: ]</p> <p>\u200b   (\u200blet\u200b [opts (\u200bif\u200b options (apply assoc {} options) {}) \u200b         data (or (:data opts) $data) \u200b         _x (data-as-list x data) \u200b         nbins (or (:nbins opts) 10) \u200b         theme (or (:theme opts) :default) \u200b         density? (true? (:density opts)) \u200b         title (or (:title opts) \u200b\"\"\u200b) \u200b         x-lab (or (:x-label opts) (str \u200b'x\u200b)) \u200b         y-lab (or (:y-label opts) \u200b                    (\u200bif\u200b density? \u200b\"Density\"\u200b \u200b\"Frequency\"\u200b)) \u200b         series-lab (or (:series-label opts) (str \u200b'x\u200b)) \u200b         legend? (true? (:legend opts)) \u200b         dataset (HistogramDataset.)] \u200b  \u200b     \u200b;; Do something heroic with x-lab and density?\u200b \u200b     \u200b;; and title and...\u200b \u200b     ) The preceding code, which is used in drawing histograms, binds no less then a dozen names. Glossing over the details\u2014which thankfully need not concern us here\u2014we can see that opts, which is defined right out of the gate, is used nine times later on in the let. Look a little more closely, and you can see that the value of opts comes out of an if expression, while the value of y-lab is computed with an if embedded in an or. Behold the power of an expression-based language.</p> <p>The other thing to behold is how much computing gets done inside the square brackets of this let. There are ifs and ors and a number other function calls going off in there. The lesson here is that if you have an intricate set of step-by-step values to compute, consider doing it inside the square brackets of let, giving each intermediate result an informative name. Your future self will thank you.</p>"},{"location":"first-steps/name-association/#a-local-temporary-place-for-your-stuff_1","title":"A Local, Temporary Place for Your Stuff","text":"<p>We\u2019ll begin our exploration of local naming in Clojure by imagining that our book store runs periodic specials. Every now and then we offer our customers a percentage discount on their book purchases. Unfortunately, our deal does come with some fine print: there\u2019s a minimum charge for each order that overrides the discount.</p> <p>Armed with our hard-won knowledge of functions and if, it\u2019s not difficult to turn this discount policy into Clojure code:</p> <p>let/examples.clj \u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200bif\u200b (&gt; ( amount (- 1.0 discount-percent)) min-charge) \u200b       ( amount (- 1.0 discount-percent)) \u200b       min-charge)) As a bit of everyday software engineering, compute-discount-amount is a mixed bag. On the plus side, it does work. Unfortunately, compute-discount-amount is hardly a model of clarity. Come back to this code after a few months\u2019 absence, and there\u2019s a fair chance you\u2019ll be muttering, Wait, what times who is greater than huh?</p> <p>Clearly a bit of intention-revealing naming is called for. The code would be a lot easier to follow if we could bind a symbol\u2014perhaps called discounted-amount\u2014to the appropriate value and have that binding disappear once we\u2019re done computing discounts. But how?</p> <p>You might be tempted to do something like this:</p> <p>\u200b   \u200b;; Don't do this!\u200b \u200b  \u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200bdef\u200b discounted-amount (* amount (- 1.0 discount-percent)))   \u200b; NOOOOO!\u200b \u200b     (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b       discounted-amount \u200b       min-charge)) There are two reasons that you should avoid using def like this, inside of a function. The first reason is that, as we have seen, symbols bound with def have reasonably global visibility. Calling this version of compute-discount-amount will have the ugly side effect of changing the value bound to discounted-amount, and that change will be visible outside of the function:</p> <p>\u200b   \u200b;; A nasty side effect is brewing here.\u200b \u200b  \u200b   (\u200bdef\u200b discounted-amount \u200b\"Some random string.\"\u200b) \u200b  \u200b   (compute-discount-amount 10.0 0.20 1.0) \u200b  \u200b   discounted-amount   \u200b; Is now 8.00\u200b The second, more philosophical reason is that using def this way is actually misusing it: def is designed to bind more or less global symbols to their more or less stable values. Instead of def you should use let for your local-naming needs:</p> <p>\u200b   \u200b;; Do use let!\u200b \u200b  \u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200blet\u200b [discounted-amount (* amount (- 1.0 discount-percent))] \u200b       (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b         discounted-amount \u200b         min-charge))) The mechanics of let couldn\u2019t be simpler: you call let like a function, passing in a name and a value\u2014wrapped in square brackets\u2014followed by an expression. In essence you say, Execute this expression with this symbol bound to this value. In our example, the symbol was discounted-amount and the value was the order amount less the percentage discount. As you can probably figure out from the example, the value returned by the let is the value computed by the expression\u2014the body\u2014of the let. Critically, the bindings manufactured by let go away once the let is done, so that you can get on with the rest of the code without littering your mental landscape with stray names.</p> <p>One nice feature of let is that you can bind multiple names inside a single let. We could, for example, make the code a bit clearer by doing the percentage-off calculation in two steps:</p> <p>\u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200blet\u200b [discount (* amount discount-percent) \u200b           discounted-amount (- amount discount)] \u200b       (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b         discounted-amount \u200b         min-charge))) The rule is that let will bind each name to its corresponding value, starting with the first one. Each name becomes available immediately after it\u2019s bound, which is why we can use discount to compute discounted-amount.</p> <p>You can also have more than one expression inside the body of the let. If, for example, you wanted to print our intermediate values for debugging purposes, you could do this:</p> <p>\u200b   (\u200bdefn\u200b compute-discount-amount [amount discount-percent min-charge] \u200b     (\u200blet\u200b [discount (* amount discount-percent) \u200b           discounted-amount (- amount discount)] \u200b       (println \u200b\"Discount:\"\u200b discount) \u200b       (println \u200b\"Discounted amount\"\u200b discounted-amount) \u200b       (\u200bif\u200b (&gt; discounted-amount min-charge) \u200b         discounted-amount \u200b         min-charge))) Keep in mind that while all the expressions in the body of a let get evaluated, only the last expression has anything to say about the value returned by the let.</p>"},{"location":"first-steps/name-association/#wrapping-up","title":"Wrapping Up","text":"<p>In this chapter we had a look at the let expression and its friends if-let and when-let. We saw how let and company enable you to bind a name to a value as you compute it, a binding that lasts only as long as you need it. We\u2019ve also seen how you can use let to organize and illuminate long sequences of computing by giving a name to each intermediate value. As usual, we also looked at some of the programming pits that you can fall into when using let\u2014and happily discovered that those pits were both few in number and fairly easy to avoid.</p> <p>Now that you know all about let, it\u2019s time to dig deeper into Clojure\u2019s other naming mechanism, def.</p> <p>FOOTNOTES [14] http://incanter.org</p>"},{"location":"first-steps/projects/","title":"Clojure projects","text":"<p>A Clojure CLI project contains a <code>deps.edn</code> configuration file, containing a hash-map that defines the fundamentals of a project.</p> <p>Create project from template</p> <p>Create a minimal project using the <code>:project/create</code> alias <pre><code>clojure -T:project/create \n</code></pre> Pass <code>:name practicalli/project-name</code> to define a specific name for the project.</p> <p><code>:project/create</code> from  Practicalli Clojure CLI config uses deps-new tool to create a project from a template</p> <p> Practicalli Project Templates creates a project with an effective REPL workflow tools. </p>"},{"location":"first-steps/projects/#anatomy-of-a-project","title":"Anatomy of a project","text":"<p><code>deps.edn</code> a declarative definition of source paths, library dependencies and aliases to support development tools.</p> <p><code>build.clj</code> a programatic approach to building jars and uberjars and related build tasks, using org. clojure/tools.build library .</p> <p><code>resources</code> directory containing EDN configuration files and any other artifacts to ship with the Clojure project, e.g. images, CSS, JavaScript for web services.</p> <p><code>src</code> directory containing a tree of source code, typically including the organisation as the first directory under src, e.g <code>practicalli</code>, <code>org/clojure</code> or <code>io.seancorfield</code></p> <p><code>test</code> directory containing unit test code in a tree that mirrors the <code>src</code> directory structure.</p>"},{"location":"first-steps/projects/#depsedn-structure","title":"deps.edn structure","text":"<p>The <code>deps.edn</code> file is defined by a hash-map, {}, with top-level keys: <code>:paths</code>, <code>:deps</code>, <code>:alias</code>, <code>:mvn/repositories</code>, <code>:mvn/local</code></p> <p><code>:paths</code> location of Clojure source code and Edn configuration, adding locations to the class path.</p> <p><code>:deps</code> library dependencies to build the Clojure project, added to the class path.</p> <p><code>:aliases</code> tools and libraries optionally included during development to support the local workflow (repl &amp; testing tools, data inspectors, reload repl state, etc.)</p> <p><code>:mvn/repositories</code> - URLs for Maven &amp; Clojars repositories included in Clojure CLI by default, mirrors and depenency caches are typically added to the user configuration.</p> <p><code>:mvn/local-repo</code> - set local repository path, default <code>$HOME/.m2/repository</code></p> Migrate from Leiningen <p>Adding a <code>deps.edn</code> file to use Clojure CLI with an existing Leiningen project.  No changes to the source code or test code should be required (unless using a Leinignen plugin that modifys code, e.g lein ring) Leiningen uses the <code>project.clj</code> configuration for projects, a mostly declarative approach.</p> <p>Create a <code>deps.edn</code> configuration that includes the main paths and deps from the <code>project.clj</code> file.</p> <p>Include aliases that support the development workflow</p>"},{"location":"first-steps/projects/#aliases","title":"Aliases","text":"<p>The <code>deps.edn</code> top level <code>:aliases</code> key is associated with a hash-map, <code>{}</code>, containing zero or more alias definitions.</p> <p>An alias definition can use any of the following keys</p> <p><code>:extra-paths</code> to add libraries to the class path, e.g. <code>:paths [\"test\"]</code> to add the <code>test</code> directory</p> <p><code>:extra-deps</code> to add libraries to the class path, using the same form as <code>:deps</code></p> <p><code>:main-opts</code> to pass a vector of string arguments when running code via <code>clojure.main</code></p> <p><code>:exec-fn</code> to specify a fully-qualified function to run via <code>clojure.exec</code></p> <p><code>:exec-opts</code> to pass a hash-map of arguments when running code via <code>clojure.exec</code></p> <p><code>:replace-paths</code> to add only the paths specified to the class path </p> <p><code>:replace-deps</code> to add only the libraries specificed to the class path </p> <pre><code>  :repl/rebel\n  {:extra-deps {nrepl/nrepl                {:mvn/version \"1.0.0\"}\n                cider/cider-nrepl          {:mvn/version \"0.31.0\"}\n                com.bhauman/rebel-readline {:mvn/version \"0.1.4\"}}\n   :main-opts  [\"-e\" \"(apply require clojure.main/repl-requires)\"\n                \"--main\" \"nrepl.cmdline\"\n                \"--middleware\" \"[cider.nrepl/cider-middleware]\"\n                \"--interactive\"\n                \"-f\" \"rebel-readline.main/-main\"]}\n</code></pre> <p>Inside an alias definition, <code>:deps</code> is an alias for <code>replace-deps</code> and <code>:paths</code> is an alias for <code>:replace-paths</code>.  Practicalli recommends using the explicit <code>:replace-*</code> keys to avoid ambiguaty.</p> Aliases provided by Practicalli Clojure CLI Config <p>A wide range of aliases to support development tools and reloaded REPL workflow are provided by  Practicalli Clojure CLI Config</p>"},{"location":"first-steps/projects/#namespace-structure","title":"Namespace structure","text":"<p>Each Clojure file in either <code>src</code> or <code>test</code> should define the namespace name using the <code>ns</code> form. </p> src/practicalli/gameboard/service.clj<pre><code>(ns practicalli.gameboard.service)\n</code></pre> <p>The <code>ns</code> for can also require libraries used by the code within the namespace.  Libraries are added using a short meaningful alias using the <code>:as</code> directive.</p> src/practicalli/gameboard/service.clj<pre><code>(ns practicalli.gameboard.service\n  (:require \n   [com.brunobiachi.mulog :as mulog])\n\n(mulog/set-global-context! \n {:app-name \"Practicalli Gameboard API Service\",\n  :version \"0.1.0\" \n  :env \"dev\"})\n</code></pre> <p>When a namespace requires a library for a specific purpose, then function names can be required directly</p> <p>The purpose of the <code>-test</code> namespaces under the <code>test</code> directory is to run unit tests, so functions from <code>clojure.test</code> can be required directly using the <code>:refer</code> directive.</p> test/practicalli/gameboard/service_test.clj<pre><code>(ns practicalli.gameboard.service-test\n  (:require \n   [clojure.test :refer [deftest is testing]]\n   [practicalli.gameboard.service :as service])\n\n(deftest\n  (testing \"Gameboard API Service startup tests\"),\n    (is (seq? service/running-systemg)))\n</code></pre> <p>Only require using alias or refer specific functions</p> <p>The <code>(:use namespace.name)</code> directive and <code>(:require namespace.name :refer :all)</code> are strongly discouraged as they include the whole library and introduce abiguaty and potential conflict.</p>"},{"location":"games/","title":"Writing Games with Clojure","text":"<p>Games are driven by events and require state to be managed, so are a good way to explore how to manage state with immutable values.</p> <p>For games in Clojure the events are simply function calls and we prefer to pass the state around rather than have a central mutable container for our state.</p> <p>This section will contain several games that have been built using a functional approach with immutable data structures.</p> <ul> <li>TicTacToe on the command line</li> </ul>"},{"location":"games/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Pull requests are welcome</p>"},{"location":"games/#hintgames-in-clojurescript","title":"Hint::Games in ClojureScript","text":"<p>There is a section on games in the Practicalli ClojureScript book, including a TicTacToe game using Reagent (react.js style library) and Scalable Vector Graphics (SVG).</p>"},{"location":"games/tictactoe-cli/","title":"TicTacToe on the command line","text":"<p>Tic-tac-toe is a paper-and-pencil game for two players, X and O, who take turns marking the spaces in a 3\u00d73 grid. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row wins the game</p> <p></p> <p> </p> <p>The code for this section is published on GitHub at: practicalli/tictactoe-cli</p> <p>A TicTacToe game that you run on the command line.  The game takes input from a human player and the program is the second player.</p> <p></p> <p>Output from the game appears in the REPL</p> <pre><code>Current board:\n1 | 2 | 3\n---------\n4 | 5 | 6\n---------\n7 | 8 | 9\nX: Select your move (press a number between 1 and 9 then press enter)\nCurrent board:\nX | 2 | 3\n---------\n4 | 5 | 6\n---------\n7 | 8 | 9\nO: Select your move (press a number between 1 and 9 then press enter)\nCurrent board:\nX | O | 3\n---------\n4 | 5 | 6\n---------\n7 | 8 | 9\nX: Select your move (press a number between 1 and 9 then press enter)\nCurrent board:\nX | O | X\n---------\n4 | 5 | 6\n---------\n7 | 8 | 9\nO: Select your move (press a number between 1 and 9 then press enter)\nCurrent board:\nX | O | X\n---------\nO | 5 | 6\n---------\n7 | 8 | 9\nX: Select your move (press a number between 1 and 9 then press enter)\nCurrent board:\nX | O | X\n---------\nO | X | 6\n---------\n7 | 8 | 9\nO: Select your move (press a number between 1 and 9 then press enter)\nCurrent board:\nX | O | X\n---------\nO | X | O\n---------\n7 | 8 | 9\nX: Select your move (press a number between 1 and 9 then press enter)\nCurrent board:\nX | O | X\n---------\nO | X | O\n---------\nX | 8 | 9\nPlayer  X  wins!\n</code></pre>"},{"location":"games/tictactoe-cli/#references","title":"References","text":"<ul> <li>TicTacToe game created by Brian Will.</li> </ul>"},{"location":"games/tictactoe-cli/create-project/","title":"Create a Clojure project","text":"<p>Create a project for our game.</p> <p>{% tabs deps=\"deps.edn projects\", lein=\"Leiningnen projects\" %}</p> <p>{% content \"deps\" %} Create a new project using <code>clj-new</code> alias, found in  Practicalli Clojure CLI Config</p> <pre><code>clojure -M:new practicalli/tictactoe-cli\n</code></pre> <p>Open the project in a Clojure aware editor or run a rebel REPL</p> <pre><code>clojure -M:repl/rebel\n</code></pre> <p>Once the rebel REPL is running, load the project and change to the main namespace</p> <pre><code>(require 'practicalli/tictactoe-cli)\n\n(in-ns 'practicalli/tictactoe-cli)\n</code></pre> <p>{% content \"lein\" %} The default Leiningen template is suitable fine for the project as no additional libraries are used.</p> <pre><code>lein new tictactoe-cli\n</code></pre> <pre><code>git clone https://github.com/practicalli/tictactoe-cli.git\n</code></pre>"},{"location":"games/tictactoe-cli/create-project/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"games/tictactoe-cli/create-project/#hintalternatively-clone-the-github-repository","title":"Hint::Alternatively clone the github repository","text":"<p>You can also clone the tictactoe-cli game from GitHub</p>"},{"location":"games/tictactoe-cli/create-project/#updating-clojure-version-and-licence","title":"Updating Clojure version and licence","text":"<p>In the <code>project.clj</code> file I have updated Clojure to version 1.10.0 and changed the licence to be the more open Creative Commons license.</p> <pre><code>(defproject tictactoe-cli \"0.1.0-SNAPSHOT\"\n  :description \"TicTacToe game played on the command line\"\n  :url \"https://github.com/practicalli/tictactoe-cli\"\n  :license {:name \"Creative Commons Attribution Share-Alike 4.0 International\"\n            :url \"https://creativecommons.org\"}\n  :dependencies [[org.clojure/clojure \"1.10.0\"]])\n</code></pre> <p>I also removed the <code>license</code> file and added a brief description of the project to the <code>README.md</code> file</p> <p>{% endtabs %}</p>"},{"location":"introduction/clojure-community/","title":"Connect with Clojure Community","text":"<p>There are several ways to can get help and advice from the Clojure Community.</p> <ul> <li>ask.clojure.org - official forum with the Clojure maintainers, help shape the development of Clojure</li> <li>Clojurian Slack community - very active community chat for immediate / shot term discussions</li> <li>Clojurians Zulip - active community chat with topic-based threading and full history, strong data science community and archive of most slack channels</li> <li>ClojureVerse - community forum for friendly short to long-term discussions</li> <li>New Clojurians: Ask Anything - simple web based threaded discussions</li> </ul> <p>General website such as redit/clojure are useful ways for the Clojure community to reach out to the more general development community.</p> <p>Hundreds of Clojure related videos are available on Clojure.tv, the London Clojurians community and Practicalli YouTube channels.</p>"},{"location":"introduction/clojure-community/#askclojureorg","title":"ask.clojure.org","text":"<p>An official place to ask questions about Clojure, ClojureScript, ClojureCLR, Clojure contrib libraries and any other Clojure topic.  </p> <p>This forum is used by the Clojure maintainer team and so discussions can shape the direction of Clojure, e.g. resolving problems and adding new features.</p> <p></p> <p>Questions must have one or more of the fixed categories, enabling discussions to be simpler to find and engage with.  Questions can also include tags to further specify the topic</p> <ul> <li><code>problem</code> - problem in the language or library</li> <li><code>request</code> - request for enhancement in the language or library</li> <li><code>jira</code> - a jira ticket has been raised for development, Jira link included in an answer</li> </ul> <p>An account is required to ask questions, using GitHub authentication. Once logged in, click the user name in the upper right corner and add an email address if notifications are required.</p> <p>Account holders may vote on both questions and answers. Votes are used to inform decisions about future releases of Clojure, ClojureScript, libraries, etc.</p> <p>The @AskClojure twitter account tweets new questions posted to the ask.clojure.org forum on its feed, providing another channel to keep track of discussions.</p>"},{"location":"introduction/clojure-community/#clojurians-slack-channels","title":"Clojurians Slack channels","text":"<p>clojurians.net provides a self-service way to sign up to the Clojurians slack community, which contains many channels where you can get help.  The community is very active with a relatively quick response time in the most popular channels, especially #beginners.</p> <p>Discussions are only visible for a few days as the community uses the free Slack plan, there is no way to scroll back through history in Slack once its archived.  A community log of the discussions is provided by the ClojureVerse team and many channels are mirrored by the Clojurians Zulip community.</p> <p>Channels of note include:</p> <ul> <li><code>#beginners</code> - channel for help on most topics to do with Clojure, occasionally re-directed to focused channels</li> <li><code>#announcements</code> - occasional project / library announcements only. Use a threaded reply or jump to specific topic channel for follow-on discussions.</li> <li><code>#news-and-articles</code> - published content related to Clojure development, everything that is not a project/library announcement</li> <li><code>#events</code> taking place around the world, from meetups to conferences and anything in-between</li> <li><code>#jobs</code> <code>#remote-jobs</code> for posting legitimate job vacancies (and their location), with <code>#jobs-discuss</code> for experiences and advice on finding, getting and doing a job with Clojure</li> <li><code>#spacemacs</code> <code>#calva</code> <code>#chlorine</code> - editor specific channel with questions about using those tools, customising and developing features</li> <li><code>#cider</code> <code>#clj-kondo</code> <code>#figwheel-main</code> <code>#kaocha</code> - Clojure tooling discussions (there are many more)</li> <li><code>#clojuredesign-podcast</code> <code>#defnpodcast</code> <code>#practicalli</code> - supporting live and recorded broadcasts</li> <li><code>#admin-announcements</code> - messages from the administrators of the Clojurians Slack channel</li> <li><code>#community-development</code> community growth &amp; support, reporting code of conduct breaches to the administrators</li> </ul> <p>All discussions in Slack are bound by the Clojurians community code of conduct</p> <p>Post only in one specific channel rather than potentially spamming other channels.  If there are valid exceptions, then use a short summary or link to the original post or delete the original post and add it to another channel.</p>"},{"location":"introduction/clojure-community/#clojurians-zulip","title":"Clojurians Zulip","text":"<p>Discussions history is easier to follow in the Clojurians Zulip than in Slack, especially where discussions take place over time, thanks to the Zulip topic-based threading.  Slack does have discussion threading, but this is often not used as conversation don't last in Slack.</p> <p></p> <p>The Clojurians Zulip is very actively used, although not yet quite as busy as Slack.  There is a strong data science community on Zulip and is also used for SciCoj hackathons and other (virtual) events.  It would be great to see more Clojurians using Zulip either via the website or the excellent Zulip app.</p> <p>Discussions in Clojurians Zulip are also available indefinitely, whereas Slack conversations are only visible for a few days.   If a zulipchat bot has been added to a channel in the Clojurians Slack, that channel discussion history is available as a full-text-searchable archive.  To search the history of the #beginners channel, use <code>/</code> to start a search and use the query:</p> <pre><code>stream:slack-archive topic:beginners\n</code></pre> <p>An account is required and authentication is via GitHub, GitLab, Google or username/password.</p>"},{"location":"introduction/clojure-community/#clojureverse","title":"ClojureVerse","text":"<p>A Clojure community forum that is enjoyable to use with a rich user interface (topics, participant icons, etc.).  Responses may not be as immediate as Slack, however, it is far easier to track discussions as they evolve and review past discussions.</p> <p>All the usual forum features are available and direct and private messages can be sent between user accounts.</p> <p></p>"},{"location":"introduction/clojure-community/#community-meetups","title":"Community Meetups","text":"<p> London Clojurians run regular online and in-person events.</p> <p>Code dojo in-person events are an excellent way to practice Clojure and learn from each other.  A challenge is selected at the start of the event and people are organised into small groups (2-4 people).  A show-n-tell at the end is an opportunity to share experiences between the groups.</p> <p>Talks and other presentations are online (Zoom) enabling a wide range of speakers and attendees to be involved.  These events are recorded and shared on the London Clojurians website.</p> History of the London Clojurians <p>London Clojurians was established in 2009 (London, UK) and has grown to over 4,500 members</p> <p> London Clojurians - a relatively brief history</p>"},{"location":"introduction/clojure-community/#clojure-communities","title":"Clojure Communities","text":"<p>A non-exhaustive list of Clojure communities across the world (that Practicalli is aware of).</p> <ul> <li> London Clojurians London, U.K.</li> <li>LatAm Clojure Meetup S\u00e3o Paulo, Brazil</li> <li>Clojure/Oslo Norway</li> <li>Clojadelphia Philadelphia, PA, USA</li> <li>Seajure Seattle, WA, USA</li> <li>Boston Clojure Group Cambridge, MA, USA</li> <li>Bangalore Clojure Group Bangalore, India</li> <li>Los Angeles Clojure Group Los Angeles, CA, USA</li> <li>Clojure Vienna Vienna, Austria</li> <li>Clojure Mid-Cities Southlake, TX, USA</li> <li>Clojure/nyc New York, NY, USA</li> <li>Clojure Toronto Toronto, ON, Canada</li> <li>Clojure Ireland Dublin, Ireland</li> <li>Minnesota Clojure Group Minneapolis, MN, USA</li> <li>Austin Clojure Meetup Austin, TX, USA</li> <li>Atlanta Functional Programming Meetup Atlanta, GA, USA</li> <li>Kiev Clojure Kyiv, Ukraine</li> <li>Helsinki Clojure Meetup Helsinki, Finland</li> <li>clj-melb Melbourne, Australia</li> <li>BeClojure Brussels, Belgium</li> <li>Virtual Clojure Meetup Durham, NC, USA</li> <li>Clojure D\u00fcsseldorf D\u00fcsseldorf, Germany</li> <li>Clojure Berlin Berlin, Germany</li> <li>Dutch Clojure meetup Amsterdam, Netherlands</li> <li>Bay Area Clojure group San Francisco, CA, USA</li> </ul>"},{"location":"introduction/clojure-community/#clojurebridge-communities","title":"ClojureBridge Communities","text":"<p>ClojureBridge events are often run via the local Clojure communities meetup site. </p> <ul> <li>ClojureBridge London</li> <li>ClojureBrdige Bangalore</li> </ul>"},{"location":"introduction/clojure-in-15-minutes/","title":"Clojure Syntax in 15 minutes","text":"<p>A quick tour of the Clojure syntax, which is so terse you can read through this section in around 15 minutes (or less).</p> <p>This overview is expanded throughout the Practicalli Learning Clojure book along with practical examples.</p>"},{"location":"introduction/clojure-in-15-minutes/#comments","title":"Comments","text":"<p><code>;;</code> two semi-colons for a line comment, <code>;</code> single semi-colon to comment the rest of the line</p> <p><code>#_</code> comment reader macro to comment out the next form</p> <p><code>(comment )</code> form to comment all the containing forms</p>"},{"location":"introduction/clojure-in-15-minutes/#clojure-written-in-forms","title":"Clojure written in forms","text":"<p>Clojure is written as \"expressions\", an expressions being a lists of elements (forms) inside parentheses, <code>()</code>, separated by a space character (or multiple spaces / lines).</p> <p>Clojure evaluates the first element in an expression as a function call.  Additional values in the expression are passed as arguments to the called function.</p> <p>Clojure is organised into one or more namespaces. The namespace represents the directory path and file name that contains the code of the particular namespace.</p> <pre><code>;; Define the namespace test\n(ns test.code)  ;; src/test/code.clj\n\n;; Define a longer namespace\n(ns com.company.product-name.component.service)  ;; src/com/company/product_name/component/service.clj\n</code></pre> <p>Kebab-case for Clojure, Snake-case for file_names</p> <p>Lisps use kebab-case, words joined by <code>-</code>, when names are composed of multiple words.</p> <p>File and directory names must use snake_case, words joined by <code>_</code>, as the underlying Java host does not support <code>-</code> dash characters in names.</p>"},{"location":"introduction/clojure-in-15-minutes/#string-manipulation","title":"String manipulation","text":"<p>The <code>str</code> function creates a new string from all the arguments passed</p> <pre><code>(str \"Hello\" \" \" \"World\")\n; =&gt; \"Hello World\"\n</code></pre> <p><code>clojure.string</code> returns string values (other functions my return characters as results)</p>"},{"location":"introduction/clojure-in-15-minutes/#math-truth-prefix-notation","title":"Math, Truth &amp; prefix notation","text":"<p>Functions use prefix notation, so you can do math with multiple values very easily</p> <pre><code>(+ 1 2 3 5 7 9 12) ; =&gt; 40\n(- 24 7 3) ; =&gt; 14\n(* 1 2) ; =&gt; 2\n(/ 27 7) ; =&gt; 22/7\n</code></pre> <p>Math is very precise, no need for operator precedence rules (as there are no operators)</p> <p>Nesting forms defined a very precise calculation</p> <pre><code>(+ 1 (- 3 2)) ; = 1 + (3 - 2) =&gt; 2\n</code></pre> <p>Equality is =</p> <pre><code>(= 1 1) ; =&gt; true\n(= 2 1) ; =&gt; false\n</code></pre> <p><code>true</code> and <code>false</code> are Boolean values</p> <p><code>clojure (true? true) ; =&gt; true (not true) ; =&gt; false (not= true false) ; =&gt; true (true? (complement true?)) ; =&gt; false</code></p>"},{"location":"introduction/clojure-in-15-minutes/#types","title":"Types","text":"<p>Clojure is strongly typed, so everything is a type in Clojure.</p> <p>Clojure is dynamically typed, so Clojure infers the type.  A type does not need to be specified in the code, making the code simpler and more concise.</p> <p>As Clojure is a hosted language it uses the type system of its host where relevant.  For example, Clojure uses Java object types for booleans, strings and numbers under the covers.</p> <p>Use <code>class</code> or <code>type</code> functions to inspect the type of some code in Clojure.</p> <pre><code>(class 1) ; Integer literals are java.lang.Long by default\n(class 1.); Float literals are java.lang.Double\n(class \"\"); Strings always double-quoted, and are java.lang.String\n(class false) ; Booleans are java.lang.Boolean\n(class nil); The \"null\" value is called nil\n</code></pre> <p>Vectors and Lists are java classes too!</p> <pre><code>(class [1 2 3]); =&gt; clojure.lang.PersistentVector\n(class '(1 2 3)); =&gt; clojure.lang.PersistentList\n</code></pre>"},{"location":"introduction/clojure-in-15-minutes/#collections-sequences","title":"Collections &amp; Sequences","text":"<p>The most common data collections in Clojure:</p> <ul> <li><code>(1 2 \"three\")</code> or <code>(list 1 2 \"three\")</code> - a list of values read from start to end (sequential access)</li> <li><code>[1 2 \"three\"]</code> or <code>(list 1 2 \"three\")</code> - a vector of values with index (random access)</li> <li><code>{:key \"value\"}</code> or <code>(hash-map :key \"value\")</code> - a hash-map with zero or more key value pairs (associative relation)</li> <li><code>#{1 2 \"three\"}</code> or <code>(set 1 2 \"three\")</code> - a unique set of values</li> </ul> <p>A list <code>()</code> is evaluated as a function call. The first element of the list the name of the function to call and additional values are arguments to the function.</p> <p>The <code>'</code> quote function informs the Clojure reader to treat the list as data only.</p> <pre><code>'(1 2 3)\n</code></pre> <p>Lists and vectors are collections</p> <pre><code>(coll? '(1 2 3)) ; =&gt; true\n(coll? [1 2 3]) ; =&gt; true\n</code></pre> <p>Only lists are sequences</p> <pre><code>(seq? '(1 2 3)) ; =&gt; true\n(seq? [1 2 3]) ; =&gt; false\n</code></pre> <p>Sequences are an interface for logical lists, which can be lazy. \"Lazy\" means that a sequence of valus are not evaluated until accessed.</p> <p>A lazy sequence enables the use of large or even an infinite series, like so:</p> <pre><code> (range) ; =&gt; (0 1 2 3 4 ...) - an infinite series\n(take 4 (range)) ;  (0 1 2 3) - lazyily evaluate range and stop when enough values are taken\n</code></pre> <p>Use cons to add an item to the beginning of a list or vector</p> <pre><code>(cons 4 [1 2 3]) ; =&gt; (4 1 2 3)\n(cons 4 '(1 2 3)) ; =&gt; (4 1 2 3)\n</code></pre> <p>Use conj to add an item relative to the type of collection, to the beginning of a list or the end of a vector</p> <pre><code>(conj [1 2 3] 4) ; =&gt; [1 2 3 4]\n(conj '(1 2 3) 4) ; =&gt; (4 1 2 3)\n</code></pre> <p>Use concat to add lists or vectors together</p> <pre><code>(concat [1 2] '(3 4)) ; =&gt; (1 2 3 4)\n</code></pre> <p>Use filter, map to interact with collections</p> <pre><code>(map inc [1 2 3]) ; =&gt; (2 3 4)\n(filter even? [1 2 3]) ; =&gt; (2)\n</code></pre> <p>Use reduce to reduce them</p> <pre><code>(reduce + [1 2 3 4])\n; = (+ (+ (+ 1 2) 3) 4)\n; =&gt; 10\n</code></pre> <p>Reduce can take an initial-value argument too</p> <pre><code>(reduce conj [] '(3 2 1))\n; =&gt; [3 2 1]\n</code></pre> <p>Equivalent of <code>(conj (conj (conj [] 3) 2) 1)</code></p>"},{"location":"introduction/clojure-in-15-minutes/#functions","title":"Functions","text":"<p>Use <code>fn</code> to create new functions that defines some behaviour. <code>fn</code> is referred to as an anonymous fuction as it has no external name to be referenced by and must be called within a list form.</p> <pre><code>(fn hello [] \"Hello World\") ; =&gt; hello\n</code></pre> <p>Wrap a <code>(fn ,,,)</code> form in parens to call it and return the result</p> <pre><code>((fn hello [] \"Hello World\")) ; =&gt; \"Hello World\"\n</code></pre> <p>Create a reusable function using <code>def</code>, creating a name that is a <code>var</code>.  The function behaviour defined in <code>def</code> can be changed and the expression re-evaluated to use the new behaviour.</p> <pre><code>(defn hello-world []\n  \"Hello World\")\n;; =&gt; \"Hello World\"\n</code></pre> <p>The [] is the list of arguments for the function.</p> <pre><code>(defn hello [name]\n  (str \"Hello \" name))\n(hello \"Steve\") ; =&gt; \"Hello Steve\"\n</code></pre> <p>Clojure supports  multi-variadic functions, allowing one function definition to respond to a function call with different number of arguments</p> <pre><code>(defn hello3\n  ([] \"Hello World\")\n  ([name] (str \"Hello \" name)))\n(hello3 \"Jake\") ; =&gt; \"Hello Jake\"\n(hello3) ; =&gt; \"Hello World\"\n</code></pre> <p>Functions can pack extra arguments up in a seq for you</p> <pre><code>(defn count-args [&amp; args]\n  (str \"You passed \" (count args) \" args: \" args))\n(count-args 1 2 3) ; =&gt; \"You passed 3 args: (1 2 3)\"\n</code></pre> <p>You can mix regular and packed arguments</p> <pre><code>(defn hello-count [name &amp; args]\n  (str \"Hello \" name \", you passed \" (count args) \" extra args\"))\n(hello-count \"Finn\" 1 2 3)\n; =&gt; \"Hello Finn, you passed 3 extra args\"\n</code></pre>"},{"location":"introduction/clojure-in-15-minutes/#hash-map-collections","title":"Hash-map collections","text":"<pre><code>(class {:a 1 :b 2 :c 3}) ; =&gt; clojure.lang.PersistentArrayMap\n</code></pre> <p>Keywords are like strings with some efficiency bonuses</p> <pre><code>(class :a) ; =&gt; clojure.lang.Keyword\n</code></pre> <p>Maps can use any type as a key, but usually keywords are best</p> <pre><code>(def stringmap (hash-map \"a\" 1, \"b\" 2, \"c\" 3))\nstringmap  ; =&gt; {\"a\" 1, \"b\" 2, \"c\" 3}\n\n(def keymap (hash-map :a 1 :b 2 :c 3))\nkeymap ; =&gt; {:a 1, :c 3, :b 2} (order is not guaranteed)\n</code></pre> Commas are whitespace <p>commas are always treated as whitespace and are ignored by the Clojure reader</p> <p>Retrieve a value from a map by calling it as a function</p> <pre><code>(stringmap \"a\") ; =&gt; 1\n(keymap :a) ; =&gt; 1\n</code></pre> <p>Keywords can be used to retrieve their value from a map.  Strings cannot be used.</p> <pre><code>(:b keymap) ; =&gt; 2\n\n(\"a\" stringmap)\n; =&gt; Exception: java.lang.String cannot be cast to clojure.lang.IFn\n</code></pre> <p>Retrieving a non-present value returns nil</p> <pre><code>(stringmap \"d\") ; =&gt; nil\n</code></pre> <p>Use assoc to add new keys to hash-maps</p> <pre><code>(assoc keymap :d 4) ; =&gt; {:a 1, :b 2, :c 3, :d 4}\n</code></pre> <p>But remember, clojure types are immutable!</p> <pre><code>keymap ; =&gt; {:a 1, :b 2, :c 3}\n</code></pre> <p>Use dissoc to remove keys</p> <pre><code>(dissoc keymap :a :b) ; =&gt; {:c 3}\n</code></pre>"},{"location":"introduction/clojure-in-15-minutes/#sets","title":"Sets","text":"<pre><code>(class #{1 2 3}) ; =&gt; clojure.lang.PersistentHashSet\n(set [1 2 3 1 2 3 3 2 1 3 2 1]) ; =&gt; #{1 2 3}\n</code></pre> <p>Add a member with conj</p> <pre><code>(conj #{1 2 3} 4) ; =&gt; #{1 2 3 4}\n</code></pre> <p>Remove one with disj</p> <pre><code>(disj #{1 2 3} 1) ; =&gt; #{2 3}\n````\n\nTest for existence by using the set as a function:\n\n```clojure\n(#{1 2 3} 1) ; =&gt; 1\n(#{1 2 3} 4) ; =&gt; nil\n</code></pre> <p>There are more functions in the clojure.sets namespace.</p>"},{"location":"introduction/clojure-in-15-minutes/#useful-forms","title":"Useful forms","text":"<p>Logic constructs in clojure are just macros, and look like everything else</p> <pre><code>(if false \"a\" \"b\") ; =&gt; \"b\"\n(if false \"a\") ; =&gt; nil\n</code></pre> <p>Use let to create temporary bindings</p> <pre><code>(let [a 1 b 2]\n  (&gt; a b)) ; =&gt; false\n</code></pre> <p>Group statements together with do</p> <pre><code>(do\n  (print \"Hello\")\n  \"World\") ; =&gt; \"World\" (prints \"Hello\")\n</code></pre> <p>Functions have an implicit do</p> <pre><code>(defn print-and-say-hello [name]\n  (print \"Saying hello to \" name)\n  (str \"Hello \" name))\n(print-and-say-hello \"Jeff\") ;=&gt; \"Hello Jeff\" (prints \"Saying hello to Jeff\")\n</code></pre> <p>So does let</p> <pre><code>(let [name \"Urkel\"]\n  (print \"Saying hello to \" name)\n  (str \"Hello \" name)) ; =&gt; \"Hello Urkel\" (prints \"Saying hello to Urkel\")\n</code></pre>"},{"location":"introduction/clojure-in-15-minutes/#namespaces-and-libraries","title":"Namespaces and Libraries","text":"<p>Namespaces are used to organise code into logical groups.  The top of each Clojure file has an <code>ns</code> form that defines the namespace name.  The domain part of the namespace name is typically the organisation or community name (e.g. GitHub user/organisation)</p> <pre><code>(ns domain.namespace-name)\n</code></pre> <p>All Practicalli projects have namespace domains of <code>practicalli</code></p> <pre><code>(ns practicalli.service-name)\n</code></pre> <p><code>require</code> allows code from one namespace to be accessed from another namespace, either from a the same Clojure project or from a library added to the project classpath.</p> <p>The <code>:as</code> directive with <code>require</code> is used to specify an alias name, a short-hand for the full library name</p> <p>Or <code>:refer [function-name var-name]</code> can be used to specify specific functions and data (vars) that are available directly</p> <p>A required directive is typically added to a namespace form</p> <pre><code>(ns practicalli.service-name\n  (require [clojure.set :as set]))\n</code></pre> <p>The functions from clojure.set can be used via the alias name, rather than the fully qualified name, i.e. <code>clojure.set/intersection</code></p> <pre><code>(set/intersection #{1 2 3} #{2 3 4}) ; =&gt; #{2 3}\n(set/difference #{1 2 3} #{2 3 4}) ; =&gt; #{1}\n</code></pre> <p><code>:require</code> directive can be used to include multiple library namespaces</p> <pre><code>(ns test\n  (:require\n    [clojure.string :as string]\n    [clojure.set :as set]))\n</code></pre> <p><code>require</code> can be used by itself, usually within a rich code block</p> <pre><code>(comment\n  (require 'clojure.set :as set))\n</code></pre>"},{"location":"introduction/clojure-in-15-minutes/#java","title":"Java","text":"<p>Java has a huge and useful standard library, so you'll want to learn how to get at it.</p> <p>Use import to load a java package</p> <pre><code>(import java.util.Date)\n</code></pre> <p>Or import from a java package name</p> <pre><code>(ns test\n  (:import\n    java.util.Date\n    java.util.Calendar))\n</code></pre> <p>Use the class name with a \".\" at the end to make a new instance</p> <pre><code>(Date.) ; &lt;a date object&gt;\n</code></pre> <p>Use <code>.</code> to call methods. Or, use the \".method\" shortcut</p> <pre><code>(. (Date.) getTime) ; &lt;a timestamp&gt;\n(.getTime (Date.))  ; exactly the same thing.\n</code></pre> <p>Use / to call static methods</p> <pre><code>(System/currentTimeMillis) ; &lt;a timestamp&gt; (system is always present)\n</code></pre> <p>Use doto to make dealing with (mutable) classes more tolerable</p> <pre><code>(import java.util.Calendar)\n(doto (Calendar/getInstance)\n  (.set 2000 1 1 0 0 0)\n  .getTime) ; =&gt; A Date. set to 2000-01-01 00:00:00\n</code></pre>"},{"location":"introduction/contributing/","title":"Contributing to Practicalli","text":"<p>Practicalli books are written in markdown and use MkDocs to generate the published website via a GitHub workflow.  MkDocs can also run a local server using the <code>make docs</code> target from the <code>Makefile</code></p> <p>By submitting content ideas and corrections you are agreeing they can be used in this book under the Creative Commons Attribution ShareAlike 4.0 International license.  Attribution will be detailed via GitHub contributors.</p> <p>All content and interaction with any persons or systems must be done so with respect and within the Practicalli Code of Conduct.</p>"},{"location":"introduction/contributing/#book-status","title":"Book status","text":""},{"location":"introduction/contributing/#submit-and-issue-or-idea","title":"Submit and issue or idea","text":"<p>If something doesnt seem quite right or something is missing from the book, please raise an issue via the GitHub repository explaining in as much detail as you can.</p> <p>Raising an issue before creating a pull request will save you and the maintainer time.</p>"},{"location":"introduction/contributing/#considering-a-pull-request","title":"Considering a Pull request?","text":"<p>Pull Request Commits must be cryptographically signed</p> <p>All commits contributed to Practicalli must be signed via a legitimate SSH or GPG key to avoid the risk of commit spoofing.</p> <p>Configure commit signing with SSH key - Practicalli Engineering</p> <p>All pull requests must include an entry in CHANGELOG.md or will not be merged.  A changelog entry allows the community to follow the changes to the book.</p> <p>Each pull request will have a number of CI workflows run against the contribution, checking the format of the content and if a changelog entry has been provided.</p> <p>Please keep pull requests small and focused, as they are much quicker to review and easier to accept.  Ideally PR's should be for a specific page or at most a section.</p> <p>A PR with a list of changes across different sections will be closed without merging as these take considerable time to review.</p> <p>Issues such as grammar improvements are typically a sign of a rushed section that requires a rewrite, so a pull request to fix a typeographic error will probably not be merged.  Raise an issue, or post a thread in the  Clojurians Slack #practicall channel</p>"},{"location":"introduction/contributing/#thank-you-to-everyone-that-has-contributed","title":"Thank you to everyone that has contributed","text":"<p>A huge thank you to Rich Hickey and the team at Cognitect for creating and continually guiding the Clojure language.  Special thank you to Alex Miller who has provided excellent advice on working with Clojure and the CLI tooling.</p> <p>The Clojure community has been highly supportive of everyone using Clojure and I'd like to thank everyone for the feedback and contributions.  I would also like to thank everyone that has joined in with the London Clojurins community, ClojureBridgeLondon, Clojurians Slack community, Clojurians Zulip community and Clojureverse community.</p> <p>Thank you to everyone who sponsors the Practicalli websites and videos and for the Clojurists Together sponsorship, it helps me continue the work at a much faster pace.</p> <p>Special thanks to Bruce Durling for getting me into Cloure in the first place.</p> <p></p>"},{"location":"introduction/first-taste-of-clojure/","title":"Clojure Quick Reference","text":"<p>The basic Clojure syntax and a few common functions you should probably learn first.</p> <p>The examples are editable (using an embedded REPL) so feel free to experiment and watch as the return value changes as you change the code.  Reload the page if you want to reset all the code back to the starting point.</p> <p>Install Clojure on your computer if you want to experiment even further.</p> <p>Want to go deeper already?</p> <p>Watch the Clojure language video series by Brian Will for a detailed introduction to key parts of the language.  Or discover Clojure core functions by completing challenges on 4Clojure.org and then watching how Practicalli solved them.</p>"},{"location":"introduction/first-taste-of-clojure/#calling-functions","title":"Calling functions","text":"<p>The first element in a list, <code>()</code>, is a call to a function.  Any other elements are passed to the function as arguments. The examples show how to call functions with multiple arguments.</p> <p>Add values together</p> <pre><code>(+ 1 2 3 4 5)\n</code></pre> <p>Parens rather than precedence order rules</p> <pre><code>(+ 3 (* 2 (- 7 2) 4) (/ 16 4))\n</code></pre> <p>Construct a string from strings and return value of a function</p> <pre><code>(str \"Clojure is \" (- 2021 2007) \" years old\")\n</code></pre> <p>Increment a value</p> <pre><code>(inc 1)\n</code></pre> <p>Increment all values in a collection</p> <pre><code>(map inc [1 2 3 4 5])\n</code></pre> <p>Return odd values from a sequence of values</p> <pre><code>(filter odd? (range 11))\n</code></pre> <p>Prefix notation and parens</p> <p>Hugging code with <code>()</code> is a simple syntax to define the scope of code expressions.  No additional <code>;</code>, <code>,</code> or spaces are required.</p> <p>Treating the first element of a list as a function call is referred to as prefix notation, which greatly simplifies Clojure syntax.  Prefix notation makes mathematical expressions completely deterministic, eliminating the need for operator precedence.</p>"},{"location":"introduction/first-taste-of-clojure/#understanding-functions","title":"Understanding functions","text":"<p><code>clojure.repl/doc</code> function returns the doc-string of the given function. A doc-string should be part of all public function definitions.</p> <p>Clojure editors should provide commands to view doc-strings and the ability to jump to function definitions to view their source code</p> <p>Show the documentation for a function</p> <pre><code>(clojure.repl/doc map)\n</code></pre>"},{"location":"introduction/first-taste-of-clojure/#modeling-data-with-collection-types","title":"Modeling data with Collection types","text":"<p>Clojure has 4 main collection types, all immutable (cannot change once created) and can contain any Clojure types.</p> <p>A list, <code>()</code>, used for calling functions and representing sequences. A linked list for sequential access.</p> <p>Compose a string from strings an a function return value</p> <pre><code>(str \"lists used mainly \" (* 2 2) \" \" :code)\n</code></pre> <p>A vector, <code>[]</code>, used for simple collections of values.  An indexed data structure for random access</p> <p>A vector with different types of values</p> <pre><code>[0 \"indexed\" :array (* 2 2) \"random-access\" 4 :data]\n</code></pre> <p>A map, <code>{}</code>, use for descriptive data collections.  An associative data structure for value lookup by unique keys (also known as a dictionary).</p> <p>A hash-map - key value pairs</p> <pre><code>{:hash-map :associative-collection :pairs {:key \"value\"} :aka \"dictionary\"}\n</code></pre> <p>A set, <code>#{}</code>, contains a unique set of values. Sets can be used to test if a value is contained within a collection</p> <p>A Set of unique values</p> <pre><code>#{1 2 3 4 \"unique\" \"set\" \"of\" \"values\" \"unordered\" (* 3 9)}\n</code></pre> <p>Collections are Persistent data types</p> <p>List, Vector, Hash-map and Set are immutable values and cannot be changed.</p> <p>When a function transforms the contents of a collection, a new structure is returned which shares all the unchanged values from the original collection.</p> <p>The sharing approach is called persistent data types and enables immutable data to be used efficiently.</p>"},{"location":"introduction/first-taste-of-clojure/#using-data-structures","title":"Using data structures","text":"<p>Using the <code>map</code> and <code>inc</code> function, increment all the numbers in a vector</p> <p>Increment all values in a collection</p> <pre><code>(map inc [1 2 3 4 5])\n</code></pre> <p>The above <code>map</code> function is roughly equivalent to the following expression</p> <p>Conjoin all the values together into a sequence</p> <pre><code>(conj [] (inc 1) (inc 2) (inc 3) (inc 4) (inc 5))\n</code></pre> <p>The <code>conj</code> function creates a new sequenct by combining one or more values.</p> <p><code>map</code> <code>reduce</code> <code>filter</code> are common functions for iterating through a collection / sequence of values</p> <p>Multiple a value from each collection in turn</p> <pre><code>(map * [1 3 5 8 13 21] [3 5 8 13 21 34])\n</code></pre> <p>Return all the even values from a collection</p> <pre><code>(filter even? [1 3 5 8 13 21 34])\n</code></pre> <p>Add all the values together in the collection</p> <pre><code>(reduce + [31 28 30 31 30 31])\n</code></pre> <p>Check if a collection contains values</p> <pre><code>(empty? [])\n</code></pre> <p>Many Clojure core functions for collections</p> <p><code>map</code>, <code>reduce</code>, <code>apply</code>, <code>filter</code>, <code>remove</code> are just a few examples of Clojure core functions that work with data structures.</p>"},{"location":"introduction/first-taste-of-clojure/#defining-custom-functions","title":"Defining custom functions","text":"<p>Define a function to calculate the square of a given number</p> <pre><code>(defn square-of\n  \"Calculates the square of a given number\"\n  [number]\n  (* number number))\n\n(square-of 9)\n</code></pre> <p>Function definitions can also be used within other expressions, useful for mapping custom functions over a collection</p> <p>Map an anonymous function over a collection</p> <pre><code>(map (fn [number] (* number number)) [1 2 3 4 5])\n</code></pre>"},{"location":"introduction/first-taste-of-clojure/#defining-local-names","title":"Defining local names","text":"<p>Use the <code>let</code> function as a simple way to experiment with code designs</p> <p>Create local binding to hold the result of each function</p> <pre><code>(let [data (range 24 188)\n      total (reduce + data)\n      values (count data)]\n  (str \"Average value: \" (/ total values)))\n</code></pre> <p>Define local names to remove duplication in function definitions, or to simplify algorithms</p> <p>Define a function and call with a value</p> <pre><code>(defn square-of\n  \"Calculates the square of a given number\"\n  [number]\n  (* number number))\n\n(square-of 9)\n</code></pre>"},{"location":"introduction/first-taste-of-clojure/#defining-names-for-values-vars","title":"Defining names for values (vars)","text":"<p>A name bound to a value can be used to represent that value throughout the code.  Names can be bound to simple values (numbers, strings, etc.), collections or even function calls.</p> <p><code>def</code> binds a name to a value with the scope of the current namespace.  <code>def</code> is useful for data that is passed to multiple functions within a namespace.</p> <p>Evaluating a name will return the value it is bound to.</p> <p>Define a data structure to be shared within the namespace</p> <pre><code>(def public-health-data\n  [{:date \"2020-01-01\" :confirmed-cases 23814 :recovery-percent 15}\n   {:date \"2020-01-02\" :confirmed-cases 24329 :recovery-percent 14}\n   {:date \"2020-01-03\" :confirmed-cases 25057 :recovery-percent 12}])\n\npublic-health-data\n</code></pre> <p>def for shared values, let for locally scoped values</p> <p><code>let</code> function is used to bind names to values locally, such as within a function definition.  Names bound with <code>def</code> have namespace scope so can be used with any code in that namespace.</p>"},{"location":"introduction/first-taste-of-clojure/#iterating-over-collections","title":"Iterating over collections","text":"<p><code>map</code> iterates a function over a collection of values, returning a new collection of values</p> <p>Pass each argument of the sequence to the function</p> <pre><code>(map inc (range 20))\n</code></pre> <p><code>reduce</code> iterates a function over the values of a collection to produce a new result</p> <p>Add all values together in the sequence</p> <pre><code>(reduce + (range 101))\n</code></pre> <p>Reducing functions are function definitions used by the <code>reduce</code> function over a collection</p> <p>Use a reducing function over a collection, with an initial start value</p> <pre><code>(reduce (fn [[numerator denominator] accumulator]\n          [(+ numerator accumulator) (inc denominator)])\n        [0 0]\n        (range 1 20))\n</code></pre> <p>Functions can call themselves to iterate over a collection.  Using a lazy sequence means only the required numbers are generated, ensuring efficiency of operation and making the function usable in many different scenarios.</p> <p>Define a function to calculate a fibonacci sequence</p> <pre><code>(defn fibonacci-sequence\n  [current-number next-number]\n  (lazy-seq\n    (cons current-number\n          (fibonacci-sequence next-number (+ current-number next-number)))))\n\n(take 10 (fibonacci-sequence 0 1))\n</code></pre>"},{"location":"introduction/first-taste-of-clojure/#host-interoperability","title":"Host Interoperability","text":"<p>The REPL in this web page is running inside a JavaScript engine, so JavaScript functions can be used from within ClojureScript code </p> <p>Clojure uses the Java Virtual Machine as its host, so can call all the classes and methods from the Java language.  Libraries can also be imported from any JVM language, e.g. Java, Groovy, Jython, Jruby, etc.</p> <p>Java Host interop - current date</p> <pre><code>(java.time.LocalDate/now)\n</code></pre> <p>ClojureScript is the Clojure language that runs in JavaScript environments, e.g. a browser JavaScript engine, node.js</p> <p>JavaScript Host interop - browser alert popup</p> <pre><code>(js/alert \"I am a pop-up alert\")\n</code></pre> <p>Java libraries in Clojure</p> <p>java.lang library is available in Clojure by default</p>"},{"location":"introduction/first-taste-of-clojure/#next-steps","title":"Next steps","text":"<p>Install Clojure on your computer if you want to experiment even further or keep on reading more about Clojure.</p>"},{"location":"introduction/five-steps-to-clojure/","title":"5 Steps to Clojure","text":""},{"location":"introduction/five-steps-to-clojure/#set-up-your-environment","title":"Set up your environment","text":"<p>Install Clojure and a build tool</p> <p>Setup a Clojure aware editor</p> <ul> <li>Emacs &amp; CIDER - Spacemacs, Doom, Prelude</li> <li>Neovim &amp; Conjure</li> <li>VSCode &amp; Clover or Calva</li> <li>Sublime Text &amp; SublimedClojure</li> </ul>"},{"location":"introduction/five-steps-to-clojure/#learn-the-syntax","title":"Learn the syntax","text":""},{"location":"introduction/five-steps-to-clojure/#practice-the-core-functions","title":"Practice the core functions","text":"<ul> <li>4clojure.org</li> <li>Exercism.io</li> </ul>"},{"location":"introduction/five-steps-to-clojure/#def-defn-let","title":"def / defn / let","text":""},{"location":"introduction/five-steps-to-clojure/#map-reduce-apply","title":"map / reduce / apply","text":""},{"location":"introduction/five-steps-to-clojure/#for-while-loop-recur","title":"for / while / loop / recur","text":""},{"location":"introduction/five-steps-to-clojure/#adopt-functional-programming-practices","title":"Adopt functional programming practices","text":""},{"location":"introduction/five-steps-to-clojure/#learn-the-commonly-used-libraries","title":"Learn the commonly used libraries","text":""},{"location":"introduction/five-steps-to-clojure/#server-side-websites","title":"Server-side websites","text":""},{"location":"introduction/five-steps-to-clojure/#ring-compojure-reitit-hiccup-selma","title":"Ring / Compojure / Reitit / Hiccup | Selma","text":""},{"location":"introduction/five-steps-to-clojure/#react-client-side-single-page-apps","title":"React client-side single page apps","text":""},{"location":"introduction/five-steps-to-clojure/#reactjs-om-next-reagent-re-frame","title":"React.js / Om-next / Reagent / Re-frame","text":""},{"location":"introduction/five-steps-to-clojure/#coreasync","title":"core.async","text":""},{"location":"introduction/five-steps-to-clojure/#full-stack-apps","title":"Full Stack apps","text":""},{"location":"introduction/five-steps-to-clojure/#kit-framework","title":"Kit Framework","text":""},{"location":"introduction/learning-path-wip/","title":"Learning path wip","text":""},{"location":"introduction/learning-path-wip/#learn-more-tools-to-help-you-think-functionally","title":"Learn more tools to help you think functionally","text":"<ul> <li>mostly using immutable values and pure functions</li> <li>functional composition, sequences and transducers</li> <li>atoms for managing mutable state changes (with immutable values)</li> </ul>"},{"location":"introduction/learning-path-wip/#get-a-broader-view-of-clojure-and-learn-some-common-practices","title":"Get a broader view of Clojure and learn some common practices","text":"<p>Start reading a book which is aimed at intermediate</p> <ul> <li>Clojure CookBook</li> </ul> <p>Watch Video's about Clojure on subjects that are relevant to work or projects you want to work on.</p> <ul> <li>ClojureTV on YouTube</li> </ul> <p>Follow tutorials on Clojure, especially those that introduce the amazing libraries available in Clojure</p> <ul> <li>Lambda Island</li> <li>PurelyFunctional.tv</li> <li>Practical.li</li> </ul> <p>Work with some of the most common libraries in Clojure</p> <ul> <li>Ring / Compojure for web development (server side)</li> <li>ClojureScript for web UI or native mobile apps (client side)</li> <li>Reagent - reactjs style single page apps<ul> <li>Reagent deep dive - excellent tutorial</li> </ul> </li> <li>core.async - for asynchronous programming</li> <li>clojure.string - specific functions for string manipulation</li> <li>tools.logging</li> <li>java.jdbc - database access</li> <li>data.zip - manipulating trees of data, e.g. XML</li> </ul>"},{"location":"introduction/learning-path/","title":"Clojure Learning Path","text":"<p>Practicalli recommended approach for learning Clojure programming.</p> <p>A journey into Clojure should start with these foundational aspects</p> <ul> <li>Become comfortable evaluating code in the Clojure REPL</li> <li>Review the fundamental syntax of Clojure (its small and consistent)</li> <li>Configure a REPL connected Editor and create projects to save experiments</li> <li>Start discovering clojure concepts (give context to practical experience)</li> <li>Practice Clojure by solving challenges and discover more about the Clojure Standard Library (hundreds of functions available)</li> <li>Connect to the Clojure community for advice and shared experiences</li> </ul> <p>The foundational aspects are inter-related so a slice through each of them is usually the most effective approach.</p> <p>Build on that foundation by understanding the design approach to effectively create solutions in Clojure</p> <ul> <li>Designing for simplicity</li> <li>Appreciating Immutability</li> <li>Data centric design</li> <li>Common Clojure idioms (patterns)</li> <li>Common libraries</li> </ul>"},{"location":"introduction/learning-path/#clojure-repl","title":"Clojure REPL","text":"<p>Practice writing and evaluating Clojure code using  a simple REPL prompt that also provides help and documentation for standard Clojure functions.</p>"},{"location":"introduction/learning-path/#experience-the-clojure-syntax","title":"Experience the Clojure syntax","text":"<p>Take a quick look at the Syntax of Clojure.  The syntax is very small, so this will take about 15 minutes to 1 hour (dependent on your own experiences with coding).  Don't try to remember all the syntax and functions, they will come through practise.</p> <ul> <li>eg.  Clojure in 15 minutes</li> </ul>"},{"location":"introduction/learning-path/#repl-connected-editor","title":"REPL Connected Editor","text":"<p>Build on the REPL experience by connecting a Clojure aware editor to the Clojure REPL process. </p> <p>A REPL connected Editor provides an effective set of Clojure development tools to evaluate Clojure expressions.</p> <p>Understanding common Clojure project structures (src, tests, namespaces) helps organise code effectively and consistently.</p> <p>Practicalli provides editor install and usage guides for </p> <ul> <li> Emacs using Spacemacs community configuration </li> <li> Neovim using AstroNvim community configuration </li> </ul> <p> Practicalli overview of Clojure Aware Editors </p> <p>Web based Clojure environments</p> <p>Exercism includes a web-based editor for solving its challenges (and challenges can be downloaded locally).</p> <p> repl.it provides web based repl you can share / fork via a GitHub account.</p>"},{"location":"introduction/learning-path/#clojure-concepts","title":"Clojure Concepts","text":"<p>Gain an appreciation that a software system should strive for a simple design is a crucial step to truly understanding Clojure.  </p> <p>Spend an hour watching the author of the Clojure Language,  Rich Hickey, talk about Simple made Easy or read the ( transcript of talk) to emerse in the foundational concepts of Clojure.</p> <p>Review the  Clojure Big Ideas presented by Stuart Halloway and further  video presentations by Rich Hickey.</p> <p> Rich Hickey video lecture series </p>"},{"location":"introduction/learning-path/#practice-practice-practice","title":"Practice Practice Practice","text":"<p>Practice Clojure.  Write lots of small and relatively simple examples in Clojure and experiment with the code in the REPL.  </p> <p>Regular practice helps learn and retain the many of the 700+ functions within the Clojure Standard API</p> <p>Aim to become comfortable in the understanding of:</p> <ul> <li>basic values (strings, numbers, etc) and persistent collections (list, vector, map, set)</li> <li>binding names to values and their scope  (def, defn, let)</li> <li>calling functions, defining functions, arity options for functions</li> <li>Higher order functions and basics of functional composition (map, reduce, filter, etc)</li> <li>Designing with data, Extensible Data Notation (EDN), data manipulation</li> </ul> <p>Activities to help practice Clojure include:</p> <ul> <li>4ever Clojure - aim to complete the first 50 exercises and experiment with various functions from the Clojure standard library (<code>clojure.core</code>).</li> <li>Exercism Clojure Track</li> <li>Code Kata repeat exercises taking different design decisions </li> <li>Small Projects</li> </ul>"},{"location":"introduction/learning-path/#community-help","title":"Community Help","text":"<p>There are many ways to  get help from the Clojure community</p> <p>Often starting to ask questions of the community is an effective way of solving the problem yourself.  Asking specific questions helps the community help you.  Posting the specifics of the solution helps the community grow.</p> <p>Clojurians Slack community is very active and the Clojurians Zulip community is specifically active around data science.</p> In-person Code Dojo events <p>A local Clojure community may run Code Dojo events which are an excellent way to learn and practice with others. e.g. London Clojurians</p> <p>The Clojure dojo is a collaborative way to learn Clojure/ClojureScript through practice. The aim is to learn a little more than before you started.</p> <p>Collectively decide on a challenge to complete and split into small groups (2-4 people).  Discuss and start to solve the challenge by coding the next simplest thing possible.  Spend around 90 minutes in groups and come back together to show what was learned.  The dojo is about sharing lessons learned rather than completing a challenge.</p>"},{"location":"introduction/learning-path/#building-a-frame-of-reference","title":"Building a frame of reference","text":"<p>Find an introductory book that you like which provides lots of example code to help you feel more comfortable with the syntax and more importantly the major concepts of functional programming with Clojure.  Type in the exercises as you read and don't be afraid to play around with code examples</p> <p>Clojure.org Book page has a comprehensive list of commercially available books </p> <p>Freely available books Practicalli recommends:</p> <p> Practicalli Learn Clojure</p> <p> Clojure Cookbook</p> <p> Clojure for the Brave and the True</p> <p>Commercial books Practicalli recommends:</p> <p> Getting Clojure - Russ Olsen</p> <p> Clojure Essential Reference - Renzo Borgatti</p>"},{"location":"introduction/learning-path/#starter-projects","title":"Starter Projects","text":"<p>Work on a relatively small project that is care about enough to invest time on regularly, either several hours over the weekend or a couple of hours over several days in the week.</p> <ul> <li>eg. a tool to help you at work</li> </ul> <p> Practicalli Small Projects </p>"},{"location":"introduction/repl-workflow/","title":"REPL Driven Development","text":"<p>Always be REPL'ing</p> <p>Coding without a REPL feels limiting. The REPL provides fast feedback from code as its crafted, testing assumptions and design choices every step of the journey to a solution  - John Stevenson, Practical.li</p> <p>Clojure is a powerful, fun and highly productive language for developing applications and services.  The clear language design is supported by a powerful development environment known as the REPL (read, evaluate, print, loop).  The REPL gives you instant feedback on what your code does and enables you to test either a single expression or run the whole application (including tests).</p> <p>REPL driven development is the foundation of working with Clojure effectively</p> <p>An effective Clojure workflow begins by running a REPL process.  Clojure expressions are written and evaluated immediately to provide instant feedback. The REPL feedback helps test the assumptions that are driving the design choices.</p> <ul> <li>Read - code is read by the Clojure reader, passing any macros to the macro reader which converts those macros into Clojure code.</li> <li>Evaluate - code is compiled into the host language (e.g. Java bytecode) and executed</li> <li>Print - results of the code are displayed, either in the REPL or as part of the application.</li> <li>Loop - the REPL is a continuous process that evaluates code, either a single expression or the whole application.</li> </ul> <p>Design decisions and valuable data from REPL experiments can be codified as specifications and unit tests</p> <p>Practicalli REPL Reloaded Workflow</p> <p>The principles of REPL driven development are implemented in practice using the Practicalli REPL Reloaded Workflow and supporting tooling.  This workflow uses Portal to inspect all evaluation results and log events, hot-load libraries into the running REPL process and reloads namespaces to support major refactor changes.</p>"},{"location":"introduction/repl-workflow/#evaluating-source-code","title":"Evaluating source code","text":"<p>A REPL connected editor is the primary tool for evaluating Clojure code from source code files, displaying the results inline.</p> <p>Source code is automatically evaluated in its respective namespace, removing the need to change namespaces in the REPL with (<code>in-ns</code>) or use fully qualified names to call functions.</p> <p> </p> Evaluate Clojure in a Terminal UI REPL <p>Entering expressions at the REPL prompt evaluates the expression immediately, returning the result directly underneath  </p>"},{"location":"introduction/repl-workflow/#rich-comment-blocks-living-documentation","title":"Rich Comment blocks - living documentation","text":"<p>The <code>(comment ,,,)</code> function wraps code that is only run directly by the developer using a Clojure aware editor.</p> <p>Expressions in rich comment blocks can represent how to use the functions that make up the namespace API.  For example, starting/restarting the system, updating the database, etc.  Expressions provide examples of calling functions with typical arguments and make a project more accessible and easier to work with.</p> <p>Clojure Rich Comment to manage a service</p> <pre><code>(ns practicalli.gameboard.service)\n\n(defn app-server-start [port] ,,,)\n(defn app-server-start [] ,,,)\n(defn app-server-restart [] ,,,)\n\n(defn -main\n  \"Start the service using system components\"\n  [&amp; options] ,,,)\n\n(comment\n  (-main)\n  (app-server-start 8888)\n  (app-server-stop)\n  (app-server-restart 8888)\n\n  (System/getenv \"PORT\")\n  (def environment (System/getenv))\n  (def system-properties (System/getProperties))\n  ) ; End of rich comment block\n</code></pre> <p>Rich comment blocks are very useful for rapidly iterating over different design decisions by including the same function but with different implementations.  </p> <p>Hide clj-kondo linter warnings for redefined vars (<code>def</code>, <code>defn</code>) when using this approach.</p> <pre><code>;; Rich comment block with redefined vars ignored\n#_{:clj-kondo/ignore [:redefined-var]}\n(comment\n  (defn value-added-tax []\n    ;; algorithm design - first idea)\n\n  (defn value-added-tax []\n    ;; algorithm design - second idea)\n\n  ) ;; End of rich comment block\n</code></pre> <p>The \"Rich\" in the name is an honourary mention to Rich Hickey, the author and benevolent dictator of Clojure design.</p>"},{"location":"introduction/repl-workflow/#design-journal","title":"Design Journal","text":"<p>A journal of design decisions makes the code easier to understand and maintain.  Code examples of design decisions and alternative design discussions are captured, reducing the time spent revisiting those discussions.</p> <p>Journals simplify the developer on-boarding processes as the journey through design decisions are already documented.</p> <p>A Design Journal is usually created in a separate namespace, although it may start as a rich comment at the bottom of a namespace.</p> <p>A journal should cover the following aspects</p> <ul> <li>Relevant expressions use to test assumptions about design options.</li> <li>Examples of design choices not taken and discussions why (saves repeating the same design discussions)</li> <li>Expressions that can be evaluated to explain how a function or parts of a function work</li> </ul> <p>The design journal can be used to create meaningful documentation for the project very easily and should prevent time spent on repeating the same conversations.</p> <p>Example design journal</p> <p>Design journal for TicTacToe game using Reagent, ClojureScript and Scalable Vector Graphics</p>"},{"location":"introduction/repl-workflow/#viewing-data-structures","title":"Viewing data structures","text":"<p>Pretty print shows the structure of results from function calls in a human-friendly form, making it easier for a developer to parse and more likely to notice incorrect results.</p> <p>Tools to view and navigate code</p> <ul> <li> Cider inspector is an effective way to navigate nested data and page through large data sets.</li> <li> Portal Inspector to visualise many kinds of data in many different forms.</li> </ul> <p></p>"},{"location":"introduction/repl-workflow/#code-style-and-idiomatic-clojure","title":"Code Style and idiomatic Clojure","text":"<p>Clojure aware editors should automatically apply formatting that follows the  Clojure Style guide.</p> <p>Live linting with  clj-kondo suggests common idioms and highlights a wide range of syntax errors as code is written, minimizing bugs and therefore speeding up the development process.</p> <p> </p> <p>Clojure LSP is build on top of clj-kondo</p> <p> Clojure LSP uses clj-kondo static analysis to provide a standard set of development tools (format, refactor, auto-complete, syntax highlighting, syntax &amp; idiom warnings, code navigation, etc).</p> <p>Clojure LSP can be used with any Clojure aware editor that provides an LSP client, e.g.  Spacemacs,  Doom Emacs,  Neovim, VSCode.</p> <p>Clojure Style Guide</p> <p>The  Clojure Style guide provides examples of common formatting approaches, although the development team should decide which of these to adopt.  Emacs <code>clojure-mode</code> will automatically format code and so will Clojure LSP (via cljfmt).  These tools are configurable and should be tailored to the teams standard.</p>"},{"location":"introduction/repl-workflow/#data-and-function-specifications","title":"Data and Function specifications","text":"<p> Clojure spec is used to define a contract on incoming and outgoing data, to ensure it is of the correct form.</p> <p>As data structures are identified in REPL experiments, create data specification to validate the keys and value types of that data.</p> <pre><code>;; ---------------------------------------------------\n;; Address specifications\n(spec/def ::house-number string?)\n(spec/def ::street string?)\n(spec/def ::postal-code string?)\n(spec/def ::city string?)\n(spec/def ::country string?)\n(spec/def ::additional string?)\n\n(spec/def ::address   ; Composite data specification\n  (spec/keys\n   :req-un [::street ::postal-code ::city ::country]\n   :opt-un [::house-number ::additional]))\n;; ---------------------------------------------------\n</code></pre> <p>As the public API is designed, specifications for each functions arguments are added to validate the correct data is used when calling those functions.</p> <p> Generative testing provides a far greater scope of test values used incorporated into unit tests. Data uses clojure.spec to randomly generate data for testing on each test run.</p>"},{"location":"introduction/repl-workflow/#test-driven-development-and-repl-driven-development","title":"Test Driven Development and REPL Driven Development","text":"<p>Test Driven Development (TDD) and REPL Driven Development (RDD) complement each other as they both encourage incremental changes and continuous feedback.</p> <p>Test Driven Development fits well with Hammock Time, as good design comes from deep thought</p> <ul> <li>RDD enables rapid design experiments so different approaches can easily and quickly be evaluated .</li> <li>TDD focuses the results of the REPL experiments into design decisions, codified as unit tests.  These tests guide the correctness of specific implementations and provide critical feedback when changes break that design.</li> </ul> <p> Unit tests should support the public API of each namespace in a project to help prevent regressions in the code.  Its far more efficient in terms of thinking time to define unit tests as the design starts to stabilize than as an after thought.</p> <p><code>clojure.test</code> library is part of the Clojure standard library that provides a simple way to start writing unit tests.</p> <p> Clojure spec can also be used for generative testing, providing far greater scope in values used when running unit tests.  Specifications can be defined for values and functions.</p> <p>Clojure has a number of  test runners available.  Kaocha is a test runner that will run unit tests and function specification checks.</p> <p>Automate local test runner</p> <p>Use  kaocha test runner in watch mode to run tests and specification check automatically (when changes are saved) <pre><code>clojure -X:test/watch\n</code></pre></p>"},{"location":"introduction/repl-workflow/#continuous-integration-and-deployment","title":"Continuous Integration and Deployment","text":"<p>Add a  continuous integration service to run tests and builds code on every shared commit.  Spin up testable review deployments when commits pushed to a pull request branch, before pushing commits to the main deployment branch, creating an effective pipeline to gain further feedback.</p> <ul> <li> CircleCI provides a simple to use service that supports Clojure projects.</li> <li> GitHub Workflows and GitHub actions marketplace to quickly build a tailored continuous integration service, e.g. Setup Clojure GitHub Action.</li> <li> GitLab CI</li> </ul> <p></p>"},{"location":"introduction/repl-workflow/#live-coding-with-data-stuart-halloway","title":"Live Coding with Data - Stuart Halloway","text":"<p>There are few novel features of programming languages, but each combination has different properties. The combination of dynamic, hosted, functional and extended Lisp in Clojure gives developers the tools for making effective programs. The ways in which Clojure's unique combination of features can yield a highly effective development process.</p> <p>Over more than a decade we have developed an effective approach to writing code in Clojure whose power comes from composing many of its key features. As different as Clojure programs are from e.g. Java programs, so to can and should be the development experience. You are not in Kansas anymore!</p> <p>This talk presents a demonstration of the leverage you can get when writing programs in Clojure, with examples, based on my experiences as a core developer of Clojure and Datomic.</p> <p> </p>"},{"location":"introduction/study-guide-schedule/","title":"Clojure Study guide","text":"<p>A suggested study guide for those new to functional programming with Clojure.</p>"},{"location":"introduction/study-guide-schedule/#hintmeetamentor-clojure-study-group-3rd-november-2018-onwards","title":"Hint::MeetAMentor Clojure Study Group - 3rd November 2018 onwards","text":"<p>MeetAMentor Community is hosting a Clojure Study group starting 3rd November, using this study guide.  Sign up via the MaM Study Group form.</p> <p>All broadcasts are available via the jr0cket YouTube channel</p>"},{"location":"introduction/study-guide-schedule/#week1-overview-of-clojure","title":"Week1: Overview of Clojure","text":"<p>Briefly discuss what the Clojure programming languages is good for, some example companies using Clojure and give suggestions on how to start learning Clojure.</p> <p>Cover the syntax and a few common functions,</p>"},{"location":"introduction/study-guide-schedule/#homework","title":"Homework","text":"<ul> <li>Simple Clojure exercises from ClojureBridge London workshop</li> <li>Understand the principles behind the design of the Clojure language by watching Simple made Easy by Rich Hickey (the author of Clojure)</li> </ul>"},{"location":"introduction/study-guide-schedule/#week2-repl-driven-development-overview-and-clojurebridge-london-exercise-review","title":"Week2: REPL Driven Development overview and ClojureBridge London exercise review","text":"<p>Discuss REPL Driven Development (my blog post on the topic)</p> <p>Review the ClojureBridge London exercises homework - Github Gist - Repl.it project</p>"},{"location":"introduction/study-guide-schedule/#homework_1","title":"Homework","text":"<ul> <li>4Clojure exercises</li> </ul>"},{"location":"introduction/study-guide-schedule/#week-3-using-the-repl-and-structural-editing","title":"Week 3: Using the REPL and Structural editing","text":""},{"location":"introduction/study-guide-schedule/#part-1-structural-editing","title":"Part 1: Structural Editing","text":"<p>The first part of the video covers Structural Editing for Clojure development and the concept of code as symbolic expressions.  Demonstrating the basic of structural editing using Spacemacs</p> <p>Briefly covers the different editors that give a good Clojure experience. http://practicalli.github.io/clojure/development-tools/</p> <p>Visit http://practicalli.github.io/spacemacs to learn more about Clojure development with Spacemacs (Emacs and CIDER).</p>"},{"location":"introduction/study-guide-schedule/#part-2-4clojure-exercises-1-to-15","title":"Part 2: 4Clojure exercises 1 to 15","text":"<p>At 34.50 onwards we discuss solving the first fifteen challenges of 4Clojure, a website that gives you Clojure code snippets to complete.  Entering the missing code and the website will run the code and tests, showing if you got the answer correct.</p> <p>Solving the first 15 challenges - 34.50 onwards</p>"},{"location":"introduction/study-guide-schedule/#homework_2","title":"Homework","text":"<ul> <li>4Clojure exercises</li> <li>Install a Clojure development environment using these install guides for several Clojure aware editors</li> </ul>"},{"location":"introduction/study-guide-schedule/#clojure-loves-data-a-40-minute-sessions-at-london-java-community-conference","title":"Clojure Loves Data: A 40 minute sessions at London Java Community conference","text":"<p>Live coding session covering the basics of using data structures (collections) in Clojure, mostly focusing on Vectors (arrays) and Maps (hash-map, dictionary). I will also attempt to broadcast live a lightning talk on how to broadcast live (because I like being quite meta some times).</p>"},{"location":"introduction/study-guide-schedule/#week-4-clojure-maps-ascii-code-generator-and-clojure-test","title":"Week 4: Clojure maps, ascii code generator and clojure test","text":"<p>Working with Clojure maps (hash-map) and writing a simple ascii code generator.</p>"},{"location":"introduction/study-guide-schedule/#homework_3","title":"Homework","text":"<ul> <li>Test driven development for the Clacks messages converter.  See 61 minutes onwards for ideas how to create the tests.</li> </ul>"},{"location":"introduction/study-guide-schedule/#week-5-test-driven-development-clacks-messenger","title":"Week 5: Test Driven Development - Clacks messenger","text":"<p>This week we will look at Test Driven Development and Clojure.</p> <p>The <code>clojure.test</code> library is part of Clojure and is the simplest way to start with TDD and Clojure.  We will take a small challenge and solve it by first writing a failing test, then writing some code to make the test pass, then refactor the code if necessary.</p> <p>We will start by creating a new project on the command line with Leiningen, which creates parallel source and test branches.</p> <pre><code>lein new my-project\n</code></pre> <p>Open the source code file from the project (<code>SPC f f</code>) and start the REPL - <code>, '</code> or <code>M-RET</code>.</p> <p>Toggle between source code and test code with <code>SPC p a</code>.  Or open the other in a new window using <code>SPC p f</code>, highlight the filename and use <code>C-c o</code> to open in new window.</p> <p>Run all tests using <code>, t a</code> or <code>M-RET t a</code>.</p> <p>To automate running of tests, toggle cider-auto-test-mode using <code>, T t</code> and then evaluate either source or test buffer using <code>, e b</code> and tests will run for that namespace</p>"},{"location":"introduction/study-guide-schedule/#source-code-examples","title":"Source code examples","text":"<ul> <li>Clacks encoder/decoder TDD style</li> </ul>"},{"location":"introduction/study-guide-schedule/#homework_4","title":"Homework","text":"<ul> <li>Try some of the Advent of Code challenges</li> <li>Solve 4Clojure challenges from #16 onwards</li> </ul>"},{"location":"introduction/study-guide-schedule/#week-6-advent-of-clojure","title":"Week 6: Advent of Clojure","text":"<p>Solving day one of the Advent of Code challenges.  The first part of the problem is solved with a simple <code>reduce</code> function.  The second part we investigate several different approaches, becoming more functional and using higher abstractions in Clojure.</p> <p>If you understand the progression of the solutions, you are a good way on to creating very clean Clojure code at a good level of abstraction.</p>"},{"location":"introduction/study-guide-schedule/#noteadvent-of-code","title":"Note::Advent of Code","text":"<p>jr0cket/advent-of-code-2018 repository contains documented descriptions of the solutions to Advent of Code created so far.</p> <p>Advent of Code is a yearly coding challenge that sets one challenge per day, just like an advent calendar.</p> <p>Tim Pote will be live streaming their solution to the advent of code each day at 12 noon (UTC-5 timezone) on Twitch.</p> <p>Borkdude also has a Github repository where advent of code solutions will be published, with all solutions checked with Clojure spec</p>"},{"location":"introduction/study-guide-schedule/#week-7-simple-website-with-clojurescript-reagent-bootstrap-and-svg","title":"Week 7: Simple website with ClojureScript, reagent, bootstrap and SVG","text":"<p>Creating a very simple front end website with ClojureScript.  ClojureScript is Clojure that runs on JavaScript engines, such at the one in your browser or node.js.  The project included reagent, a react.js style framework for ClojureScript.  The web page is made up of one or more components that are managed by the reagent library, so if there are updates to the components the reagent library will refresh the web page.</p> <p>The project also used Bootstrap as a Cascading Style Sheet library, to help structure the layout of the page and add visual components.  The reagent library also lets us define graphics using markup, creating Scalable Vector graphics.</p> <p>The project was created with the Leiningen figwheel template, to give instant feedback in the web page as we update the code.</p> <pre><code>lein new figwheel simple-website -- --reagent\n</code></pre>"},{"location":"introduction/study-guide-schedule/#week-8-4clojure-challenges-16-to-22","title":"Week 8: 4Clojure challenges 16 to 22","text":"<p>Solving the 4Clojure challenges from 16 to 32.</p>"},{"location":"introduction/study-guide-schedule/#hint4clojure-challenges-up-to-15","title":"Hint::4Clojure challenges up to 15","text":"<p>We solve the first 15 challenges in study group #3 from 34.50 onwards</p> <p>jr0cket/four-clojure repository - discussions of 4Clojure solutions</p>"},{"location":"introduction/study-guide-schedule/#week-9-tic-tac-toe","title":"Week 9: Tic-Tac-Toe","text":"<p>Building a simple command line tic-tac-toe game in Clojure in a very functional style.</p> <p>No frameworks were harmed (or used) in the making of this broadcast </p> <ul> <li>practicalli/tictactoe GitHub repository</li> </ul>"},{"location":"introduction/study-guide-schedule/#hintjoining-the-live-discussion","title":"Hint::Joining the Live discussion","text":"<p>A hangout link will be posted to the MeetAMentor Slack channel and London Clojurians meetup page about 30 minutes before broadcast.</p>"},{"location":"introduction/study-guide-schedule/#additional-concepts-to-cover","title":"Additional concepts to cover","text":"<ul> <li>Understanding how to model the world with immutable data (values)</li> <li>Writing your own (pure) functions</li> <li>using sequences</li> <li>lisp comprehension</li> <li>higher order functions</li> <li>functional composition.</li> </ul> <p>Homework: various small challenges and 4Clojure exercises.</p>"},{"location":"introduction/study-guide-schedule/#resources-for-practising-clojure","title":"Resources for practising Clojure","text":"<ul> <li>4Clojure</li> <li>Exorcism</li> <li>CodeWars</li> </ul> <p>Demonstrate how to use the REPL in Spacemacs and Atom.io with ProtoREPL.  Demonstrating evaluation of code, structural editing, refactoring, etc.</p>"},{"location":"introduction/study-guide-schedule/#hintfinding-your-own-learning-path","title":"Hint::Finding your own learning path","text":"<p>As there are many ways to study, please feel free to carve out your own learning path and share what you found useful if you wish. Learning Clojure section describes important steps you should take on your journy into Clojure.</p>"},{"location":"introduction/who-uses-clojure/","title":"Who uses Clojure","text":"<p>Hundreds of companies actively advertised their Clojure adoption. Given the broad participation in user groups there are many more organizations using Clojure within their technology stack.</p> <p>A quick scan of various job sites shows Clojure positions at companies like Walmart, Facebook, Staples, Consumer Reports, Salesforce, and Amazon. It doesn't get much more mainstream than that.</p>"},{"location":"introduction/who-uses-clojure/#case-studies","title":"Case Studies","text":"<p>JUXT Clojure In is a Clojure consultancy company and has interviewed numerous CTO's and Tech Leads, discussing the advantages of using Clojure to solve business challenges.</p> <p>Clojure.org Community Stories also provides insights into companies using Clojure.</p>"},{"location":"introduction/who-uses-clojure/#interesting-companies","title":"Interesting Companies","text":"<p> Functional Works a recruitment company focused on functional programming jobs and built their job management platform on Clojure and ClojureScript.</p> <p>A diverse set of example companies using Clojure for development.  Many more can be found at Clojure.org Companies list, Clojure.org Community Stories and JUXT Clojure In.</p> Company Type of applications Boeing Boeing 737 MAX - onboard maintenance Puppet Labs DevOps apps &amp; services e.g. trapperkeeper Cisco Malware analysis &amp; threat intelligence platform (expert system with core.logic) Deuche Bank (UK) Processing event streams from Apache Storm Atlassian Collaborative editing platform for all their products Netflix Map-Reduce languages for writing apps for Hadoop / Pig USwitch (UK) Creating meaningful data from multiple sources Daily Mail Online (UK) Publishing pipeline Circle CI (USA) Front-end of CI server in ClojureScript &amp; test suite CitiGroup Financial Trading Student Loans company (UK) Loans management system written in Clojure LinkedIn Powers the LinkedIn social graph Walmart (USA) eReceipts project to process every purchase from 5,000+ stores SwiftKey (UK) Predictive intelligence platform (possibly used with Microsoft Cortana) Roomkey.co.uk Hotel booking system to rival Expedia (with a tiny development team) Funding Circle (UK &amp; USA) Adopting Clojure as their main language (from Ruby, etc) Braintree Payment processing pipeline with Kafka Mastodon C Data centre analysis (Incanta, Storm) Thoughtworks Agile development for Client projects world wide Vero Insurance (AUS) Rebuilt policy management system in Clojure with Thoughworks Meta-X Performance art (Overtone, Quil) Salesforce (USA) Build &amp; deployment with Puppet &amp; Application Routing with nginx-clojure <p>There are many more examples of projects on the HackerNews thread: Ask HN: Who's using Clojure in Production</p>"},{"location":"introduction/who-uses-clojure/#tech-radar","title":"Tech Radar","text":"<p>Clojure is also defined as a technology that can be adopted since 2014, according to the Thoughtworks technology radar.</p> <p></p> <p>JUXT also created its own Clojure specific technology radar as there is such an encompassing ecosystem of libraries and services.</p>"},{"location":"introduction/writing-tips/","title":"Writing tips for MkDocs","text":"<p>Making the docs more engaging using the mkdocs-material theme reference guide</p> Configuring Colors <p>Material for MkDocs - Changing the colors lists the primary and accent colors available.</p> <p>HSL Color Picker for codes to modify the theme style, overriding colors in <code>docs/assets/stylesheets/extra.css</code></p>"},{"location":"introduction/writing-tips/#hypertext-links","title":"Hypertext links","text":"<p>Links open in the same browser window/tab by default.</p> <p>Add <code>{target=_blank}</code> to the end of a link to configure opening in a new tab</p> <pre><code>[link text](url){target=_blank}\n</code></pre>"},{"location":"introduction/writing-tips/#buttons","title":"Buttons","text":"<p>Convert any link into a button by adding <code>{.md-button}</code> class names to end of the markdown for a link, which uses <code>.md-button-primary</code> by default.  Include <code>target=_blank</code> for buttons with links to external sites.</p> <pre><code>[link text](http://practical.li/blog){.md-button target=_blank}\n</code></pre> <p>Or specify a different class</p> <pre><code>[link text](http://practical.li/blog){.md-button .md-button-primary}\n</code></pre> <p>Add an icon to the button</p> <p> Practicalli Issues  Practicalli Books and Blogs  Clojure.org</p> <pre><code>[:fontawesome-brands-github: Practicalli Issues](http://practical.li/blog){ .md-button .md-button-primary }\n[:fontawesome-solid-book-open: Practicalli Books and Blogs](http://practical.li/blog){ .md-button .md-button-primary }\n[:simple-clojure: Clojure.org](http://clojure.org/){ .md-button .md-button-primary }\n</code></pre> <p> Search all supported icons</p>"},{"location":"introduction/writing-tips/#youtube-video","title":"YouTube video","text":"<p>Use an iframe element to include a YouTube video, wrapping in a paragraph tag with center alignment to place the video in a centered horizontal position</p> <pre><code>&lt;p style=\"text-align:center\"&gt;\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rQ802kSaip4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;\n&lt;/p&gt;\n</code></pre> <p>mkdocs material does not have direct support for adding a YouTube video via markdown.</p>"},{"location":"introduction/writing-tips/#admonitions","title":"Admonitions","text":"<p>Supported admonition types</p> <p>Note</p> <p>Use <code>!!!</code> followed by <code>NOTE</code></p> <p>Adding a title</p> <p>Use <code>!!!</code> followed by <code>NOTE</code> and a <code>\"title in double quotes\"</code></p> <p>Shh, no title bar just the text... Use <code>!!!</code> followed by <code>NOTE</code> and a <code>\"\"</code> empty double quotes</p> <p>Abstract</p> <p>Use <code>!!!</code> followed by <code>ABSTRACT</code></p> <p>Info</p> <p>Use <code>!!!</code> followed by <code>INFO</code></p> <p>Tip</p> <p>Use <code>!!!</code> followed by <code>TIP</code></p> <p>Success</p> <p>Use <code>!!!</code> followed by <code>SUCCESS</code></p> <p>Question</p> <p>Use <code>!!!</code> followed by <code>QUESTION</code></p> <p>Warning</p> <p>Use <code>!!!</code> followed by <code>WARNING</code></p> <p>Failure</p> <p>Use <code>!!!</code> followed by <code>FAILURE</code></p> <p>Danger</p> <p>Use <code>!!!</code> followed by <code>DANGER</code></p> <p>Bug</p> <p>Use <code>!!!</code> followed by <code>BUG</code></p> <p>Example</p> <p>Use <code>!!!</code> followed by <code>EXAMPLE</code></p> <p>Quote</p> <p>Use <code>!!!</code> followed by <code>QUOTE</code></p>"},{"location":"introduction/writing-tips/#collapsing-admonitions","title":"Collapsing admonitions","text":"Note <p>Collapse those admonitions using <code>???</code> instead of <code>!!!</code></p> Replace with a title <p>Use <code>???</code> followed by <code>NOTE</code> and a <code>\"title in double quotes\"</code></p> Expanded by default <p>Use <code>???+</code>, note the <code>+</code> character,  followed by <code>NOTE</code> and a <code>\"title in double quotes\"</code></p>"},{"location":"introduction/writing-tips/#custom-admonitions","title":"Custom admonitions","text":"<p>Clojure-idiom</p> <p>Use <code>!!!</code> or <code>???</code> followed by <code>CLOJURE-IDIOM</code> and an optional \"title\" in double quotes</p>"},{"location":"introduction/writing-tips/#inline-admonition","title":"Inline admonition","text":"<p>Inline admonitions to make a specific callout within a paragraph of text</p> <p>Info</p> <p>Use <code>!!! INFO INLINE</code> to create an inline admonition on the left-hand side of a paragraph of text.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. </p> <p>Adding something to then end of text is the preffered choice by Practicalli books as it seems to avoid interupting the flow of the main text</p> <p>Info</p> <p>Use <code>!!! INFO INLINE END</code> to create an inline admonition on the right-hand side </p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. </p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"introduction/writing-tips/#code-blocks","title":"Code blocks","text":"<p>Three backtics followed by an optional language name define the start of a code block.  Three backtic characters end the code block.</p> <p>Code blocks include a copy icon automatically</p> <p>Syntax highlighting in code blocks</p> <pre><code>(defn my-function  ; Write a simple function\n  \"With a lovely doc-string\"\n  [arguments]\n  (map inc [1 2 3]))\n</code></pre> Code block with clojure language <pre><code>    ```clojure\n    (defn my-function  ; Write a simple function\n      \"With a lovely doc-string\"\n      [arguments]\n      (map inc [1 2 3]))\n    ```\n</code></pre> <p>Give the code block a title using <code>title=\"\"</code> after the backtics and language name</p> src/practicalli/gameboard.clj<pre><code>(defn my-function\n  \"With a lovely doc-string\"\n  [arguments]\n  (map inc [1 2 3]))\n</code></pre> <p><code>linenums</code> adds line numbers to the code block to help refer to a specific line.  </p> <p><code>linenums=\"42\"</code> also sets the starting point of the line numbers</p> src/practicalli/gameboard.clj<pre><code>(defn my-function\n  \"With a lovely doc-string\"\n  [arguments]\n  (map inc [1 2 3]))\n</code></pre> Code block with clojure language, line numbers and title <pre><code>    ```clojure linenums=\"42\" title=\"src/practicalli/gameboard.clj\"\n    (defn my-function\n      \"With a lovely doc-string\"\n      [arguments]\n      (map inc [1 2 3]))\n    ```\n</code></pre>"},{"location":"introduction/writing-tips/#annotations","title":"Annotations","text":"<p>Annotations in a code block help to highlight important aspects.  Use the comment character for the language followed by a space and a number in brackets</p> <p>For example, in a shell code block, use <code># (1)</code> where 1 is the number of the annotation,  in Clojure use <code>; (1)</code>.</p> <p>Use a number after the code block to add the text for the annotation, e.g. <code>1.</code>. Ensure there is a space between the code block and the annotation text.</p> <pre><code>ls -la $HOME/Downloads  # (1)\n</code></pre> <ol> <li> I'm a code annotation! I can contain <code>code</code>, formatted text, images, anything which can be written in Markdown format.</li> </ol> <p><code>!</code> after the annotation number, e.g. <code>; (1)!</code>, hides the comment character in the annotation display.</p> <pre><code>(defn helper-function\n  \"Doc-string with description of function purpose\" ; (1)!\n  [data]\n  (merge {:fish 1} data)\n  )\n</code></pre> <ol> <li>Always include a doc-string in every function to describe the purpose of that function, identifying why it was added and what its value is.</li> </ol> Code block with annotations <pre><code>    ```clojure\n    (defn helper-function\n      \"Doc-string with description of function purpose\" ; (1)!\n      [data]\n      (merge {:fish 1} data)\n      )\n    ```\n</code></pre> <p>GitHub action example with multiple annotations</p> <pre><code>name: ci # (1)!\non:\n  push:\n    branches:\n      - master # (2)!\n      - main\npermissions:\n  contents: write\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: 3.x\n      - run: pip install mkdocs-material # (3)!\n      - run: mkdocs gh-deploy --force\n</code></pre> <ol> <li> <p>You can change the name to your liking.</p> </li> <li> <p>At some point, GitHub renamed <code>master</code> to <code>main</code>. If your default branch     is named <code>master</code>, you can safely remove <code>main</code>, vice versa.</p> </li> <li> <p>This is the place to install further [MkDocs plugins] or Markdown     extensions with <code>pip</code> to be used during the build:</p> <pre><code>pip install \\\n  mkdocs-material \\\n  mkdocs-awesome-pages-plugin \\\n  ...\n</code></pre> </li> </ol>"},{"location":"introduction/writing-tips/#highlight-lines-in-code-blocks","title":"Highlight lines in code blocks","text":"<p>Add highlight line meta data to a code block after the opening backticks and code block language.</p> <p><code>hl_lines=\"2\"</code> highlights line 2 in the codeblock</p> <pre><code>(defn my-function\n  \"With a lovely doc-string\"\n  [arguments]\n  (map\n   inc\n   [1 2 3]))\n</code></pre>"},{"location":"introduction/writing-tips/#embed-external-files","title":"Embed external files","text":"<p><code>--8&lt;--</code> in a code block inserts code from a source code file or other text file</p> <p>Specify a local file from the root of the book project (the directory containing mkdocs.yml)</p> Scheduled Version Check GitHub Workflow from source code file scheduled version check<pre><code>\n</code></pre> Practicalli Project Templates Emacs project configuration - .dir-locals.el<pre><code>((clojure-mode . ((cider-preferred-build-tool . clojure-cli)\n                  (cider-clojure-cli-aliases . \":test/env:dev/reloaded\"))))\n</code></pre> <p>Code example reuse</p> <p>Use an embedded local or external file (URL) when the same content is required in more than one place in the book.</p> <p>An effective way of sharing code and configuration mutliple times in a book or across multiple books.</p>"},{"location":"introduction/writing-tips/#content-tabs","title":"Content tabs","text":"<p>Create in page tabs that can also be</p> <p>Setting up a project</p> Clojure CLILeiningen <pre><code>clojure -T:project/new :template app :name practicalli/gameboard\n</code></pre> <pre><code>lein new app practicalli/gameboard\n</code></pre> <p>Or nest the content tabs in an admonition</p> <p>Run a terminal REPL</p> Clojure CLILeiningen <pre><code>clojure -T:repl/rebel\n</code></pre> <pre><code>lein repl\n</code></pre>"},{"location":"introduction/writing-tips/#diagrams","title":"Diagrams","text":"<p>Neat flow diagrams</p> <p>Diagrams - Material for MkDocs</p> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre> <p>UML Sequence Diagrams</p> <pre><code>sequenceDiagram\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre> <p>state transition diagrams</p> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre> <p>Class diagrams - not needed for Clojure</p> <p>Entity relationship diagrams are handy though</p> <pre><code>erDiagram\n  CUSTOMER ||--o{ ORDER : places\n  ORDER ||--|{ LINE-ITEM : contains\n  LINE-ITEM {\n    customer-name string\n    unit-price int\n  }\n  CUSTOMER }|..|{ DELIVERY-ADDRESS : uses</code></pre>"},{"location":"introduction/writing-tips/#keyboard-keys","title":"Keyboard keys","text":"<p>Represent key bindings with Keyboard keys. Each number and alphabet character has their own key.</p> <ul> <li>1 <code>++1++</code> for numbers</li> <li>l <code>++\"l\"++</code> for lowercase character</li> <li>U <code>++u++</code> for uppercase character or <code>++\"U\"++</code> for consistency</li> </ul> <p>Punctionation keys use their name</p> <ul> <li>Space <code>++spc++</code></li> <li>, <code>++comma++</code></li> <li>Left <code>++arrow-left++</code></li> </ul> <p>For key sequences, place a space between each keyboard character</p> <ul> <li>Space g s <code>++spc++ ++\"g\"++ ++\"s\"++</code></li> </ul> <p>For key combinations, use join they key identifies with a <code>+</code></p> <ul> <li>Meta+X <code>++meta+x++</code></li> <li>Ctrl+Alt+Del <code>++ctrl+alt+del++</code></li> </ul> <p>MkDocs keyboard keys reference</p>"},{"location":"introduction/writing-tips/#images","title":"Images","text":"<p>Markdown images can be appended with material tags to set the size of the image, whether to appear on light or dark theme and support lazy image loading in browsers</p> SizeLazy LoadingAlignTheme SpecificAll Image Attributes <p><code>{style=\"height:150px;width:150px\"}</code> specifies the image size <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){style=\"height:150px;width:150px\"}\n</code></pre></p> <p></p> <p><code>{loading=lazy}</code> specifies an image should lazily load in the browser <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png){loading=lazy}\n</code></pre></p> <p><code>{aligh=left}</code> or <code>{aligh=right}</code> specifies the page alignment of an image. <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){align=right}\n![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light){align=right}\n</code></pre></p> <p>  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p><code>![Kitty Logo](image/kitty-light.png#only-dark)</code> or <code>![Kitty Logo](image/kitty-light.png#only-light)</code>  specifies the theme the image should be shown, allowing different versions of images to be shown based on the theme. <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){style=\"height:150px;width:150px\"}\n![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light){style=\"height:150px;width:150px\"}\n</code></pre> Use the theme toggle in the top nav bar to see the icon change between light and dark.  </p> <p>Requires the color pallet toggle</p> <p>Alight right, lazy load and set image to 150x150</p> <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){align=right loading=lazy style=\"height:64px;width:64px\"}\n![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light){align=right loading=lazy style=\"height:64px;width:64px\"}\n</code></pre> <p>  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"introduction/writing-tips/#lists","title":"Lists","text":"<p>Task lists</p> <ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> <li> In scelerisque nibh non dolor mollis congue sed et metus</li> <li> Praesent sed risus massa</li> </ul> </li> <li> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li> </ul> <p>Task List example</p> <pre><code>- [x] Lorem ipsum dolor sit amet, consectetur adipiscing elit\n- [ ] Vestibulum convallis sit amet nisi a tincidunt\n    * [x] In hac habitasse platea dictumst\n    * [x] In scelerisque nibh non dolor mollis congue sed et metus\n    * [ ] Praesent sed risus massa\n- [ ] Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque\n</code></pre>"},{"location":"introduction/writing-tips/#tooltips","title":"Tooltips","text":"<p>The humble tool tip</p> <p>Hover me</p> <p>with references</p> <p>Hover me</p> <p>Icon tool tip with a title</p> <p></p>"},{"location":"introduction/writing-tips/#abreviations","title":"Abreviations","text":"<p>The HTML specification is maintained by the W3C.</p> <p>[HTML]: Hyper Text Markup Language [W3C]: World Wide Web Consortium</p>"},{"location":"introduction/writing-tips/#magic-links","title":"Magic links","text":"<p>MagicLink can auto-link HTML, FTP, and email links. It can auto-convert repository links (GitHub, GitLab, and Bitbucket) and display them in a more concise, shorthand format.</p> <p>Email Practicalli</p> <p>Practicalli Neovim</p>"},{"location":"introduction/concepts/","title":"Clojure concepts","text":"<p>Clojure is an elegant language for a more civilized development experience.</p> <p>Clojure supports the creation of simple software systems using immutable values and encouraging a pragmatic approach to pure functional design.</p> <p>A simple syntax means Clojure is quick to learn and a wide range of open source libraries provides a rapid way to build any kind of software. Designed as a hosted language, Clojure runs on many platforms including the Java Virtual Machine, GraalVM, Microsoft.Net, JavaScript engines.  Simple host language interoperability provides access to libraries from a wide range of programming languages, further extending the reach of Clojure.</p> <p>Experiment with the Clojure language to help understand concepts</p> <p>Spend some time eevaluating code in the REPL and then revisit this section to get a deeper understanding of the design and philosophy of the Clojure approach to functional programming.</p> <p>Clojure concepts are easier to relate to whist practicing with Clojure and building Clojure software solutions.</p>"},{"location":"introduction/concepts/#ten-big-ideas-plus-one","title":"Ten Big Ideas plus one","text":"<p>The key to understanding Clojure is ideas, not language constructs but the concepts that shape the language.</p> <p>Each of these ideas is valuable by itself, not only in Clojure. Taken together, however, they Begin to fill in the picture of why Clojure is changing the way many programmers think about software development.</p> <ol> <li>Extensible Data Notation</li> <li>Persistent Data Structures</li> <li>Sequences</li> <li>Transducers</li> <li>Specification</li> <li>Dynamic Development</li> <li>Async Programming</li> <li>Protocols</li> <li>ClojureScript</li> <li>Logic query / Logic Programming</li> <li>Atomic Succession Model</li> </ol> <p>Stuart Halloway presents Clojure in 10 big ideas (plus one) in the following video, also see presentation Content</p> <p> </p> <ul> <li>2013 RuPy slides</li> <li>2017 Chicago JUG slides</li> </ul>"},{"location":"introduction/concepts/#antithesis-of-clojure-and-simple-software-design","title":"Antithesis of Clojure and simple software design","text":"<p>In Narcissistic Design by Stuart Halloway, the antithesis of the Clojure view of software development is presented as a description of how unproductive and valueless much of the software industry has been in the past.</p> <p>Its essentially a guide on what to avoid if you are a responsible and professional software developer.</p> <p> </p>"},{"location":"introduction/concepts/all-bytecode-in-the-end/","title":"Its all Bytecode in the end","text":"<p>The REPL is your compiler</p> <p></p> <p>As soon as you evaluate your code in the REPL it is also being compiled in the background into Java Bytecode.  So there is no need for a separate build and run phase.</p> <p>Injecting code into the running environment provides the means for fast iterative development of code.</p>"},{"location":"introduction/concepts/clojure-from-the-author/","title":"Clojure from the Author","text":"<p>A series of important videos from Rich Hickey, the author of Clojure who spent over 2 years designing core of Clojure around the concept of simplicity.  Since then Rich has stewarded the continued design and development of Clojure, along with the Cognitect team, ensuring Clojure stays true to is founding principles.</p> <p>Try Clojure in the REPL</p> <p>The videos can be watched at any time during the journey into Clojure.  </p> <p>An effective way to learn and become comfortable with Clojure is to write code and evaluate it in the REPL.</p> <p>Presentations by Rich Hickey are an excellent way understand the design philosophy behind Clojure and support adoption of Clojure as a highly effective language for software development.</p>"},{"location":"introduction/concepts/clojure-from-the-author/#expert-to-expert-rich-hickey-and-brian-beckman-inside-clojure","title":"Expert to Expert: Rich Hickey and Brian Beckman - Inside Clojure","text":"<p>Discussing some of the key characteristics of the Clojure language and why those decisions were taken</p> <p> </p>"},{"location":"introduction/concepts/clojure-from-the-author/#clojure-made-simple","title":"Clojure made simple","text":"<p>Covers the major problems with software development and the challenges most programming languages fail to tackle completely.</p> <p>Discusses a simple approach to software development and the big picture view of how Clojure solves these problems</p> <p> </p>"},{"location":"introduction/concepts/clojure-from-the-author/#simplicity-matters","title":"Simplicity Matters","text":"<p>!!! QUOTE Rich Hickey, Clojure Benevolent Dictator for Life     As we move forward we have to take what we already have and make that [software] do more, make it do things differently, make it do things better,  </p> <pre><code>... as we try to take on manipulating software we are ... challenged to understand it in order to make that happen.\n\n... I'll contend that you will completely be dominated by complexity.  I don't care what processes you are using, I don't care how well you test or anything else.\n\nComplexity will dominate what you do.\n</code></pre> <p> </p>"},{"location":"introduction/concepts/clojure-from-the-author/#discussing-design","title":"Discussing Design","text":""},{"location":"introduction/concepts/clojure-from-the-author/#the-value-of-values","title":"The value of values","text":"<p>Rich Hickey provides analysis of the changing way we think about values (not the philosophical kind) in light of the increasing complexity of information technology and the advent of Big Data</p> <p> </p> <p>Also see the related video: Database as a value by Rich Hickey</p> <p> </p>"},{"location":"introduction/concepts/clojure-from-the-author/#understanding-clojure-as-a-programming-language","title":"Understanding Clojure as a programming language","text":""},{"location":"introduction/concepts/design/","title":"Clojure Design","text":"<p>Clojure leads to a very component based approach to development.  There are no huge and bloated frameworks in Clojure.  The core is very small.  Hundreds of focused libraries to use in collaboration.</p> <p>Boiled down to the most simplest structure, Clojure applications you write typically look like this:</p> <pre><code>;; define a namespace\n(ns name-space.name)\n\n;; define one or more immutable data structures - the fewer the better typically\n(def my-data-structure [[{}{}]])\n\n;; define behaviour that acts on data structures inside one or more functions\n(defn my-function [parameter]\n  (my-behaviour parameter))\n\n;; Call those functions to make your application do something\n(my-behaviour data)\n</code></pre> <p>Hint As functions always evaluate to a value, a function can be used as an argument to another function (or itself if you get recursive !!)</p>"},{"location":"introduction/concepts/design/#data-focused-design-maps-vectors","title":"Data focused design - Maps &amp; Vectors","text":"<p>Maps (hash-map) and vectors are two more built-in persistent data structures that are more commonly used to represent data within a Clojure application.</p> <p>A vector is similar to an array in that its an indexed collection and so has fast random access.  Vectors are a catch all data structure that can hold any type of information, including other data structures and function calls.</p> <p>A hash-map is an associative data structure with key value pairs.  The keys are most commonly represented with Clojure keywords, although keys can be strings, numbers, collections or functions so long as all the keys are unique.</p> <p>Hash-maps are a collection of key / value pairs that provide an easy way to reference data by keys.  Its common to use a Clojure <code>keyword</code> type as the keys as keywords are self-referential (they point to themselves).  Using keywords in a map means you can use a specific keyword as a function call on the map that returns its associated value.</p> <p>Some examples of using these data structures this are:</p> <pre><code>;; A map of maps of maps with occasional vectors\n\n{:star-wars {\n    :characters {\n      :jedi   [\"Luke Skywalker\"\n               \"Obiwan Kenobi\"]\n      :sith   [\"Darth Vader\"\n               \"Darth Sideous\"]\n      :droids [\"C3P0\"\n               \"R2D2\"]}\n    :ships {\n      :rebel-alliance  [\"Millennium Falcon\"\n                        \"X-wing fighter\"]\n      :imperial-empire [\"Intergalactic Cruiser\"\n                        \"Destroyer\"\n                        \"Im just making these up now\"]}}}\n</code></pre>"},{"location":"introduction/concepts/design/#hintbasic-design-principle","title":"Hint::Basic design principle","text":"<p>\u201cIt is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.\u201d \u2014Alan Perlis</p>"},{"location":"introduction/concepts/design/#extensibility-via-macros","title":"Extensibility via Macros","text":"<p>You can extend the language and define your own constructs using Macros.</p> <p>The first example of this you see is from Leiningen.  The <code>defproject</code> function is a macro that helps you easily define the configuration of a Clojure project.</p> <p>An example of a macro that is part of the core Clojure language is <code>defn</code>.  When you define a function with <code>defn</code> it is syntactic sugar for defining a thing that is a function.</p> <pre><code>  (defn my-function [argument] (my-behaviour argument) )\n\n  (def my-function\n    (fn [argument] (my-behaviour argument)))\n</code></pre>"},{"location":"introduction/concepts/design/#special-forms-the-building-blocks-of-clojure","title":"Special forms - the building blocks of Clojure","text":"<p>The following are the building blocks of Clojure, everything else is either a macro or a function</p> <p>The Clojure / LISP special forms</p> <pre><code>def, do, if, let, loop, fn, quote, recur, set!, var\n</code></pre> <p>The forms added for Interoperability with the host platform (mainly Java / JVM)</p> <pre><code>monitor-enter, monitor-exit,\ncatch, dot ('.'), finally, new, throw, try\n</code></pre>"},{"location":"introduction/concepts/features/","title":"Features of Clojure","text":""},{"location":"introduction/concepts/features/#dynamic-language","title":"Dynamic language","text":"<p>A problem space can quickly be explored through code to test your assumptions.  The design of code is easy to change as you are not managing type changes, Clojure is very good at managing data that would otherwise lead to exceptions.</p> <p>As a dynamic language the code is quite terse and developers are encouraged to write very modular code, therefore it is easy to refactor.</p>"},{"location":"introduction/concepts/features/#dynamic-development-repl","title":"Dynamic Development - REPL","text":"<p>Clojure has a REPL (Read Evaluate Print Loop), this is the Clojure run-time environment.  You can define functions and data structures, then evaluate them to run either all your code or just a single expression.  You can even change code and re-evaluate it whilst your application is still running and immediately see the effect that change has.</p> <p>So the REPL is a very fast way to explore your problem domain with code</p> <p>You could even connect to the REPL of a live system and change its behaviour without any down time (unless of course you write code that crashes).</p>"},{"location":"introduction/concepts/features/#pure-functional-programming","title":"'Pure' Functional Programming","text":"<p>Functions return a value (even if that value is nil) and you can therefore use a function as an argument to another function.  This is termed as first order functions.</p> <p>Clojure encourages a relatively pure approach to functional programming and Clojure can be considered immutable by default</p>"},{"location":"introduction/concepts/features/#immutability","title":"Immutability","text":"<ul> <li>immutable data structures at its core, everything is immutable by default</li> <li>in imperative programming, we change state where ever we like</li> <li>in functional programming we avoid changing state as much as possible</li> <li>if a function does not change state it is referentially transparent, always returning the same result when given the same input (arguments) - often returned as a pure function</li> <li>impure functions can affect other functions and therefore has to be very mindful of the changes it makes and when it makes them</li> <li>pure functions are truly modular as they do not affect any other part of the system</li> </ul>"},{"location":"introduction/concepts/features/#persistent-data-structures","title":"Persistent Data Structures","text":"<p>List, Map, Vector and Set are all built in data structures that are immutable.</p> <p>If you run a function that seems to change a data structure, its actually returning a new data structure.  Via a shared-memory model, new data structures are created cheaply as they share the common data elements from the original data structure and only include additional elements.</p>"},{"location":"introduction/concepts/features/#homoiconicity","title":"Homoiconicity","text":"<p>One thing that keeps Clojure a small language is the fact that the same syntax is used to represent data and behaviour.  For example, a function call is defined using a list, data structures and functions are defined using a list.  In fact everything is a list, although we use a little syntactic sugar here and there to make the code quicker for a human to parse.</p>"},{"location":"introduction/concepts/features/#clojure-is-an-implementation-of-lisp","title":"Clojure is an implementation of Lisp","text":"<p>Lisp stands for LISt Processing, so its no surprise that all Clojure code is defined in a list.</p> <p>The open Parenthesis <code>(</code> denotes the start of a list, the first element of that list is evaluated as a function call, everything else in the list is data.</p> <p>The evaluation of the first element of a list can be behaviour of <code>(</code> can be over-ridden using <code>quote</code> or its short form the quote character, ', so the list elements are all treated as data.</p>"},{"location":"introduction/concepts/features/#runtime-polymorphism","title":"Runtime Polymorphism","text":"<p>See Clojure arity and multi-methods for more information</p>"},{"location":"introduction/concepts/features/#concurrent-programming-parallelism","title":"Concurrent Programming &amp; Parallelism","text":"<p>Concurrent code is much safer when you data does not change state (eg. immutable values).  Clojure encourages an immutable approach with its built in persistent data structures (list, Map, Vector, Set).  Using Pure Functions that are not affected by or cause side effects also make writing concurrent code trivial.</p> <p>Clojure helps you scale your applications by with a parallel processing approach, as you can run functions over immutable data-structures without conflict.</p>"},{"location":"introduction/concepts/features/#hosted-on-the-jvm","title":"Hosted on the JVM","text":"<p>Clojure is compiled to bytecode that runs on the Java Virtual Machine.  This helps Clojure run at a very high performance (close to Java, C++, etc.)</p> <p>Clojure has a concise and easy to use Java Interoperability, enabling you to use any libraries that run on the JVM (Java, Groovy, Scala, Jruby, Jython, etc).</p> <ul> <li>many parts of the Clojure standard library, Clojure.core defer to the Java Standard library, for example for I/O (reading,writing files)</li> <li>Clojure makes invoking Java very convenient and provides special primitive constructs in the Clojure language to do so (new .javaMethodName javaClassName. etc)</li> </ul> <p>ClojureScript generated JavaScript that will run in a browser.  ClojureCLR will compile to bytecode that runs on the Microsoft .Net platform.</p>"},{"location":"introduction/concepts/features/#managed-state-changes","title":"Managed State Changes","text":"<p>Using <code>atoms</code> or <code>refs</code> in clojure you can have mutable data.  Changes are done safely within Software Transactional Memory (STM), like having an in-memory ACID database managing access</p>"},{"location":"introduction/concepts/features/#extend-the-language-with-macros","title":"Extend the language with Macros","text":"<p>Clojure uses macros</p> <p>Fixme Review the following content to see if its relevant ?</p> <p>** Input &amp; output with functional programming</p> <ul> <li>other fp languages like haskel &amp; Scala use monads to encapsulate data changes whilst appearing stateless to the rest of the program - monads allow us to sneak in impure code into the context of pure code.</li> <li>Clojure doesn't try and enforce functional purity, so any function can include impure code</li> <li>most functions should be pure though or you loose the benefits of functional programming</li> <li>Clojure encourages minimal state changes / mutable state - so its up to the developer to keep the ratio of mutable data small</li> <li> <p>Clojure uses reference types to manage threads and mutable state.  References provide synchronisation of threads without using locks (notoriously cumbersome).  See STM</p> </li> <li> <p>Supporting concurrency</p> </li> <li> <p>atoms etc</p> </li> <li>automatic management of state changes via Software transactional memory - like having an ACID database in memory, managing requests to change values over time.</li> <li> <p>by having immutable data structures - if your values do not change then its trivial to have massive parallelism.</p> </li> <li> <p>A modern LISP</p> </li> <li> <p>leaner syntax and not as many brackets as LISP</p> </li> <li>clean data structure syntax at the core of the language</li> <li>LiSP was the first language to introduce first class functions, garbage collection and dynamic typing, which are common in languages used today</li> </ul> <p>Macros</p> <ul> <li>a function that takes in source code and returns source code, replacing the macro code</li> <li>use macros to take out repetition / boilerplate code</li> <li>as LISP syntax is extremely simple it is much easier to write macros that work compared to non-LISP languages</li> </ul> <p>Clojure emphasizes safety in its type system and approach to parallelism, making it easier to write correct multi-threaded programs.</p> <p>Clojure is very concise, requiring very little code to express complex operations.</p> <p>Data centric design - a well constructed data structure helps define and clarify the purpose of the code</p> <p>Modularity - Clojure and its community build things in modules / components that work together (in a similar design approach to the Unix file system, for example).</p> <p>It offers a REPL and dynamic type system: ideal for beginners to experiment with, and well-suited for manipulating complex data structures.</p> <p>A consistently designed standard library and full-featured set of core data types rounds out the Clojure toolbox.</p> <p>Clojure is close to the speed of Java</p>"},{"location":"introduction/concepts/features/#constraints","title":"Constraints","text":"<p>Clojure relies on the JVM so there can be a longer boot time than a scripting language like Javascript.  However, as you can connect to the Clojure runtime (the REPL) of a live system and because Clojure is dynamic, you can make changes to that live system without any downtime.</p> <p>If you require more performance from Clojure, you can specify ahead of time compilation.</p>"},{"location":"introduction/concepts/functional-reactive-programming/","title":"Functional Reactive Programming","text":"<p>Functional Reactive programming is used in ClojureScript with libraries including reagent, re-frame, rum, etc.</p> <p>Functional Reactive Programming is an elegant means of modeling state over time in an easily composable way. Approaching the problem conceptually and developing a formal semantics first can lead to better optimization potential and simpler implementation.</p> <p>Taking a functional reactive programming approach results in systems that are:</p> <ul> <li>Easier to reason about</li> <li>Simpler to implement</li> <li>Easier to optimize</li> </ul> <p>Functional Reactive Programming (FRP) is a specific formalism of a model of behaviors that change in response to events, created by Conal Elliot. That's a pretty abstract statement, but FRP is abstract itself. It does not denote a particular implementation, but rather a formal semantics. It is not a style of programming or a paradigm. It's simply a formalism.</p> <p>Functional Reactive Programming (and Denotational Design, also by Conal Elliott) has a lot to teach us about how to design functional programs.</p>"},{"location":"introduction/concepts/functional-reactive-programming/#conal-elliott-on-frp-audio-interview","title":"Conal Elliott on FRP Audio Interview","text":"<p>If you're looking for an explanation of the Functional Reactive Programming from the man who invented it, along with an idea of the intriguing process he used to invent it, this HaskellCast episode is for you.</p>"},{"location":"introduction/concepts/functional-reactive-programming/#functional-reactive-animation","title":"Functional Reactive Animation","text":"<p>A great paper from 1997 that spells out an early form of Functional Reactive Programming. It specifies behaviors (functions of time to a value) that change when events occur.</p>"},{"location":"introduction/concepts/functional-reactive-programming/#conal-elliots-home-page","title":"Conal Elliot's home page","text":"<p>Conal Elliot created FRP while he was researching graphics and animation. Be sure to check out his FRP papers section.</p>"},{"location":"introduction/concepts/functional-reactive-programming/#push-pull-functional-reactive-programming","title":"Push-pull functional reactive programming","text":"<p>A more advanced formulation of Functional Reactive Programming that formalizes the types and operations using Haskell's common type classes (Functor, ApplicativeFunctor, Monoid, etc). This one also includes a video of the paper presentation given at ICFP.</p> <p>The main breakthrough of this paper is to model the notion of a future value for events that have not yet happened. But if they have not happened, how can future values be compared? For instance, how does one ask if event a happens before event b if neither of them has happened yet? The paper develops a cool and inspiring formalism which resolves this problem. And one is left with a value that represents the entire behavior of a system past, present, and future.</p>"},{"location":"introduction/concepts/functional-reactive-programming/#elm-thesis-pdf","title":"Elm Thesis - PDF","text":"<p>Elm is a different take on FRP (and it is potentially not FRP, according to some). Instead of behaviors (functions of time to a value), Elm uses discreet signals which are transformed to other signals using functional map-like operations. It also solves a real issue with computationally expensive operations blocking the propagation of signals by making some signals asynchronous.</p> <p>All-in-all, the thesis is a pleasure to read. It is very clear and a decent introduction to the myriad implementations of FRP out there. See the bibliography.</p>"},{"location":"introduction/concepts/misc/","title":"Misc","text":""},{"location":"introduction/concepts/misc/#characteristics","title":"Characteristics","text":"<ul> <li>Dynamic</li> <li>typed - like Python, Ruby or Groovy</li> <li>because its a LISP - you can redefine running code by redefining functions and re-evaluating</li> <li> <p>REPL - a fast way to explore your problem domain with code</p> </li> <li> <p>Functional programming</p> </li> <li>in contrast to imperative programing</li> <li>immutable data structures at its core, everything is immutable by default</li> <li>if any piece of data can be changed, that is mutable state</li> <li>in imperative programming, we change state where ever we like</li> <li>in functional programming we avoid changing state as much as possible</li> <li>if a function does not change state it is referentially transparent, always returning the same result when given the same input (arguments) - often returned as a pure function</li> <li>impure functions can affect other functions and therefore has to be very mindful of the changes it makes and when it makes them</li> <li>pure functions are truly modular as they do not affect any other part of the system ** Changing state</li> <li>rather than changing a data structure, fp instead creates a new data structure that contains the changes and copies of the existing data.</li> <li>to manage the potential overhead of copying data structures, Clojure uses Persistent collections (Lists, Vectors, Maps) which are immutable but provide an efficient way to mutate by sharing common elements (data) ** Input &amp; output with functional programming</li> <li>other fp languages like haskel &amp; Scala use monads to encapsulate data changes whilst appearing stateless to the rest of the program - monads allow us to sneak in impure code into the context of pure code.</li> <li>Clojure doesn't try and enforce functional purity, so any function can include impure code</li> <li>most functions should be pure though or you loose the benefits of functional programming</li> <li>Clojure encourages minimal state changes / mutable state - so its up to the developer to keep the ratio of mutable data small</li> <li> <p>Clojure uses reference types to manage threads and mutable state.  References provide synchronisation of threads without using locks (notoriously cumbersome).  See STM</p> </li> <li> <p>Hosted on the Java Virtual Machine</p> </li> <li>written for the JVM &amp; heavily integrated, giving beautiful integration</li> <li>Clojure is compiled to Java byte code</li> <li>many parts of the Clojure standard library, Clojure.core defer to the Java Standard library, for example for I/O (reading,writing files)</li> <li> <p>Clojure makes invoking Java very convenient and provides special primitive constructs in the Clojure language to do so (new .javaMethodName javaClassName. etc)</p> </li> <li> <p>Supporting concurrency</p> </li> <li>atoms etc</li> <li>automatic management of state changes via Software transactional memory - like having an ACID database in memory, managing requests to change values over time.</li> <li> <p>by having immutable data structures - if your values do not change then its trivial to have massive parallelism.</p> </li> <li> <p>A modern LISP</p> </li> <li>leaner syntax and not as many brackets as LISP</li> <li>clean data structure syntax at the core of the language</li> <li>LiSP was the first language to introduce first class functions, garbage collection and dynamic typing, which are common in languages used today</li> </ul> <p>Macros</p> <ul> <li>a function that takes in source code and returns source code, replacing the macro code</li> <li>use macros to take out repetition / boilerplate code</li> <li>as LISP syntax is extremely simple it is much easier to write macros that work compared to non-LISP languages</li> </ul> <p>fixme assuming you need more, I'll add to this page, but Clojure is a very powerful language, incredibly flexible and tonnes of fun.  What more do you need ?</p> <p>fixme concepts to explore</p> <p>Clojure emphasizes safety in its type system and approach to parallelism, making it easier to write correct multi-threaded programs.</p> <p>Clojure is very concise, requiring very little code to express complex operations.</p> <p>Data centric design - a well constructed data structure helps define and clarify the purpose of the code</p> <p>Modularity - Clojure and its community build things in modules / components that work together (in a similar design approach to the Unix file system, for example).</p> <p>It offers a REPL and dynamic type system: ideal for beginners to experiment with, and well-suited for manipulating complex data structures.</p> <p>A consistently designed standard library and full-featured set of core data types rounds out the Clojure toolbox.</p> <p>Clojure is close to the speed of Java</p>"},{"location":"introduction/concepts/misc/#constraints","title":"Constraints","text":"<p>Clojure relies on the JVM so there can be a longer boot time than a scripting language like Javascript.  However, as you can connect to the Clojure runtime (the REPL) of a live system and because Clojure is dynamic, you can make changes to that live system without any downtime.</p> <p>If you require more performance from Clojure, you can specify ahead of time compilation.</p>"},{"location":"introduction/concepts/naming-local/","title":"Naming - local scope","text":""},{"location":"introduction/concepts/naming-local/#local-names-in-functions","title":"Local names in functions","text":"<p>You can define names for things within the scope of a function using the <code>let</code> function.</p>"},{"location":"introduction/concepts/naming-local/#example","title":"Example","text":"<p>You can use the let function to define a simple expression, for which everything will go out of scope once it has been evaluated</p> <pre><code>(let [local-name \"some value\"])\n(let [minutes-in-a-day (* 60 60 24)])\n</code></pre> <p>You can also use <code>let</code> inside a function to do something with the arguments passed to that function.  Here we calculate the hourly-rate from a yearly salary, returning the calculated-rate.</p> <p>(defn hourly-rate [yearly-salary weeks-in-year days-in-week]   (let [calculated-rate (/ yearly-salary weeks-in-year days-in-week)]     calculated-rate))</p> <p>(hourly-rate 60000 48 5)</p> <pre><code>## Local names in data structures\n\n  When defining a map you are creating a series of key value pairs.  The key is essentially a name that represents the value it is paired with.  Keys are often defined using a `:keyword`.\n\n```clojure\n  {:radius 10, :pi 22/7 :colour purple}\n\n  (def my-circle {:radius 10, :pi 22/7 :colour purple})\n</code></pre> <p>Fixme This is incorrect, as a Clojure keyword type (a name starting with :) have global scope within a namespace.  If the keys were strings, then they would have the scope of just the collection.</p>"},{"location":"introduction/concepts/naming-things/","title":"Naming things - data structures and functions","text":"<p>The <code>def</code> function is used to name data structures in Clojure.</p> <p>You can also use <code>def</code> to name functions, however it is more common to use <code>defn</code> (which is a macro around def) to give a function a name.</p>"},{"location":"introduction/concepts/naming-things/#keeping-things-private","title":"Keeping things private","text":"<p>There is less emphasis on keeping functions and data structures private (compared to Java, C++, C#).  If you want to define a function name so that it is only accessible by other functions of the same namespace, you can use the <code>defn-</code> function.</p> <p>There is no private equivalent for <code>def</code> (as of Clojure 1.6) however you can use metadata to specify this</p> <p>(def ^:private name data)</p> <p>TODO: check if there is anything new around this or other common practices</p>"},{"location":"introduction/concepts/naming-things/#misc-writing-a-private-def-macro","title":"Misc - writing a private def macro","text":"<p>You could write your own macro to create a private <code>def</code> called <code>def-</code></p> <pre><code>(defmacro def- [item value]\n  `(def ^{:private true} ~item ~value)\n)\n</code></pre> <p>There are no naming conventions for a private symbol name.  As its defined an used within the scope of that one namespace (file), then there is no real need to make a special convention.  Private functions will just be called as normal within the namespace and it will be quite clear from the function definition that it is private.</p> <p>Clojure community style guide</p>"},{"location":"introduction/concepts/naming-things/#example","title":"example","text":"<p>Learning Clojure #4: private functions http://tech.puredanger.com/2010/02/09/clojure-4-private-functions/</p> <p>Sometimes in a Clojure file you just want some helper functions that shouldn\u2019t be exposed outside the namespace. You can create a private function using the special defn- macro instead of defn.</p> <p>For instance, create a file foo/bar.clj with a public and a private function:</p> <p>(ns foo.bar) (defn- sq [x] (* x x)) (defn sum-squares [a b] (+ (sq a) (sq b)))</p> <p>Then use it from the REPL:</p> <p>user=&gt; (use 'foo.bar) nil user=&gt; (sum-squares 3 4) 25 user=&gt; (sq 5) java.lang.Exception: Unable to resolve symbol: sq in this context (NO_SOURCE_FILE:6)</p>"},{"location":"introduction/concepts/purpose/","title":"When to use Clojure","text":"<p>Clojure is a general purpose language suitable for any kind of application or service.  As Clojure implementations run across multiple technology platforms and operating systems, there are very few barriers to its use.</p> <p>So Clojure is great for webapps, data science, big data, finance industry (banking, trading, insurance, etc), devops tools (log analysis, etc) and anything else really.</p> <p>There are areas where Clojure obviously excels.</p>"},{"location":"introduction/concepts/purpose/#effective-data-manipulation","title":"Effective Data Manipulation","text":"<p>Fundamentally all software systems take in data (in the form of values or events), process or react to that data and return as a result.</p> <p>The persistent data structures in Clojure (list, vector, hash-map and set) provide an efficient way to use immutable collections of data.</p> <p>The <code>clojure.core</code> library contains a vast number of data processing functions in Clojure so data is easily transformed</p>"},{"location":"introduction/concepts/purpose/#highly-scalable","title":"Highly Scalable","text":"<p>Clojure code is encouraged to be immutable and functions to be pure, you can run millions of parallel instances of your application or service for massive processing power.  These features also vastly simplify concurrent programming.</p>"},{"location":"introduction/concepts/purpose/#reducing-complexity","title":"Reducing Complexity","text":"<p>Clojure encourages a component design through functional composition, breaking down problems into components</p> <p>Clojure and its libraries are all great examples of well designed components and the community strongly encourages this approach.</p>"},{"location":"introduction/concepts/purpose/#hintfunctional-reactive-programming","title":"Hint::Functional Reactive Programming","text":"<p>You can also use ClojureScript for Functional Reactive programming of client-side apps for browsers and mobile device.</p>"},{"location":"introduction/concepts/rationale/","title":"The rationale for Clojure","text":"<p>At the time Clojure was created there were no LISP based languages that ran on a widely adopted platform, that also made concurrency easier for the developer to manage.</p> <p>Developers and the companies that hire them are comfortable with the performance, security and stability of the Java Virtual Machine.</p> <p>While Java developers may envy the succinctness, flexibility and productivity of dynamic languages, they have concerns about running on customer-approved infrastructure, access to their existing code base and libraries, and performance. In addition, they face ongoing problems dealing with concurrency using native threads and locking. Clojure is an effort in pragmatic dynamic language design in this context. It endeavors to be a general-purpose language suitable in those areas where Java is suitable. It reflects the reality that, for the concurrent programming future, pervasive, uncontrolled mutation simply has to go.</p> <p>Clojure meets its goals by: embracing an industry-standard, open platform - the JVM; modernizing a venerable language - Lisp; fostering functional programming with immutable persistent data structures; and providing built-in concurrency support via software transactional memory and asynchronous agents. The result is robust, practical, and fast.</p> <p>Clojure has a distinctive approach to state and identity.</p> <p>Why Clojure?</p>"},{"location":"introduction/concepts/rationale/#motivating-ideas-behind-clojure","title":"Motivating ideas behind Clojure","text":"<p>A LISP base language design is very effecitve</p> <ul> <li> <p>Lambda calculus yields an extremely small core with very little syntax required</p> </li> <li> <p>Core advantage still code-as-data and syntactic abstraction</p> </li> </ul> <p>Standard Lisps (Common Lisp, Scheme) have not evolved over time, since standardisation.  Their core data structures are mutable and not extensible and therefore no mechanisms for effectively dealing with concurrency.</p> <p>Clojure is a Lisp not constrained by backwards compatibility, allowing modernisation of the language that otherwise deters developers from adoption.</p> <p>Clojure extends the code-as-data paradigm to maps and vectors</p> <p>All data structures default to immutability</p> <p>Core data structures are extensible abstractions</p> <p>Embraces a platform (JVM)</p> <p>Functional programming is a good thing</p> <ul> <li>Immutable data + first-class functions</li> <li>Could always be done in Lisp, by discipline/convention</li> </ul> <p>But if a data structure can be mutated, dangerous to presume it won't be In traditional Lisp, only the list data structure is structurally recursive Pure functional languages tend to strongly static types Not for everyone, or every task Clojure is a functional language with a dynamic emphasis All data structures immutable &amp; persistent, supporting recursion Heterogeneous collections, return types Dynamic polymorphism Languages and Platforms VMs, not OSes, are the platforms of the future, providing: Type system Dynamic enforcement and safety Libraries Abstract away OSes Huge set of facilities Built-in and 3rd-party Memory and other resource management GC is platform, not language, facility Bytecode + JIT compilation Abstracts away hardware Language as platform vs. language + platform Old way - each language defines its own runtime GC, bytecode, type system, libraries etc New way (JVM, .Net) Common runtime independent of language Language built for platform vs language ported-to platform Many new languages still take 'Language as platform' approach When ported, have platform-on-platform issues Memory management, type-system, threading issues Library duplication If original language based on C, some extension libraries written in C don't come over Platforms are dictated by clients 'Must run on JVM' or .Net vs 'must run on Unix' or Windows JVM has established track record and trust level Now also open source Interop with other code required C linkage insufficient these days Java/JVM is a language and platform Not the original story, but other languages for JVM always existed, now embraced by Sun Java can be tedious, insufficiently expressive Lack of first-class functions, no type inference, etc Ability to call/consume Java is critical Clojure is the language, JVM the platform Object Orientation is overrated Born of simulation, now used for everything, even when inappropriate Encouraged by Java/C# in all situations, due to their lack of (idiomatic) support for anything else Mutable stateful objects are the new spaghetti code Hard to understand, test, reason about Concurrency disaster Inheritance is not the only way to do polymorphism \"It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.\" - Alan J. Perlis Clojure models its data structures as immutable objects represented by interfaces, and otherwise does not offer its own class system. Many functions defined on few primary data structures (seq, map, vector, set). Write Java in Java, consume and extend Java from Clojure. Polymorphism is a good thing Switch statements, structural matching etc yield brittle systems Polymorphism yields extensible, flexible systems Clojure multi-methods decouple polymorphism from OO and types Supports multiple taxonomies Dispatches via static, dynamic or external properties, metadata, etc Concurrency and the multi-core future Immutability makes much of the problem go away Share freely between threads But changing state a reality for simulations and for in-program proxies to the outside world Locking is too hard to get right over and over again Clojure's software transactional memory and agent systems do the hard part</p> <p>In short, I think Clojure occupies a unique niche as a functional Lisp for the JVM with strong concurrency support. Check out some of the features.</p>"},{"location":"introduction/concepts/what-is-functional-programming/","title":"What is Functional Programming","text":"<p>Functional programming can seem quite different from imperative programming used in languages like C, C++ and Java.</p> <p>Imperative languages may seem easier initially, as defining one step after another is familiar approach to many things in live.  As the scale of a system grows, so does complexity.  Imperative languages applied object oriented design to manage complexity with varied rates of success.</p> <p>When shared mutable state is common in an OO design, then a system quickly becomes complex and very difficult to reason about.</p> <p>Functional programming is actually simpler that the OO approach, although initially it may be unfamiliar and not considered as easy.  As systems grow in complexity, the building blocks are still simple and deterministic, creating a system that is far easier to reason about.</p>"},{"location":"introduction/concepts/what-is-functional-programming/#imperative-programming-languages","title":"Imperative programming languages","text":"<p>In Imperative languages code is written that specifies a sequential of instructions that complete a task.  These instructions typically modifies program state until the desired result is achieved.</p> <p>Variables typically represent memory addresses that are mutable (can be changed) by default.</p> <p></p>"},{"location":"introduction/concepts/what-is-functional-programming/#functional-programming-languages","title":"Functional programming languages","text":"<p>Individual tasks are small and achieved by passing data to a function which returns a result.</p> <p>Functions are composed together to form more complex tasks and satisfy larger business logic.  These composed functions pass the result of their evaluation to the next function, until all functions in the composition have been evaluated.</p> <p>The entire functional program can be thought of as a single function defined in terms of smaller ones.</p> <p>Program execution is an evaluation of expressions, with the nesting structure of function composition determining program flow.</p> <p>Data is immutable and cannot be change once created.  Changes are expressed as new values, with complex values sharing common values for efficiency.</p> <p></p>"},{"location":"kata/","title":"Code Kata: Practising TDD with Clojure","text":""},{"location":"kata/#suggested-kata-exercises","title":"Suggested kata exercises","text":"<ul> <li>String Calculator</li> <li>Bowling Game</li> <li>FizzBuzz</li> <li>Odd Even</li> <li>The Calc Stat</li> <li>The Leap Year</li> <li>The Prime Factor</li> <li>The Recently Used List  (recent song list)</li> <li>The Word Wrap</li> <li>The Natural String Sorting</li> </ul>"},{"location":"puzzles/","title":"Puzzles","text":"<p>Simple puzzles to help you start thinking functionally</p>"},{"location":"puzzles/random-seat-assignment/","title":"Random Seat assignment","text":"<p>https://github.com/practicalli/clojure-practicalli-content/issues/4</p> <p>Take a functional / data oriented approach to solving this problem</p>"},{"location":"puzzles/random-seat-assignment/#description","title":"Description","text":"<p>You want to randomly assign seating to a number of people for a fixed number of seats. Each seat is represented by an integer number between 1 and 30.</p> <p>How do you randomly assign seats without choosing the same seat twice.</p>"},{"location":"puzzles/random-seat-assignment/#loop-recur-approach","title":"Loop / recur approach","text":"<p>Bad...</p>"},{"location":"puzzles/random-seat-assignment/#recursive-function","title":"recursive function","text":""},{"location":"small-projects/","title":"Small Projects","text":"<p>An effective way to get comfortable with Clojure is to start writing small projects.  In this section several small projects are used to walk the audience through how to create and develop a project, as well as learn some Clojure functions and functional programming techniques along the way.</p> Project Topics Description Random Clojure Function namespace vars print a random function from the Clojure standard library Encoding and decoding hash-map dictionaries transforming messages between one form and another Data Transformation transforming larger and larger data sets Test Driven Development and Kata Unit testing Unit testing and solving challenges using different approaches <p>Create a Clojure project</p> <p>Clojure CLI tools and clj-new to create a new Clojure project.</p>"},{"location":"small-projects/generate-web-page/","title":"Generate Web Page","text":"<p>Generate a web page from Clojure code, using Hiccup</p> <p>Generate a full HTML webpage with content.</p> <p>Add a CSS library (bulma.io, bootstrap) to improve generation</p>"},{"location":"small-projects/generate-web-page/#summary","title":"Summary","text":"<p>Generating a web page in Clojure shows how easy it is to structure data and transform that data into other structures.</p> <p>Although this kind of project is easy enough to just do in a REPL directly, using a Clojure aware editor with a Clojure project makes changes to the code far simpler, without loosing any of the immediate feedback of the REPL.</p> <p>Most Clojure developers use the REPL by evaluating code in the editor showing the source code from the project.</p> <p> Practicalli Web Services book shows how to build websites, create self-documented API's, manage Web Application servers and use databases to persist data.</p>"},{"location":"small-projects/random-clojure-function/","title":"Random Clojure Function","text":"<p>A simple application that returns a random function from the <code>clojure.core</code> namespace, along with the function argument list and its description (from the doc-string)</p> <p>There are 659 functions in <code>clojure.core</code> namespace and 955 in the standard library (as of June 2020).  These functions are learned over time as experience is gained with Clojure.</p> Project: Random Clojure function <p> practicalli/random-clojure-function repository contains a Clojure project with an example solution</p>"},{"location":"small-projects/random-clojure-function/#live-coding-video-walk-through","title":"Live Coding Video walk-through","text":"<p>A Live coding video walk-through of this project shows how this application was developed, using Spacemacs editor and CircleCI for continuous integration.</p>  -M flag superseeds -A flag <p>The <code>-M</code> flag replaced the <code>-A</code> flag when running code via <code>clojure.main</code>, e.g. when an alias contains <code>:main-opts</code>.  The <code>-A</code> flag should be used only for the specific case of including an alias when starting the Clojure CLI built-in REPL.</p> <p> </p>"},{"location":"small-projects/random-clojure-function/#create-a-project","title":"Create a project","text":"<p>Use the <code>:project/create</code>  Practicalli Clojure CLI Config to create a new Clojure project.</p> <pre><code>clojure -T:project/create :template app :name practicalli/random-function\n</code></pre> <p>This project has a <code>deps.edn</code> file that includes the aliases</p> <ul> <li><code>:test</code> - includes the <code>test/</code> directory in the class path so unit test code is found</li> <li><code>:runner</code> to run the Cognitect Labs test runner which will find and run all unit tests</li> </ul>"},{"location":"small-projects/random-clojure-function/#repl-experiments","title":"REPL experiments","text":"<p>Open the project in a Clojure-aware editor or start a Rebel terminal UI REPL</p> Clojure EditorRebel REPL <p>Open the <code>src/practicalli/random-function.clj</code> file in a Clojure aware editor and start a REPL process (jack-in)</p> <p>Optionally create a rich comment form that will contain the expressions as the design of the code evolves, moving completed functions out of the comment forms so they can be run by evaluating the whole namespace. <pre><code>(ns practicalli.random-function)\n\n(comment\n  ;; add experimental code here\n)\n</code></pre></p> <p>Open a terminal and change to the root of the Clojure project created, i.e. the directory that contains the <code>deps.edn</code> file.</p> <p>Start a REPL that provides a rich terminal UI <pre><code>clojure -M:repl/reloaded\n</code></pre> <code>require</code> will make a namespace available from within the REPL <pre><code>(require '[practicalli.random-function])\n</code></pre> Change into the <code>random-function</code> namespace to define functions <pre><code>(in-ns 'practicalli.random-function')\n</code></pre> Reload changes made to the <code>src/practicalli/random_function.clj</code> file using the <code>require</code> function with the <code>:reload</code> option.  <code>:reload</code> forces the loading of all the definitions in the namespace file, overriding any functions of the same name in the REPL. <pre><code>(require '[practicalli.random-function] :reload)\n</code></pre></p> <p>Copy finished code into the source code files</p> <p>Assuming the code should be kept after the REPL is closed, save the finished versions of function definitions into the source code files.  Use Up and Down keys at the REPL prompt to navigate the history of expressions</p> <p>List all the public functions in the <code>clojure.core</code> namespace using the <code>ns-publics</code> function</p> <pre><code>(ns-publics 'clojure.core)\n</code></pre> <p>The hash-map keys are function symbols and the values are the function vars</p> <pre><code>{+' #'clojure.core/+',\n decimal? #'clojure.core/decimal?,\n sort-by #'clojure.core/sort-by,\n macroexpand #'clojure.core/macroexpand\n ,,,}\n</code></pre> <p>The <code>meta</code> function will return a hash-map of details about a function, when given a function var.</p> <pre><code>(meta #'map)\n</code></pre> <p>The hash-map has several useful pieces of information for the application, including <code>:name</code>, <code>:doc</code>, and <code>:arglists</code></p> <pre><code>;; =&gt; {:added \"1.0\",\n;;     :ns #namespace[clojure.core],\n;;     :name map,\n;;     :file \"clojure/core.clj\",\n;;     :static true,\n;;     :column 1,\n;;     :line 2727,\n;;     :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 &amp; colls]),\n;;     :doc\n;;     \"Returns a lazy sequence consisting of the result of applying f to\\n  the set of first items of each coll, followed by applying f to the\\n  set of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments. Returns a transducer when\\n  no collection is provided.\"}\n</code></pre> <p>To use the <code>meta</code> function, the values from the <code>ns-publics</code> results should be used.</p> <pre><code>(vals (ns-publics 'clojure.core))\n</code></pre> <p><code>rand-nth</code> will return a random function var from the sequence of function vars</p> <pre><code>(rand-nth (vals (ns-publics 'clojure.core)))\n</code></pre> <p>A single function var is returned, so then the specific meta data can be returned.</p> <pre><code>(meta (rand-nth (vals (ns-publics 'clojure.core))))\n</code></pre>"},{"location":"small-projects/random-clojure-function/#define-a-name-for-all-functions","title":"Define a name for all functions","text":"<p>Edit the <code>src/practicalli/random-function.clj</code> file and define a name for the collection of all public functions from <code>clojure.core</code></p> <pre><code>(def standard-library\n  \"Fully qualified function names from clojure.core\"\n  (vals (ns-publics 'clojure.core)))\n</code></pre>"},{"location":"small-projects/random-clojure-function/#write-unit-tests","title":"Write Unit Tests","text":"<p>From the REPL experiments we have a basic approach for the application design, so codify that design by writing unit tests.  This will also highlight regressions during the course of development.</p> <p>Edit the file <code>test/practicalli/random_function_test.clj</code> and add unit tests.</p> <p>The first test check the standard-library-functions contains entries.</p> <p>The second test checks the -main function returns a string (the function name and details).</p> src/practicalli/random_function_test.clj<pre><code>(ns practicalli.random-function-test\n  (:require [clojure.test :refer [deftest is testing]]\n            [practicalli.random-function :as random-fn]))\n\n(deftest standard-library-test\n  (testing \"Show random function from Clojure standard library\"\n    (is (seq random-fn/standard-library-functions))\n    (is (string? (random-fn/-main)))))\n</code></pre>"},{"location":"small-projects/random-clojure-function/#update-the-main-function","title":"Update the main function","text":"<p>Edit the <code>src/practicalli/random-function.clj</code> file.  Change the <code>-main</code> function to return a string of the function name and description.</p> src/practicalli/random-function.clj<pre><code>(defn -main\n  \"Return a function name from the Clojure Standard library\"\n  [&amp; args]\n  (let [function-details (meta (rand-nth standard-library-functions))]\n    (str (function-details :name) \"\\n  \" (function-details :doc)))\n  )\n</code></pre> Cognitect Test Runner <p>Run the tests with the Congnitect test runner via the <code>test</code> function in the <code>build.clj</code> file. ```bash clojure -T:build test</p> <p>```</p> Kaocha Test Runner <p>Run the tests with the Kaocha test runner using the alias <code>:test/run</code> from Practicalli Clojure CLI config ```bash clojure -M:test/run</p> <p>```</p>"},{"location":"small-projects/random-clojure-function/#running-the-application","title":"Running the application","text":"<p>Use the clojure command with the main namespace of the application.  Clojure will look for the -main function and evaluate it.</p> <pre><code>clojure -M -m practicalli.random-function\n</code></pre> <p>This should return a random function name and its description.  However, nothing is returned.  Time to refactor the code.</p>"},{"location":"small-projects/random-clojure-function/#improving-the-code","title":"Improving the code","text":"<p>The tests pass, however, no output is shown when the application is run.</p> <p>The main function returns a string but nothing is sent to standard out, so running the application does not return anything.</p> <p>The <code>str</code> expression could be wrapped in a println, although that would make the result harder to test and not be very clean code.  Refactor the <code>-main</code> to a specific function seems appropriate.</p> <p>Replace the <code>-main-test</code> with a <code>random-function-test</code> that will be used to test a new function of the same name which will be used for retrieving the random Clojure function.</p> <pre><code>(deftest random-function-test\n  (testing \"Show random function from Clojure standard library\"\n    (is (seq SUT/standard-library-functions))\n    (is (string? (SUT/random-function SUT/standard-library-functions)))))\n</code></pre> <p>Create a new function to return a random function from a given collection of functions, essentially moving the code from <code>-main</code>.</p> <p>The function extracts the function <code>:name</code> and <code>:doc</code> from the metadata of the randomly chosen function.</p> <pre><code>(defn random-function\n  [function-list]\n  (let [function-details (meta (rand-nth function-list))]\n    (str (function-details :name) \"\\n  \" (function-details :doc) \"\\n  \")))\n</code></pre> <p>Update the main function to call this new function.</p> <pre><code>(defn -main\n  \"Return a function name from the Clojure Standard library\"\n  [&amp; args]\n  (println (random-function standard-library-functions)))\n</code></pre> <p>Run the tests again.</p> <p>If the tests pass, then run the application again</p> <pre><code> clojure -M -m practicalli.random-function\n</code></pre> <p>A random function and its description are displayed.</p>"},{"location":"small-projects/random-clojure-function/#adding-the-function-signature","title":"Adding the function signature","text":"<p>Edit the <code>random-function</code> code and add the function signature to the string returned by the application.</p> <p>Format the code so it is in the same structure of the output it produces, making the code clearer to understand.</p> <pre><code>(defn random-function\n  [function-list]\n  (let [function-details (meta (rand-nth function-list))]\n    (str (function-details :name)\n    \"\\n  \" (function-details :doc)\n    \"\\n  \" (function-details :arglists))))\n</code></pre>"},{"location":"small-projects/random-clojure-function/#add-more-namespaces","title":"Add more namespaces","text":"<p>All current namespaces on the classpath can be retrieved using the <code>all-ns</code> function.  This returns a lazy-seq, <code>(type (all-ns))</code></p> <pre><code>(all-ns)\n</code></pre> <p>Using the list of namespace the <code>ns-publics</code> can retrieve all functions across all namespaces.</p> <p>Create a helper function to get the functions from a namespace, as this is going to be used in several places.</p> <pre><code>(defn function-list\n  [namespace]\n  (vals (ns-publics namespace)))\n</code></pre> <p>This function can be mapped over all the namespaces to get a sequence of all function vars.  Using <code>map</code> creates a sequence for each namespace, returned as a sequence of sequences.  Using <code>mapcat</code> will concatenate the nested sequences and return a flat sequence of function vars.</p> <pre><code>(mapcat #(vals (ns-publics %)) (all-ns))\n</code></pre> <p>Bind the results of this expression to the name <code>all-public-functions</code>.</p> <pre><code>(def available-namespaces\n  (mapcat #(vals (ns-publics %)) (all-ns)))\n</code></pre>"},{"location":"small-projects/random-clojure-function/#control-which-namespaces-are-consulted","title":"Control which namespaces are consulted","text":"<p>There is no way to control which library we get the functions from, limiting the ability of our application.</p> <p>Refactor the main namespace to act differently based on arguments passed:</p> <ol> <li> <p>If no arguments are passed then all public functions are used to pull a random function from.</p> </li> <li> <p>If any argument is passed, the argument should be used as the namespace to pull a random function from.  The argument is assumed to be a string.</p> </li> </ol> <p><code>ns-publics</code> function needs a namespace as a symbol, so the <code>symbol</code> function is used to convert the argument.</p> <pre><code>(symbol \"clojure.string\")\n</code></pre> <p>The <code>-main</code> function uses <code>[&amp; args]</code> as a means to take multiple arguments. All arguments are put into a vector, so the symbol function should be mapped over the elements in the vector to create symbols for all the namespaces.</p> <p>Use an anonymous function to convert the arguments to symbols and retrieve the list of public functions from each namespace.  This saves mapping over the arguments twice.</p> <p><code>mapcat</code> the function-list function over all the namespaces, converting each namespace to a symbol.</p> <pre><code>(mapcat #(function-list (symbol %)) args)\n</code></pre> <p>Update the main function with an if statement.  Use <code>seq</code> as the condition to test if a sequence (the argument vector) has any elements (namespaces to use).</p> <p>If there are arguments, then get the functions for the specific namespaces.</p> <p>Else return all the functions from all the namespaces.</p> <pre><code>(defn -main\n  \"Return a function name from the Clojure Standard library\"\n  [&amp; args]\n  (if (seq args)\n    (println (random-function (mapcat #(function-list (symbol %)) args)))\n    (println (random-function standard-library-functions))))\n</code></pre>"},{"location":"small-projects/random-clojure-function/#use-the-fully-qualified-name-for-the-namespace","title":"Use the fully qualified name for the namespace","text":"<p>Now that functions can come from a range of namespaces, the fully qualified namespace should be used for the function, eg. domain/namespace</p> <pre><code>(:ns (meta (rand-nth standard-library-functions)))\n</code></pre> <p>Update the random function to return the domain part of the namespace, separated by a <code>/</code></p> <pre><code>(defn random-function\n  [function-list]\n  (let [function-details (meta (rand-nth function-list))]\n    (str (function-details :ns) \"/\" (function-details :name)\n         \"\\n  \" (function-details :arglists)\n         \"\\n  \" (function-details :doc))))\n</code></pre>"},{"location":"small-projects/random-clojure-function/#use-all-available-namespaces-by-default","title":"Use all available namespaces by default","text":"<p>Define a name to represent the collection of all available namespaces, in the context of the running REPL.</p> <pre><code>(def all-public-functions\n  \"Fully qualified function names from available\"\n  (mapcat #(vals (ns-publics %)) (all-ns)))\n</code></pre> <p>Update the <code>-main</code> function to use all available namespaces if no arguments are passed to the main function.</p> <pre><code>(defn -main\n  \"Return a random function and its details\n  from the available namespaces\"\n  [&amp; args]\n  (if (seq args)\n    (println (random-function (mapcat #(function-list (symbol %)) args)))\n    (println (random-function all-public-functions))))\n</code></pre>"},{"location":"small-projects/random-clojure-function/#follow-on-idea-convert-to-a-web-service","title":"Follow-on idea: Convert to a web service","text":"<p>Add http-kit server and send  information back as a plain text, html, json and edn</p>"},{"location":"small-projects/random-clojure-function/#follow-on-idea-convert-to-a-library","title":"Follow-on idea: Convert to a library","text":"<p>Convert the project to a library so this feature can be used as a development tool for any project.</p> <p>Add functionality to list all functions from all namespaces or a specific namespace, or functions from all namespaces of a particular domain, e.g <code>practicalli</code> or <code>practicalli.app</code></p>"},{"location":"small-projects/split-the-bill/","title":"Split the bill","text":"<p>In a restaurant a group of friends and relatives are having a reunion dinner after a year of not seeing each other.</p> <p>Once the meal comes to an end, its time to pay the bill.  So how would you write code to split the bill?</p> <p>Start with the simplest possible approach, with everyone paying the same.</p>"},{"location":"small-projects/split-the-bill/#create-a-new-clojure-project","title":"Create a new Clojure project","text":"<p> Pracitcalli Clojure CLI Config provides the <code>:project/create</code> alias to create projects using deps-new project.</p> <pre><code>clojure -T:project/create :template app :name practicalli/split-the-bill\n</code></pre> <pre><code>(str \"Create code to calculate the bill, including what each person should pay\")\n</code></pre> <p>Tke a look at the Who am I section for ideas on how to model the bill.  Also look at More Than Average for ideas on how to write code to work out how to pay the bill.</p>"},{"location":"small-projects/split-the-bill/#paying-what-was-ordered","title":"Paying what was ordered","text":"<p>As not everyone had eaten the same amount of food or arrived at the same time, then there was an ask for everyone to pay just what they ordered.</p> <p>So create a collection to capture what each person ordered and create an itemised bill so each person knows what they should pay.</p> <p>Define a detailed bill based on what each person ordered, then create an itemised bill based on each persons order</p> <p>Now it was realised that what everyone ordered is not what everyone ate.  So now we need to take the order and create an itemised bill based on what everyone actually ate (lets suspend believe here a little and assume everyone knows exactly what they ate, and is honest about it).</p> <p>Define a detailed bill based on what each person ordered, then create an itemised bill based on each person actually ate</p>"},{"location":"small-projects/split-the-bill/#spliting-the-bill-with-a-social-group","title":"Spliting the bill with a Social Group","text":"<p>Extend the exercise by splitting bills over multiple events and activities with multiple people.</p>"},{"location":"small-projects/tripple-lock/","title":"Triple Lock","text":"<p>A new safe too keep all the richest you will gain from becoming a Clojure developer (hopefully).  The safe has a 3 combination lock to protect your new found wealth, but just how safe is the safe?</p>"},{"location":"small-projects/tripple-lock/#create-a-new-clojure-project","title":"Create a new Clojure project","text":"<p> Pracitcalli Clojure CLI Config provides the <code>:project/create</code> alias to create projects using deps-new project.</p> <pre><code>clojure -T:project/create :name practicalli/triple-lock\n</code></pre>"},{"location":"small-projects/tripple-lock/#designing-the-combination-lock","title":"Designing the combination lock","text":"<p>Lets consider how we would create such a combination lock in Clojure.</p> <ul> <li>The combination is managed by three tumbler wheels</li> <li>Each tumbler wheel has the same range of numbers on then, 0 to 9</li> </ul> <p>Each tumbler wheel could have all the numbers it contains within a Collection in Clojure.  The simplest approach would be to put the numbers 0 to 9 into a Vector (an array-like collection).</p> <pre><code>[0 1 2 3 4 5 6 7 8 9]\n</code></pre> <p>As the numbers on the tumbler wheel are just a range between 0 and 9, then rather than type out all the numbers we can use the <code>range</code> function to generate all the numbers for us.</p> <p>When we give the range function one argument, it will create all the whole numbers from 0 to the number before that of the argument.  In the following example, we give <code>range</code> the argument of 10 and we receive the numbers from 0 to 9.</p> <pre><code>(range 10)\n</code></pre> <p><code>range</code> can take two arguments to specify the start and end points, e.g <code>(range 5 15)</code> which returns <code>(5 6 7 8 9 10 11 12 13 14)</code> </p> <p><code>range</code> can also include a step increment to, e.g. <code>(range 2 0 20)</code> which returns every second number from the range, ``</p> range without arguments generates infinite sequence <p>Avoid callng the <code>range</code> function without arguments as it will try and generate an infinite range of numbers, not stopping until the computer memory is used up.</p> <p><code>range</code> can be used without arguments safely when another function limits the numbers generated, e.g. <code>take</code></p> <pre><code>(take 10 (range))\n</code></pre>"},{"location":"small-projects/tripple-lock/#create-all-the-combinations","title":"Create all the Combinations","text":"<p>Complete the following code (replacing the <code>,,,</code>) to generate all the possible combinations of the lock**</p> <pre><code>(for [tumbler-1 (range 10)\n      ,,,     ,,,\n      ,,,     ,,,]\n [tumbler-1 ,,,   ,,,])\n</code></pre>"},{"location":"small-projects/tripple-lock/#count-combinations","title":"Count combinations","text":"<p>Instead of showing all the possible combinations, count all the combinations and return the total number of combinations</p> <p>Take the code from the combinations and wrap it in the <code>count</code> function</p> <pre><code>;; now count the possible combinations\n(count\n\n         )\n</code></pre>"},{"location":"small-projects/tripple-lock/#unique-combinations","title":"Unique combinations","text":"<p>Make the lock more secure by only allowing combinations where each tumbler wheel has a different number, avoiding easier to guess combinations like 1-1-1, 1-2-2, 1-2-1, etc.</p> <p>How many combinations does that give us?</p> <p>Complete the following code to create a 3-tumbler wheel combination lock, where none of the numbers are the same**</p> <p>Hint: Beware not to enter (range) without an argument as Clojure may try and evaluate infinity</p> <pre><code>(count (for [tumbler-1 (range 10)\n             ,,,     ,,,\n             ,,,     ,,,\n             :when (or (= tumbler-1 tumbler-2)\n                       ,,,\n                       ,,,)]\n         [tumbler-1 ,,,   ,,,]))\n</code></pre> Suggested solution <p>Suggested solution to the completed 3-lock challenges. <pre><code>;; a 3 combination padlock\n\n;; model the combinations\n(for [tumbler-1 (range 10)\n      tumbler-2 (range 10)\n      tumbler-3 (range 10)]\n [tumbler-1 tumbler-2 tumbler-3])\n\n\n;; now count the possible combinations\n(count (for [tumbler-1 (range 10)\n             tumbler-2 (range 10)\n             tumbler-3 (range 10)]\n         [tumbler-1 tumbler-2 tumbler-3]))\n\n\n(count (for [tumbler-1 (range 10)\n             tumbler-2 (range 10)\n             tumbler-3 (range 10)\n             :when (or (= tumbler-1 tumbler-2)\n                       (= tumbler-2 tumbler-3)\n                       (= tumbler-3 tumbler-1))]\n         [tumbler-1 tumbler-2 tumbler-3]))\n\n;; lets look at the combinations again, we can see that there is always at least 2 matching values.  This is probably the opposite of what we want in real life.\n(for [tumbler-1 (range 10)\n      tumbler-2 (range 10)\n      tumbler-3 (range 10)\n      :when (or (= tumbler-1 tumbler-2)\n                (= tumbler-2 tumbler-3)\n                (= tumbler-3 tumbler-1))]\n  [tumbler-1 tumbler-2 tumbler-3])\n</code></pre></p>"},{"location":"small-projects/championships/","title":"Project: Championships","text":"<p>A project to show the winner, predicted winner and leaderboard from a competition.</p> <p>Competitions are defined in a hashmap</p> <pre><code>{:competition :competition-id\n :year :2023\n :winner \"\"\n :predicted-winner \"\"\n :drivers\n  [{:name \"Max Verstapen\" :score 364}\n   {:name \"Sergio Perez\" :score 219}\n   {:name \"Fernando Alonso\" :score 219}\n   ,,,\n  ]}\n</code></pre> <p>Data for each race</p> <pre><code>{:name :monza\n :date \"month-day (main race)\"\n :results \n [{:driver \"\" :score 25}]]}\n</code></pre>"},{"location":"small-projects/championships/#edge-cases","title":"Edge cases","text":"<ul> <li>Drivers with equal scores considers overall results and highest scores over current season</li> </ul>"},{"location":"small-projects/data-transformation/","title":"Data Transformation","text":"<p>In a sense all Clojure project are about data transformation, however, these projects will introduce you to many techniques used to transform larger and larger data sets.</p> <p></p> Project Topics Overview Most common word regex filter re-seq sort-by Find the most common word in a give book that is not a common English word"},{"location":"small-projects/data-transformation/most-common-word/","title":"Most common word","text":"<p>In this challenge we would like you to find the most used word in a book. The word should not be part of the common English words (i.e. the, a, i, is).</p> <p>This functionality is useful for generating word maps or identifying patterns across data sets.</p> <p></p> <p>Copyright free books for use are available via Project Guttenburg, e.g. \u201cThe Importance of Being Earnest\u201d by Oscar Wilde.</p>"},{"location":"small-projects/data-transformation/most-common-word/#suggested-approach","title":"Suggested approach","text":"<p>A suggested approach to find the most common word:</p> <ul> <li>Pull the content of the book into a collection</li> <li>Use a regular expression to create a collection of individual words - eg. <code>#\u201d[a-zA-Z0-9|\u2019]+\u201d</code></li> <li>Remove the common English words used in the book</li> <li>Convert all the words to lower case so they match with common words source</li> <li>Count the occurrences of the remaining words (eg. each word is associated with the number of times it appears in the book)</li> <li>Sort the words by the number of the occurrences</li> <li>Reverse the collection so the most commonly used word is shown first</li> </ul>"},{"location":"small-projects/data-transformation/most-common-word/#create-a-project","title":"Create a project","text":"<p> Pracitcalli Clojure CLI Config provides the <code>:project/create</code> alias to create projects using deps-new project.</p> <pre><code>clojure -T:project/create :template app :name practicalli/common-words\n</code></pre>"},{"location":"small-projects/data-transformation/most-common-word/#get-the-book-contents","title":"Get the book contents","text":"<p><code>clojure.core/slurp</code> will read in a local file or a remote resource (file, web page, etc) and return a single string of the contents.</p> <pre><code>(slurp \"https://www.gutenberg.org/files/844/844-0.txt\")\n</code></pre> <p>Wrap the <code>slurp</code> expression in a <code>def</code> to bind a name to the book.</p> <pre><code>(def being-earnest (slurp \"https://www.gutenberg.org/files/844/844-0.txt\"))\n</code></pre> <p>Project Gutenberg now compresses the books with GZip, so a stream can be created to read the file and decompress it.  Then slurp is used to read in the uncompressed text of the book into a string.</p> <pre><code>(def being-earnest\n  (with-open [uncompress-text (java.util.zip.GZIPInputStream.\n                  (clojure.java.io/input-stream\n                   \"https://www.gutenberg.org/cache/epub/844/pg844.txt\"))]\n    (slurp uncompress-text)))\n ```\n\n## Individual words from the book\n\nThe book contents should be broken down into individual words.\n\nA regular expression can be used to identify word boundaries, especially where there are apostrophes and other characters.\n\n`clojure.core/re-seq` returns a new lazy sequence containing the successive matches of a pattern from a given string.  So given a sentence\n\nUsing `re-seq` to convert the first sentence of the `being-earnest` book using a regex word boundary pattern, `\\w+`.\n\n```clojure\n(re-seq #\"\\w+\" \"Morning-room in Algernon's flat in Half-Moon Street.\")\n\n;; =&gt; (\"Morning\" \"room\" \"in\" \"Algernon\" \"s\" \"flat\" \"in\" \"Half\" \"Moon\" \"Street\")\n</code></pre> <p>The result is a sequence of the individual words, however, the hyphenated words and the apostrophes have been split into separate words.</p> <p>Extending the regex pattern the results can be refined.</p> <pre><code>(re-seq #\"[\\w|'-]+\" \"Morning-room in Algernon's flat in Half-Moon Street.\")\n\n;; =&gt; (\"Morning-room in Algernon's flat in Half-Moon Street\")\n</code></pre> <pre><code>(re-seq #\"[\\w|'-]+\" being-earnest)\n</code></pre> <p>The #\"[\\w|'-]+\" is the same pattern as the more explicit pattern #\"[a-zA-Z0-9|'-]+\"</p>"},{"location":"small-projects/data-transformation/most-common-word/#removing-common-english-words","title":"Removing common English words","text":"<p>In any book the most common word its highly likely to be a common English word (the, a, and, etc.).  To make the most common word in any book more specific, the common English words should be removed.</p> <p><code>common-english-words.csv</code> contains comma separate words.</p> <p>Using slurp and a regular expression the individual words can be extracted into a collection.</p> <p>Rather than <code>re-seq</code> the <code>clojure.string/split</code> can be used.  This is a more specific function for splitting a string using a regular expression pattern, in this case the pattern for a comma, <code>#\",\"</code>.</p> <pre><code> (clojure.string/split (slurp \"common-english-words.csv\") #\",\")\n</code></pre> <p>An additional step is to place the common English words into a Clojure set, a data structure which contains a unique set of values.</p> <pre><code> (set (clojure.string/split (slurp \"common-english-words.csv\") #\",\"))\n</code></pre> <p>The advantage of using a set for the common English words is that the data structure can be used as a predicate to remove matching words.  So a common English words set can be used to remove the common English words from <code>being-earnest</code> book.</p> <p>Define a name for the common English words set.</p> <pre><code>(def common-english-words (set (clojure.string/split (slurp \"common-english-words.csv\") #\",\")))\n</code></pre> <p>This can also be written using the threading macro, to show the sequential nature of the data transformation.</p> <pre><code>(def common-english-words\n  (-&gt; (slurp \"common-english-words.csv\")\n      (clojure.string/split #\",\")\n      set))\n</code></pre> <p>The <code>common-english-words</code> set can now be used with the <code>being-earnest</code> book.</p> <pre><code>(remove common-english-words (re-seq #\"[\\w|'-]+\" being-earnest))\n</code></pre>"},{"location":"small-projects/data-transformation/most-common-word/#counting-occurrences","title":"Counting Occurrences","text":"<p><code>clojure.core/frequencies</code> takes a collection and returns a map where the keys are the unique elements from the collection and the value for each key is the number of times that element occurred in the collection.</p> <pre><code>(filter (remove common-english-words (re-seq #\"[\\w|'-]+\" being-earnest)))\n</code></pre> <p>The resulting hash-map is not in any order.  <code>clojure.core/sort-by</code> will return the same results but sorted by a given function.  To sort a hash-map the <code>key</code> and <code>val</code> functions are function that will sort by key and value respectively.  As it is the value that has the number of occurrences, then <code>val</code> is the function to use.</p> <pre><code>(sort-by val (filter (remove common-english-words (re-seq #\"[\\w|'-]+\" being-earnest))))\n</code></pre> <p>The result is sorted from smallest to largest value.  The result could be reversed using <code>clojure.core/reverse</code> or by supplying an extra function to the <code>sort-by</code> expression.  Using greater-than, <code>&gt;</code> the result will be returned in descending order.</p> <pre><code>(sort-by val dec (filter (remove common-english-words (re-seq #\"[\\w|'-]+\" being-earnest))))\n</code></pre>"},{"location":"small-projects/data-transformation/most-common-word/#assembling-the-most-common-word-function","title":"Assembling the most-common-word function","text":"<p>Define a function called <code>most-common-word</code> that assembles all the previous steps.  The function should take all the values it needs for the calculation as arguments, creating a pure function without side effects.</p> <pre><code>(defn most-common-word\n  [book common-words]\n  (sort-by val &gt;\n    (frequencies\n      (remove common-words\n        (map #(clojure.string/lower-case %)\n             (re-seq #\"[\\w|'-]+\" book))))))\n</code></pre> <p>This may seem a little hard to parse, so the function definition can be re-written using a threading macro.</p> <pre><code>(defn most-common-word\n  [book common-words]\n  (-&gt;&gt; book\n       (re-seq #\"[\\w|'-]+\" ,,,)\n       (map #(clojure.string/lower-case %))\n       (remove common-words)\n       frequencies\n       (sort-by val &gt;)))\n</code></pre> <p>Call this function with the <code>being-earnest</code> book and the <code>common-english-words</code></p> <pre><code>(most-common-word being-earnest common-english-words)\n</code></pre>"},{"location":"small-projects/data-transformation/most-common-word/#running-from-the-command-line","title":"Running from the command line","text":"<p>Update the code to take the book reference from the command line.</p> <p>Remove the <code>def</code> that hard-coded the being-earnest book.</p> <p>In the <code>most-common-word</code> wrap the book with <code>slurp</code> to read the book reference in and convert it to a string, to be processed by the rest of the expressions.</p> <p>Add a <code>-main</code> function that takes a reference for the source of the book and the source of the common words.</p> <pre><code>(ns practicalli.common-word)\n\n(defn decode-book\n  [book-gzip]\n  (with-open\n    [uncompress-text (java.util.zip.GZIPInputStream.\n                      (clojure.java.io/input-stream book-gzip))]\n    (slurp uncompress-text)))\n\n(defn common-words\n  [csv]\n  (-&gt; (slurp csv)\n      (clojure.string/split #\",\")\n      set))\n\n(defn most-common-word\n  [book-gzip common-words]\n  (-&gt;&gt; (decode book-gzip)\n       (re-seq #\"[\\w|'-]+\")\n       (map #(clojure.string/lower-case %))\n       (remove common-words)\n       frequencies\n       (sort-by val &gt;)))\n\n(defn -main\n  [book-gzip common-word-csv]\n  (most-common-word book-gzip (common-words common-word-csv)))\n</code></pre> <p>Now call the code on the command line.</p> <pre><code>clojure -m practicalli.common-word \"https://www.gutenberg.org/cache/epub/844/pg844.txt\" \"common-english-words.csv\"\n</code></pre>"},{"location":"small-projects/encode-decode/","title":"Encoding and Decoding with Clojure","text":"<p>Projects that use a range of ciphers, from simple to more complex, to encode and decode text.</p> <p>A common approach to encoding and decoding text is to use a dictionary lookup, defined in Clojure as a hash-map. Each key-value pair provides a mapping for encoding and decoding.  Looking up a a character as a key in the map provides a value that is the encrypted character.</p> <p>These projects show several ways to transform data in Clojure.</p> Project Topics Description Boolean names to 0 or 1 hash-map get Convert boolean values to classic 1 or 0 values Caesar cipher - ROT13 seq cycle zipmap A simple alphabet rotation cipher RNA / DNA converter Convert between DNA and RNA Clacks telegram Encoding and decoding messages with Clacks"},{"location":"small-projects/encode-decode/#examples-of-encoding","title":"Examples of Encoding","text":"<ul> <li>Portable Network Graphics for image compression</li> <li>Vorbis for music and video compression plus several commercial compression encoders</li> <li>Enigma machine - encrypted communications</li> </ul>"},{"location":"small-projects/encode-decode/caesar-cipher-rot13/","title":"Caesar Cipher ROT13","text":"<p>ROT13 is one of the simplest ciphers which uses an alphabet as a circle of characters, swapping each character with a character 13 positions later in the alphabet, assuming 26 character of an English alphabet.</p> <p>A dictionary can be generated to translate between the original alphabet and the rotated alphabet, providing a simple way to generate an encrypted message.</p>"},{"location":"small-projects/encode-decode/caesar-cipher-rot13/#create-a-project","title":"Create a project","text":"<p> Pracitcalli Clojure CLI Config provides the <code>:project/create</code> alias to create projects using deps-new project.</p> <pre><code>clojure -T:project/create :template app :name practicalli/caesar-cipher\n</code></pre>"},{"location":"small-projects/encode-decode/caesar-cipher-rot13/#define-an-alphabet","title":"Define an alphabet","text":"<p>Define an alphabet to use as a basis for conversion.  Take the string of all characters and convert to a sequence of character types.</p> src/practicalli/caesar-cipher.clj<pre><code>(def english-alphabet\n  (seq \"abcdefghijklmnopqrstuvwxyz\"))\n</code></pre>"},{"location":"small-projects/encode-decode/caesar-cipher-rot13/#generate-a-cypher","title":"Generate a cypher","text":"<p>To convert a character, first build up a cypher.  A cypher in this case is simply a hash-map that creates a dictionary lookup defining what each character should be changed to.</p> <p><code>cycle</code> creates a lazy sequence of the alphabet that continually cycles.  This provides an 'infinite' sequence from which we will take only the characters needed.</p> <pre><code>(cycle \"abcdefghijklmnopqrstuvwxyz\")\n</code></pre> <p>The dictionary is composed of the original alphabet and a new alphabet that is offset by 13 characters, half the number of characters in the dictionary.</p> <p><code>(drop 13 (cycle alphabet))</code>  will drop the first 13 characters.  As <code>cycle</code> creates an 'infinite' alphabet, there are still plenty of characters to make a second alphabet.</p> <p><code>(take 26 (drop 13 (cycle alphabet)))</code> will get a new alphabet of 26 characters, starting from the 14th character, <code>n</code>.</p> <p><code>zipmap</code> is used to join two collections together to form a hash-map, e.g. the lookup dictionary. In this case the original alphabet and the new alphabet.</p> <p><code>(zipmap alphabet (take 26 (drop 13 (cycle alphabet))))</code></p> <p>This expression is nested and can be harder to parse by those new to Clojure.  The code can be written using a threading marco, that demonstrated the flow of data transformation.</p> <p>Using the thread last macro, <code>-&gt;&gt;</code>, the result of each expression becomes the last argument for the next expression.</p> <pre><code>(-&gt;&gt; (cycle alphabet)\n     (drop 13)\n     (take 26)\n     (zipmap alphabet))\n</code></pre> <p>Using the clojure.core/replace function with the cypher hash-map and a string of text returns a converted string of text.</p>"},{"location":"small-projects/encode-decode/caesar-cipher-rot13/#define-a-function","title":"Define a function","text":"<p>Define a <code>rot13</code> function with the algorithm created.  The function takes the alphabet and the text to be encrypted.  Passing both pieces of data as arguments ensures that the function is pure, i.e. free from side effects.</p> src/practicalli/caesar-cipher.clj<pre><code>(defn rot13 [alphabet text]\n  (let [cipher (-&gt;&gt; (cycle alphabet)\n                    (drop 13)\n                    (take 26)\n                    (zipmap alphabet))]\n    (apply str (replace cipher text))))\n</code></pre> <p>Call the rot13 function with the <code>english-alphabet</code> and a sentence as a string.</p> <pre><code>(rot13 english-alphabet \"The Quick Brown Fox Jumped Over The Lazy Dog!\")\n</code></pre> <p>An encrypted copy of the sentence is returned.</p>"},{"location":"small-projects/encode-decode/caesar-cipher-rot13/#idiomatic-improvements","title":"Idiomatic improvements","text":"<p><code>clojure.string</code> library is more idiomatic approach when working with string types.</p> <p>In the <code>practicalli.cypher-rot13</code> solution <code>apply str</code> was used to join a sequence of characters into a string.  <code>clojure.string/join</code> combines a sequence of characters into a string.</p> <p>Require the <code>clojure.string</code> namespace to use the functions contained within.  Add the require to the namespace definition of <code>practicalli.cypher-rot13</code></p> src/practicalli/caesar-cipher.clj<pre><code>(ns practicalli.ceaser-cypher\n  (:gen-class)\n  (:require [clojure.string :as string]))\n</code></pre> <p>Update the <code>rot13</code> function to use <code>clojure.string/join</code> rather than <code>apply str</code>.</p> <pre><code>(defn rot13 [alphabet text]\n  (let [cipher (-&gt;&gt; (cycle alphabet)\n                    (drop 13)\n                    (take 26)\n                    (zipmap alphabet))]\n    (string/join (replace cipher text))))\n</code></pre>"},{"location":"small-projects/encode-decode/clacks/","title":"Clacks Messages","text":"<p>In the 33rd Discworld novel, Going Postal, messages are sent faster than a speeding horse via the Clacks system.  The Clacks system composes of a series of towers spread across a continent with each tower sending a light signal to the next tower using combinations of lights for each character in the message.  Each tower sees a grid of lights from a distant tower and sends the message on to the next tower.</p> <p>The Clacks system was introduced in the 24th Discworld novel called \"The Fifth Elephant\". \"Going Postal\" elaborates the full history of the Clacks system.</p>"},{"location":"small-projects/encode-decode/clacks/#the-challenge","title":"The Challenge","text":"<p>Create a Clacks encoder that converts any English language message into its corresponding clacks signal, based on the Clacks alphabet as defined by the board game of the same name.</p> <p>The board game defines the alphabet as a 2 by 3 grid (although in the Discworld its actually 8 large squares).  Naturally, the interpreter also converts the Clacks signal back into an English message too.</p> <p></p>"},{"location":"small-projects/encode-decode/clacks/#create-a-project","title":"Create a project","text":"<p> Pracitcalli Clojure CLI Config provides the <code>:project/create</code> alias to create projects using deps-new project.</p> <pre><code>clojure -T:project/create :template app :name practicalli/clacks-messenger\n</code></pre> <p>This project has a <code>deps.edn</code> file that includes the aliases</p> <ul> <li><code>:test</code> - includes the <code>test/</code> directory in the class path so unit test code is found</li> <li><code>:runner</code> to run the Cognitect Labs test runner which will find and run all unit tests</li> </ul>"},{"location":"small-projects/encode-decode/clacks/#representing-a-clack","title":"Representing a Clack","text":"<p>For each clack, the light pattern is read from the top of the first column to the bottom, then from the top of the second column to the bottom.  A light in a position represents a 1 value and no light represents a 0 value.  This gives us our 6 number pattern for each clack in the alphabet.</p> <p>The initial data structure chosen was essentially just modelling each individual clack.  Since a clack is a 2x3 structure, the simplest way to represent a clacks is to have a vector that contains 2 vectors, each with three elements.</p> <p>So a simple expression of the letter a in the clacks alphabet would be:</p> <pre><code>[[0 1 0][0 0 1]]\n</code></pre> <p>Therefore we could define a single letter of our alphabet as follows:</p> <pre><code>(def a [[0 1 0][0 0 1]])\n</code></pre> <p>Before defining the complete alphabet using this data structure, test this is the right data structure for the conversion process.</p>"},{"location":"small-projects/encode-decode/clacks/#test-simple-conversion","title":"Test simple conversion","text":"<p>Define a function to convert a single character into a clack:</p> <pre><code>(defn character-&gt;clack [character]\n  (if (= character \"a\")\n    a\n    (str \"Sorry, character is not yet in the alphabet, please create a pull request\")))\n</code></pre> <p>Calling the function converts a string into the corresponding clack</p> <pre><code>(character-&gt;clack \"a\")\n</code></pre> <p>Clojure function naming</p> <p><code>-&gt;</code> is a naming convention to indicate a function is specifically transforming to a data format.  For example, <code>json-&gt;clj-map</code> would be a generic function for transforming json to Clojure hash-map</p> <p>The code is simple for a single character, however, would require a lot of redundant code to convert the whole alphabet.  We would need either a deeply nested set of if statements or a very long <code>cond</code> function, neither of which seems to be a particularly functional approach or idiomatic Clojure.</p> <p>If a <code>cond</code> statement was used, how would a clacks be converted back into a character?</p> <p>So perhaps we need to change the data structure, one that provides an easy way to map to values together.</p> <p>Also, there seems no value in mapping values to a 2x3 grid as long as we consistently express a clack.</p>"},{"location":"small-projects/encode-decode/clacks/#define-the-alphabet","title":"Define the alphabet","text":"<p>A hash map associates each key with a value and are used to create self-describing data. For example a person could be described as a hash-map</p> <pre><code>{:name \"Jenny Jetpack\" :age \"21\" :twitter \"jenjetpack\"}\n</code></pre> <p>Clojure keywords are often used for the keys because keywords can be used as a function with a map as an argument.  This will return the value associated with the keyword in the map.</p> <p>The new design for the clacks data structure associates a keyword of each letter of the alphabet with its corresponding clacks light pattern code</p> <pre><code>{:a [0 1 0 0 0 1]}\n</code></pre> <p>Test the design by defining enough letters for the clacks alphabet to convert some simple words, i.e bat</p> <pre><code>(def alphabet {:a [0 1 0 0 0 1]\n               :b [0 0 1 0 1 0]\n               :t [1 0 0 1 1 1]})\n</code></pre>"},{"location":"small-projects/encode-decode/clacks/#testing-the-map-design","title":"Testing the map design","text":"<p>Use a keyword to lookup the value of its clack code</p> <pre><code>(:a alphabet)\n\n;; =&gt; [0 1 0 0 0 1]\n</code></pre> <p>Create a simple function to convert a single character to its Clacks representation, referred to a clack.</p> <pre><code>(defn character-&gt;clack [character]\n    ((keyword character) alphabet))\n</code></pre> <p>The <code>-&gt;</code> character is part of the function name.  This is a Clojure naming convention used when the function you are defining converts from one type to another.</p> <p>And call the function as follows</p> <pre><code>(character-&gt;clack \"a\")\n\n;; =&gt; [0 1 0 0 0 1]\n</code></pre>"},{"location":"small-projects/encode-decode/clacks/#converting-a-word","title":"Converting a word","text":"<p>Now we want to convert a whole word to a clacks sequence.  It seemed the easiest way to convert a whole word was to convert each letter at a time using the map to look up each clack code, returning all the clacks codes in a sequence.</p> <p>So we redefined the <code>string-&gt;clacks</code> function to take in a whole word.</p> <p>We used the <code>map</code> function to apply a conversion function over each element in the word (each element of the string).  This conversion function called <code>clacksify</code>.</p> <pre><code>(defn clacksify [letter]\n  (let [character (str letter)]\n  (alphabet (keyword character))))\n\n(defn string-&gt;clacks [word]\n  (map clacksify word))\n</code></pre> <p>Now we could convert any word that used the letters of our limited alphabet.  We chose bat as a simple word.</p> <pre><code>(string-&gt;clacks \"bat\")\n</code></pre> <p>As we are passing a string and not a keyword to the <code>clacksify</code> function, then we first convert the string to a keyword using the <code>keyword</code> function.</p>"},{"location":"small-projects/encode-decode/clacks/#converting-the-clack-to-a-string","title":"Converting the clack to a string","text":"<p>Is there a simple way to look up a key given a value that is unique in the map?</p> <p>All Clack codes are unique in the map, but there did not seem to be a simple expression to find the key when given a value.</p> <p>We could have created a second mapping, however having two maps seemed redundant and a potential cause for silly bugs.</p> <p>The answer was simple once we found it.  As the clack codes are unique, they could be used as keys for the letter values, we just needed to swap the map around.  Swapping a map's keys and values was done by writing a <code>reverse-map</code> function.</p> <pre><code>(defn reverse-map\n  \"Reverse the keys and value pairs in a map.\n  Allows the map to be used to convert from a clack to a letter without defining a second map\"\n  [m]\n  (into {} (map (fn [[a b]] [b a]) m)))\n</code></pre> <p>So we defined the function <code>declacksify</code> which takes a clack code and returns its corresponding character.  The clack code returns the corresponding keyword rather than a character, so we use the <code>name</code> function to convert the keyword into a character name.</p> <pre><code>(defn declacksify [clack]\n  (name ((reverse-map alphabet) clack)))\n\n(defn clacks-&gt;string [clacks]\n  (map declacksify clacks))\n</code></pre> <p>So calling these functions with a clacks</p> <pre><code>(declacksify  [1 0 0 1 1 1])\n;; =&gt; \"t\"\n\n(clacks-&gt;string [[0 0 1 0 1 0] [0 1 0 0 0 1] [1 0 0 1 1 1]])\n;; =&gt; (\"b\" \"a\" \"t\")\n</code></pre> <p>At this point you may be thinking that using keywords to represent the characters of the alphabet may not be the most effective.  Using keywords has required more code to be written, adding to the complexity of the solution.</p>"},{"location":"small-projects/encode-decode/clacks/#tidy-output","title":"Tidy output","text":"<p><code>clacks-&gt;string</code> function returns the right result, but not quite in the format required.  Rather than a single string a sequence of characters is returned.</p> <p>Using the <code>map</code> function we can apply the <code>str</code> function over the resulting characters to give a single string.</p> <pre><code>(defn clacks-&gt;string [clacks]\n(map str (map declacksify clacks)))\n</code></pre> <p>Using <code>clojure.string/join</code> is a more idiomatic approach to converting a sequence of characters to a string</p> <pre><code>(require '[clojure.string :as string])\n\n(defn clacks-&gt;string [clacks]\n  (string/join (map declacksify clacks)))\n</code></pre>"},{"location":"small-projects/encode-decode/clacks/#refactor-dictionary-design","title":"Refactor dictionary design","text":"<p>Converting characters to keywords and back again seem redundant when characters themselves can be used as keys in a hash-map.</p> <p>Using keywords is problematic when it comes to the space character as a keyword cannot be a space.  Using <code>:-</code> to represent a space required the clacksification and declacksification functions to convert between <code>:-</code> and the space character.  This also prevents hyphenated words working in the Clacks system.</p> <p>Refactor the dictionary to use a string for each character as the keys in the map, instead of Clojure keywords.  This solves the issue with space and other special characters.</p> <pre><code>(def dictionary\n  {\"a\"  [0 1 1 0 0 0 0 1]\n   \"b\"  [0 1 1 0 0 0 1 0]\n   \"c\"  [0 1 1 0 0 0 1 1]\n   \"d\"  [0 1 1 0 0 1 0 0]\n   \"e\"  [0 1 1 0 0 1 0 1]\n   ,,,})\n</code></pre>"},{"location":"small-projects/encode-decode/clacks/#refactor-namespace","title":"Refactor namespace","text":"<p>As the dictionary can be quite large to represent in code, move the dictionary definition to its own namespace.</p> <p>Use a more specific name for the dictionary, describing what languages the dictionary is used for</p> <pre><code>(def english-&gt;clacks\n  {\"a\"  [0 1 1 0 0 0 0 1]\n   \"b\"  [0 1 1 0 0 0 1 0]\n   \"c\"  [0 1 1 0 0 0 1 1]\n   \"d\"  [0 1 1 0 0 1 0 0]\n   \"e\"  [0 1 1 0 0 1 0 1]\n   ,,,})\n</code></pre> <p>A dictionary is required to translate from Clacks to English to decode the messages. Rather than write the reverse mappings for each character in the dictionary, in effect creating a second directory for the same two languages, use a function to invert the map by swapping keys and values.</p> <p><code>clojure.set/map-invert</code> will swap each key/value pair in the map so the key becomes the value and the value becomes the key.</p> <p>Define a <code>clacks-&gt;english</code> dictionary that holds the result of the <code>map-invert</code> function call</p> <pre><code>(ns practicalli.clacks-dictionary\n  (:require [clojure.set]))\n\n(def clacks-&gt;english { ,,, })\n\n(def clacks-&gt;english (clojure.set/map-invert english-&gt;clacks))\n</code></pre> <p>Require the dictionary namespace using the alias <code>dictionary</code> to give the dictionary names context when used in the main namespace.</p> <p>Also require <code>clojure.string</code> using the alias <code>string</code> to use the join function.</p> <pre><code>(ns practicalli.clacks-messenger\n  (:require [practicalli.clacks-dictionary :as dictionary]\n            [clojure.string :as string]))\n</code></pre>"},{"location":"small-projects/encode-decode/clacks/#removing-side-effects","title":"Removing side effects","text":"<p>Designing pure functions, those that receive all their data via arguments, is a common way to remove side effects.</p> <p>Include the dictionary as an argument to each of the functions.  This ensures that each function is pure and prevents side effects (side causes).</p> <pre><code>(defn character-&gt;clack [char dictionary]\n  (let [character (str char)]\n    (get dictionary character)))\n\n(defn message-&gt;clacks [message dictionary]\n  (map #(character-&gt;clack % dictionary) message))\n\n(defn clack-&gt;character [clack dictionary]\n  (get (clojure.set/map-invert dictionary) clack))\n\n(defn clack-&gt;character [clack dictionary]\n  (get dictionary-inverted clack))\n\n;; Create a clacks code back to a message\n\n(defn clacks-&gt;message [clacks dictionary]\n  (string/join (map #(clack-&gt;character % dictionary) clacks)))\n</code></pre> <p>Test the updated functions by calling them via the REPL</p> <pre><code>(message-&gt;clacks \"cab\" dictionary/english-&gt;clacks)\n;; =&gt; ([0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0])\n\n(message-&gt;clacks \"cab cab\" dictionary/english-&gt;clacks)\n;; =&gt; ([0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0] [0 0 0 0 0 0 0 0] [0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0])\n\n;; Create a character from a clack code\n\n;; test data\n(clacks-&gt;message '([0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0]) dictionary/english-&gt;clacks)\n\n(clacks-&gt;message\n '([0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0] [0 0 0 0 0 0 0 0] [0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0]) dictionary)\n</code></pre>"},{"location":"small-projects/encode-decode/clacks/#use-alternative-dictionaries","title":"Use alternative dictionaries","text":"<p>Thanks to a flexible design with no side effects or side causes then its really easy to replace the English language alphabet with another language that can be encoded into Clack codes.</p> <p>All that is required is to define a dictionary for another language.  So languages based on the greek, latin or cyrillic alphabet could be send if a suitable alphabet with clack codes is supplied.</p>"},{"location":"small-projects/encode-decode/convert-boolean-values/","title":"Convert boolean values","text":""},{"location":"small-projects/encode-decode/convert-boolean-values/#convert-boolean-true-false-to-1-and-0","title":"Convert boolean true false to 1 and 0","text":"<p>A very simple example of encoding and decoding is converting the Clojure values of <code>true</code> and <code>false</code> to <code>1</code> and <code>0</code> respectively.</p> <p>Using <code>1</code> for true and <code>0</code> for false has been a common idiom in programming languages, especially where a language did not include <code>true</code> and <code>false</code> syntax.</p>"},{"location":"small-projects/encode-decode/convert-boolean-values/#define-an-association-between-values","title":"Define an association between values","text":"<p>Define a Clojure <code>hash-map</code> to associate the Clojure boolean <code>true</code> an <code>false</code> values to <code>1</code> and <code>0</code> respectively</p> <pre><code>{false 0\n true 1}\n</code></pre>"},{"location":"small-projects/encode-decode/convert-boolean-values/#find-an-associated-value-for-the-conversion","title":"Find an associated value for the conversion","text":"<p>Using the <code>get</code> function the <code>boolean-value</code> is used to find a matching key in the map and if found the value that key is associated is returned.</p> <pre><code>(get {false 0 true 1} boolean-value)\n</code></pre> <p>Example:</p> <pre><code>(get {false 0 true 1} true)\n</code></pre> <p>A map can be called, just like a function.  the <code>boolean-value</code> is passed to the map as a function argument. As with the <code>get</code> expression, if the map contains the key the associated value is returned.</p> <pre><code>({false 0 true 1} boolean-value)\n</code></pre> <p>Example:</p> <pre><code>({false 0 true 1} true)\n</code></pre>"},{"location":"small-projects/encode-decode/convert-boolean-values/#convert-multiple-boolean-values","title":"Convert multiple boolean values","text":"<p>If there are a collection of boolean values to convert, the <code>map</code> function can be used to convert them all to 1 or 0.</p> <p>Map this over a collection of values</p> <pre><code>(map {false 0 true 1} [collection-of-boolean-values])\n</code></pre> <p>Example:</p> <pre><code>(map {false 0 true 1} [true false false true true true false false true false true false false true])\n</code></pre>"},{"location":"small-projects/encode-decode/convert-boolean-values/#how-does-this-work","title":"How does this work?","text":"<p>The <code>map</code> function takes two arguments, a function and a collection.  The <code>map</code> function calls the function given as an argument and calls it with each element of the collection in turn.  The result of each call is remembered by the <code>map</code> function and when the last element of the collection has been used, a new collection of all the results is returned.</p> <p>In the above example, the hash-map {false 0 true 1} acts as a function.</p> <pre><code>({false 0 true 1} true)\n</code></pre> <p>A hash-map acts as a function in that it can return an associated value when given a key as an argument.</p> <p>Calling <code>{false 0 true 1}</code> with <code>true</code> as an argument returns the value <code>1</code>.</p>"},{"location":"small-projects/encode-decode/rna-dna/","title":"RNA to DNA transcription","text":"<p>Given a DNA strand, return its RNA complement (RNA transcription).</p> <p></p> <p>Both DNA and RNA strands are a sequence of nucleotides.</p> <p>The four nucleotides found in DNA are adenine (A), cytosine (C), guanine (G) and thymine (T).</p> <p>The four nucleotides found in RNA are adenine (A), cytosine (C), guanine (G) and uracil (U).</p> <p>Given a DNA strand, its transcribed RNA strand is formed by replacing each nucleotide with its complement:</p> <pre><code>G -&gt; C\nC -&gt; G\nT -&gt; A\nA -&gt; U\n</code></pre> Inspired by Exercism.io challenge <p>This project was inspired by the RNA Transcription exercise on Exercism.io.  Related exercises include Nucleotide Count and Hamming.</p>"},{"location":"small-projects/encode-decode/rna-dna/#create-a-project","title":"Create a project","text":"<p> Pracitcalli Clojure CLI Config provides the <code>:project/create</code> alias to create projects using deps-new project.</p> <pre><code>clojure -T:project/create :template app :name practicalli/rna-transcription\n</code></pre>"},{"location":"small-projects/encode-decode/rna-dna/#define-unit-tests","title":"Define unit tests","text":"<p>Open the <code>test/practicalli/rna-transcription.clj</code> and add the following tests</p> <pre><code>(ns practicalli.rna-transcription-test\n  (:require [clojure.test :refer [deftest is testing]]\n            [rna-transcription :as SUT]))\n\n(deftest rna-transcription-test\n  (testing \"transcribe cytosine to guanine\"\n    (is (= \"G\" (SUT/to-rna \"C\"))))\n\n  (testing \"transcribe guanine to cytosine\"\n    (is (= \"C\" (SUT/to-rna \"G\"))))\n\n  (testing \"transcribe adenine to uracil\"\n    (is (= \"U\" (SUT/to-rna \"A\"))))\n\n  (testing \"transcribe thymine to adenine\"\n    (is (= \"A\" (SUT/to-rna \"T\"))))\n\n  (testing \"transcribe all nucleotides\"\n    (is (= \"UGCACCAGAAUU\" (rna-transcription/to-rna \"ACGTGGTCTTAA\"))))\n\n  (testing \"validate dna strands\"\n    (is (thrown? AssertionError (rna-transcription/to-rna \"XCGFGGTDTTAA\")))))\n</code></pre>"},{"location":"small-projects/encode-decode/rna-dna/#code-the-rna-transcription","title":"Code the RNA transcription","text":"<p>Edit the <code>src/practicalli/rna-transcription.clj</code> file and require the <code>clojure.string</code> library.  The library is part of the Clojure standard library, so does not need to be added as a project dependency.</p> <pre><code>(ns practicalli.rna-transcription\n  (:require [clojure.string :as string]))\n</code></pre> <p>Define a dictionary to convert from DNA nucleotide to its RNA complement</p> <pre><code>(def dictionary-dna-&gt;rna\n  \"Convert DNA to RNA\"\n  {\"G\" \"C\"\n   \"C\" \"G\"\n   \"T\" \"A\"\n   \"A\" \"U\"}\n  )\n</code></pre> <p>Define a function to convert a single DNA nucleotide (one of <code>G</code>, C, T, A) into its RNA complement, using the dictionary.</p> <p>The algorithm is a simple hash-map lookup using the DNA nucleotide as the Key and returning the RNA complement as the value.</p> <pre><code>(defn convert-nucleotide\n  \"Convert a specific nucleotide from a DNA strand,\n  into a nucleotide for an RNA strand\"\n  [dictionary nucleotide]\n  (get dictionary (str nucleotide)))\n</code></pre> <p>Now a single nucleotide can be converted, another function can be defined to convert all DNA nucleotides in a given sequence.</p> <pre><code>(defn to-rna [dna-sequence]\n  (if (clojure.string/includes? dna-sequence \"X\")\n    (throw (AssertionError.))\n    (apply str\n           (map #(convert-nucleotide dictionary-dna-rna %) dna))))\n</code></pre> <p>Although <code>apply str</code> provides the correct answer, it is more idiomatic to use the <code>clojure.string/join</code> function.</p> <pre><code>(defn to-rna [dna-sequence]\n  (if (clojure.string/includes? dna-sequence \"X\")\n    (throw (AssertionError.))\n    (string/join\n           (map #(convert-nucleotide dictionary-dna-rna %) dna))))\n</code></pre> <p>The functions provide the correct answer, however, <code>to-rna</code> is not a pure function as the dictionary is pulled in as a side cause.</p> <p>Update all the tests in <code>test/practicalli/rna-transcription.clj</code> to call <code>SUT/to-rna</code> with a dictionary included in the argument.</p> <pre><code>(ns practicalli.rna-transcription-test\n  (:require [clojure.test :refer [deftest is testing]]\n            [rna-transcription :as SUT]))\n\n(deftest rna-transcription-test\n  (testing \"transcribe cytosine to guanine\"\n    (is (= \"G\" (SUT/to-rna SUT/dictionary-dna-&gt;rna \"C\"))))\n\n  (testing \"transcribe guanine to cytosine\"\n    (is (= \"C\" (SUT/to-rna SUT/dictionary-dna-&gt;rna \"G\"))))\n\n  (testing \"transcribe adenine to uracil\"\n    (is (= \"U\" (SUT/to-rna SUT/dictionary-dna-&gt;rna \"A\"))))\n\n  (testing \"transcribe thymine to adenine\"\n    (is (= \"A\" (SUT/to-rna SUT/dictionary-dna-&gt;rna \"T\"))))\n\n  (testing \"transcribe all nucleotides\"\n    (is (= \"UGCACCAGAAUU\" (SUT/to-rna SUT/dictionary-dna-&gt;rna \"ACGTGGTCTTAA\"))))\n\n  (testing \"validate dna strands\"\n    (is (thrown?\n           AssertionError\n           (SUT/to-rna SUT/dictionary-dna-&gt;rna \"XCGFGGTDTTAA\")))))\n</code></pre> <p>Update <code>to-rna</code> to be a pure function by including the dictionary as an argument and also pass the updated tests.</p> <pre><code>(defn to-rna [dictionary dna-sequence]\n  (if (clojure.string/includes? dna-sequence \"X\")\n    (throw (AssertionError.))\n    (string/join\n           (map #(convert-nucleotide dictionary %) dna))))\n</code></pre>"},{"location":"small-projects/encode-decode/rna-dna/#idiomatic-improvements","title":"Idiomatic improvements","text":"<p>The <code>to-rna</code> function is not pure, as it relies on a shared value in the namespace, the <code>dictionary-dna-rna</code> transcription map.</p> <p>Passing <code>dictionary-dna-rna</code> as an argument to the <code>to-rna</code> function as well as the dna sequence would make <code>to-rna</code> a pure function.  It would also allow use of a range of transcription maps.</p> <pre><code>(defn to-rna\n  \"Transcribe each nucleotide from a DNA strand into its RNA complement\n  Arguments: string representing DNA strand\n  Return: string representing RNA strand\"\n  [transcription dna]\n  (string/join\n    (map #(or (transcription %)\n              (throw (AssertionError. \"Unknown nucleotide\")))\n         dna )))\n</code></pre> <p>The change to the <code>to-rna</code> function will break all the tests.</p> <p>Updated unit tests that call <code>to-rna</code> with both arguments</p> <pre><code>(ns rna-transcription-pure-test\n  (:require [clojure.test :refer [deftest is]]\n            [rna-transcription-pure :as SUT]\n            [rna-transcription :as data]))\n\n(deftest transcribes-cytosine-to-guanine\n  (is (= \"G\" (SUT/dna-&gt;rna data/dna-nucleotide-&gt;rna-nucleotide \"C\"))))\n\n(deftest transcribes-guanine-to-cytosine\n  (is (= \"C\" (SUT/dna-&gt;rna data/dna-nucleotide-&gt;rna-nucleotide \"G\"))))\n\n(deftest transcribes-adenine-to-uracil\n  (is (= \"U\" (SUT/dna-&gt;rna data/dna-nucleotide-&gt;rna-nucleotide \"A\"))))\n\n(deftest it-transcribes-thymine-to-adenine\n  (is (= \"A\" (SUT/dna-&gt;rna data/dna-nucleotide-&gt;rna-nucleotide \"T\"))))\n\n(deftest it-transcribes-all-nucleotides\n  (is (= \"UGCACCAGAAUU\" (SUT/dna-&gt;rna data/dna-nucleotide-&gt;rna-nucleotide \"ACGTGGTCTTAA\"))))\n\n(deftest it-validates-dna-strands\n  (is (thrown? AssertionError (SUT/dna-&gt;rna data/dna-nucleotide-&gt;rna-nucleotide \"XCGFGGTDTTAA\"))))\n</code></pre>"},{"location":"small-projects/encode-decode/rna-dna/#hintexercisim-project-and-the-pure-function","title":"Hint::Exercisim project and the pure function","text":"<p>If you wish to keep the Exercisim project passing, then add a new namespace to the project by create a new file called <code>rna-transcript-pure.clj</code>.  Add the new design of the <code>to-rna</code> function to that namespace.  Copy the tests into a new namespace by creating a file called <code>rna-transcription-pure.clj</code> and update the tests to use two arguments when calling <code>to-rna</code></p>"},{"location":"small-projects/encode-decode/rna-dna/#summary","title":"Summary","text":"<p>This exercise has covered the concept of using a Clojure hash-map structure as a dictionary lookup.</p>"},{"location":"small-projects/mutating-state/","title":"Mutating State in a Controlled way","text":"<p>Mutating state should be used carefully and sparingly in Clojure (and all other programming languages).</p> <p><code>atom</code> is a mutable container that can manage any value. The atom ensures that only one call at a time can affect the value it manages.  This is part of the software transactions memory system in Clojure.</p> <p>As the atom is mutable in that the value it manages can be changed, however, this must be done with special commands (swap!, reset!, compare-and-set!, swap-vals!).</p> <p>Even though the atom is mutable, the values it manages are not.  They are normal immutable (unchangeable) Clojure values.</p> <p><code>ref</code> is similar to <code>atom</code> and can manage transactions, ensuring that all changes happen or no changes happen.</p> Project Topics Overview Mutants assemble atom swap! reset! Using an atom to manage state changes Undo/Redo atom add-watch Traversing the history of an atom Poker game atom swap! reset! ref Simple transaction management using atom and ref in a card game, using constraints on an atom"},{"location":"small-projects/mutating-state/#references","title":"References","text":"<ul> <li>Atoms - clojure.org</li> <li>Refs and Transactions - clojure.org</li> <li>Agents - clojure.org</li> </ul>"},{"location":"small-projects/mutating-state/mutants-assemble/","title":"Mutants Assemble","text":"<p>In this section you will apply changes to values, how to define your own simple functions.</p> <p>We will also introduce the following functions for the first time:</p> function Description <code>atom</code> create an anonymous function, one without a name <code>deref</code>, <code>@</code> assign a name to a function"},{"location":"small-projects/mutating-state/mutants-assemble/#create-a-new-clojure-project","title":"Create a new Clojure project","text":"<p> Pracitcalli Clojure CLI Config provides the <code>:project/create</code> alias to create projects using deps-new project.</p> <pre><code>clojure -T:project/create :template app :name practicalli/mutants-assemble\n</code></pre> <p>Open the <code>src/practicalli/mutants_assemble.clj</code> file in a Clojure aware editor and start the REPL.</p>"},{"location":"small-projects/mutating-state/mutants-assemble/#define-an-atom","title":"Define an atom","text":"<p>Use the <code>def</code> function to bind a name to an atom.</p> <p>The atom wraps data, initially an empty vector.</p> <pre><code>(def mutants (atom []))\n</code></pre> <p>The vector remains an immutable value, even though it is contained within a mutable atom container</p> <p>Define a function using <code>defn</code> which takes a mutant as an argument and updates the value managed by the atom.  The reference to the atom is also an argument, making this a pure function and more generic as any given atom can be updated with this function.</p> <pre><code>(defn add-mutant [mutants mutant]\n  (swap! mutants conj mutant))\n</code></pre> <p><code>swap!</code> uses a function to create a new value for the atom to manage.  In this case the <code>conj</code> function is used to join the value of mutant with the existing mutants atom value, creating a new vector.</p> <p><code>swap!</code> is a macro so the syntax is a little different. Essentially this is the same as an expression <code>(conj mutants mutant)</code>, with the value this returns swapped into the atom.</p> <p>Call the function with the <code>mutants</code> atom and a mutant to add, which is a string containing the name of a mutant character.</p> <pre><code>(add-mutant mutants \"Black Widow\")\n</code></pre> <p>The value the atom is managing has been swapped for a new value.  The original value was not modified (vectors are immutable) so the atom now points to a new value, a vector containing a string.</p>"},{"location":"small-projects/mutating-state/mutants-assemble/#viewing-the-value-managed-by-the-atom","title":"Viewing the value managed by the atom","text":"<p>Use the <code>deref</code> function to see the value the atom is managing.</p> <pre><code>(deref mutants)\n</code></pre> <p>It is idiomatic to use <code>@</code> which is a syntax alias for the <code>deref</code> function, rather than explicitly using <code>deref</code>.</p> <pre><code>@mutants\n</code></pre>"},{"location":"small-projects/mutating-state/mutants-assemble/#reset-the-atom-value","title":"Reset the atom value","text":"<p><code>reset!</code> will change the value managed by the atom by providing the new value.  This is simpler than using <code>swap!</code> as it does not use the existing value in the atom.</p> <pre><code>(reset! mutants [])\n</code></pre> <p>Now all the mutants are gone (and we can start looking for new ones to add).</p>"},{"location":"thinking-functionally/","title":"Thinking Functionally","text":"<p>In this section I cover some simple examples of Clojure code to help you think about the concepts involved in functional programming.</p> <p>An overview of thinking functionally is also covered in the presentation entitled Getting into Functional Programming with Clojure on slideshare and its accompanying youtube video</p> Get into Functional Programming with Clojure  from John Stevenson <p></p> <p>Get a free Clojurians slack community account</p>"},{"location":"thinking-functionally/arity/","title":"Arity","text":"<p>Fixme work in progress</p>"},{"location":"thinking-functionally/example-hitchhikers-guide/","title":"Example: Hitchhikers Guide","text":"<p>This is an example of using the threading macros and  a REPL to give fast feedback as you are developing code.</p> <p>Suggest you use the assumed perfectly legal copy of the Hitch-hickers book text using the <code>slurp</code> function</p> <p>Approximate algorithm</p> <ul> <li>Use a regular expression to create a collection of individual words - eg. #\"[a-zA-Z0-9|']+\"</li> <li>Convert all the words to lower case so they match with common words source - <code>clojure.string/lower-case</code></li> <li><code>Remove</code> the common English words used in the book, leaving more context specific words</li> <li>Calculate the <code>frequencies</code> of the remaining words, returning a map of word &amp; word count pairs</li> <li><code>Sort-by</code> word count values in the map</li> <li><code>Reverse</code> the collection so the most commonly used word is the first element in the map</li> </ul> <pre><code>(def book (slurp \"http://clearwhitelight.org/hitch/hhgttg.txt\"))\n\n(def common-english-words\n  (-&gt; (slurp \"https://www.textfixer.com/tutorials/common-english-words.txt\")\n      (clojure.string/split #\",\")\n      set))\n\n;; using a function to pull in any book\n(defn get-book [book-url]\n  (slurp book-url))\n\n\n(defn -main [book-url]\n  (-&gt;&gt; (get-book book-url)\n       (re-seq #\"[a-zA-Z0-9|']+\")\n       (map #(clojure.string/lower-case %))\n       (remove common-english-words)\n       frequencies\n       (sort-by val)\n       reverse))\n\n;; Call the program\n\n(-main \"http://clearwhitelight.org/hitch/hhgttg.txt\")\n</code></pre>"},{"location":"thinking-functionally/example-hitchhikers-guide/#note","title":"NOTE","text":"<p>Write functions that will give a list of the most used words used in a book, excluding the common English words like \"the, and, it, I\".  Join those functions with a threading macro.</p>"},{"location":"thinking-functionally/example-hitchhikers-guide/#deconstructing-the-code-in-the-repl","title":"Deconstructing the code in the repl","text":"<p>To understand what each of the functions do in the <code>-main</code> function then you can simply comment out one or more expressions using in front of the expression #_</p> <pre><code>(defn -main [book-url]\n  (-&gt;&gt; (get-book book-url)\n       #_(re-seq #\"[a-zA-Z0-9|']+\")\n       #_(map #(clojure.string/lower-case %))\n       #_(remove common-english-words)\n       #_frequencies\n       #_(sort-by val)\n       #_reverse))\n</code></pre> <p>Now the <code>-main</code> function will only return the result of the <code>(get-book book-url)</code> function.  To see what each of the other lines do, simply remove the #_ character from the front of an expression and re-evaluate the <code>-main</code> function in the repl</p> <p>Hint In Spacemacs / Emacs, the keybinding C-c C-p show the output in a separate buffer.  Very useful when the function returns a large results set.</p>"},{"location":"thinking-functionally/example-hitchhikers-guide/#off-line-sources-of-hitch-hickers-book-and-common-english-words","title":"Off-line sources of Hitch-hickers book and common English words","text":"<pre><code>(def book (slurp \"./hhgttg.txt\"))\n\n(def common-english-words\n  (-&gt; (slurp \"common-english-words.txt\")\n      (clojure.string/split #\",\")\n      set))\n</code></pre> <p>Original concept from Misophistful: Understanding thread macros in clojure</p> <p>Hint The <code>slurp</code> function holds the contents of the whole file in memory, so it may not be appropriate for very large files.  If you are dealing with a large file, consider wrapping slurp in a lazy evaluation or use Java IO (eg. <code>java.io.BufferedReader</code>, <code>java.io.FileReader.</code>).  See the Clojure I/O cookbook and The Ins &amp; Outs of Clojure for examples.</p>"},{"location":"thinking-functionally/first-class-functions/","title":"First Class functions","text":"<p>Idempotent - given the same input you get the same output</p> <pre><code>(+ 1 2 3 4 5 6 7 8 9 10)\n</code></pre> <p>The <code>range</code> function generates a sequence of numbers and when given arguments it does so from a specific range.  The second number is exclusive, so for 1 to 10 the second argument should be 11.</p> <pre><code>(range 1 11)\n</code></pre> <p>Unfortunately we cant just add the result of a range, because it returns a lazy sequence  So <code>(range)</code> by itself will create an error</p> <pre><code>(+ 1 (range 1 11))\n</code></pre> <p>Using a function called <code>reduce</code> we can calculate a single total value from all the numbers in the collection.</p> <p>The reduce function take 2 arguments, the first is the function to apply to a data structure, the second is the data structure.</p> <pre><code>(reduce + (range 1 11))\n\n(reduce + (1 2 3 4 5 6 7 8 9 10))\n</code></pre>"},{"location":"thinking-functionally/first-class-functions/#note","title":"Note::","text":"<p>Write an expression to add up the numbers from 1 to 10 and return the overall total.</p>"},{"location":"thinking-functionally/first-class-functions/#note_1","title":"Note::","text":"<p>Create an expression to do the same calculation, but without having to write all the numbers.  Hint: consider the functions called range and reduce.</p>"},{"location":"thinking-functionally/function-composition/","title":"Function Composition","text":"<p>We have discussed how functional programs are essentially a number of functions that work together, this is called composition (functional composition).</p> <pre><code>(let [calculated-value (* 10 (reduce +  (map inc (range 5))))]\n  calculated-value)\n</code></pre> <p>This expression is common in the Lisp &amp; Clojure languages.  Occasionally the created expressions can becomes challenging to read.  To overcome this parsing complexity, developers often break down a more complex expression into its parts, extracting code into its own function.</p> <p>Note Brake down the above example into each expression that gives a value</p> <pre><code>(range 5)\n\n(map inc (range 5))\n\n(reduce +  (map inc (range 5)))\n\n(* 10 (reduce +  (map inc (range 5))))\n\n\n;; Additional examples\n\n;; Use a let expression for code that is used more than once in a function\n\n(let [calculated-value (* 10 (reduce +  (map inc (range 5))))]\n  calculated-value)\n\n;; Use defn to define a function for code that multiple functions will call\n;; and generalise the function with arguments\n\n(defn common-data-calculation\n  [certainty-factor scope]\n  (* certainty-factor (reduce +  (map inc (range scope)))))\n</code></pre>"},{"location":"thinking-functionally/functors/","title":"Functors","text":"<p>Fixme work in progress</p> <p>Put simply, a function that takes a value and a function as its arguments, eg <code>map</code>.  The argument pass as a value is most commonly a collection type (vector, map, string, list).</p> <p>From Wikipedia</p> <p>In mathematics, a functor is a type of mapping between categories which is applied in category theory. Functors can be thought of as homomorphisms between categories. In the category of small categories, functors can be thought of more generally as morphisms.</p> <p>A functor applies the given function to each element in the the collection by unpacking and each element from the collection and passing it to the function as an argument.  The result from each application of the function from the element of the collection is put into a new collection.  This new collection is returned once all elements of the original collection have been processed.</p> <p>The function, eg. + is applied in turn to each value and returns a structured value as a result, eg. a list or vector</p> <pre><code>(map inc [1 2 3 4 5])\n\n(inc 1 )\n</code></pre>"},{"location":"thinking-functionally/higher-order-functions/","title":"Higher Order functions","text":"<p>Functions can be used as an arguments to other functions as we have seen in function composition.  This is possible because a function always evaluates to a value.  This is the basis of function composition.</p> <p>Higher Order functions can also return a function definition, as when that function definition is evaluated it to will return a value.</p> <p>You could have a function that returns a function definition which in turn returns a function definition, but at some point this will get very confusing for the developers (yes, that means you).</p> <pre><code>(filter\n even?\n (range 1 10))\n</code></pre> <pre><code>(defn twice [f]\n  ,,,)\n</code></pre> <pre><code>;; Our higher order function\n\n(defn twice [function x]\n  (function (function x)))\n\n(twice\n  (fn [arg]\n    (* 3.14 arg))\n  21)\n;; =&gt; 207.0516\n\n;; using the short syntax for a function definition\n\n(twice #(+ 3.14 %) 21)\n;; =&gt; 207.0516\n</code></pre> <pre><code>(defn calculation [f]\n  ,,,)\n</code></pre> <pre><code>(defn calculation [f]\n  (fn [&amp; args]\n    (reduce f args)))\n\n((calculation +) 1 1 2 3 5 8 13)\n\n;; The result of `(calculation +)` is also in a list,\n;; so it will be called as a function, with the arguments 1 1 2 3 5 8 13\n</code></pre>"},{"location":"thinking-functionally/higher-order-functions/#notereturn-the-even-numbers-from-1-to-10","title":"Note::Return the even numbers from 1 to 10","text":"<p>Generate a range of numbers from 1 to 10</p> <p>Use a function that checks if a number is even and filter the range of numbers to return only the numbers that match</p>"},{"location":"thinking-functionally/higher-order-functions/#notecreate-a-named-function-as-a-higher-order-function-called-twice","title":"Note::Create a named function as a higher order function called <code>twice</code>","text":"<p>The function twice which takes a function and value as arguments.</p> <p>The twice function should call the function passed as an argument on the value passed as an argument.</p> <p>The result should be then used as an argument to calling the function passed as an argument again.</p> <p>Call the twice function with an inline function which takes a number as an argument and adds it to Pi, <code>3.14</code>.</p>"},{"location":"thinking-functionally/higher-order-functions/#notedefine-a-function-that-returns-a-function","title":"Note::Define a function that returns a function","text":"<p>The function should take a clojure.core function for a mathematical calculation, i.e. <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></p> <p>The returning function should take one or more arguments <code>[&amp; args]</code> and use the function originally passed as an argument to <code>reduce</code> the data to a single value.</p>"},{"location":"thinking-functionally/higher-order-functions/#references","title":"References","text":"<ul> <li>Writing Elegant Clojure code using Higher Order functions</li> </ul>"},{"location":"thinking-functionally/homoiconicity/","title":"Homoiconicity","text":"<p>Clojure is a homoiconic language, which is a term describing the fact that Clojure programs are represented by Clojure data structures.</p> <p>In Clojure you write your business logic as functions.  A function is defined using a list structure.  A function is called using a list structure, as the first element of a list is evaluated as a function call.</p> <p>Hint Everything in Clojure is a List (or vector, map, set).</p> <p>This is a very important difference between Clojure (and Common Lisp) and most other programming languages - Clojure is defined in terms of the evaluation of data structures and not in terms of the syntax of character streams/files.</p> <p>It is quite easy for Clojure programs to manipulate, transform and produce other Clojure programs.  This is essentially what macros do in Clojure, they re-write Clojure for you.</p> <p>Hint If you were going to create Skynet, it would be so much easier to do in Clojure</p> <p></p>"},{"location":"thinking-functionally/homoiconicity/#an-example","title":"An example","text":"<p>Consider the following expression:</p> <pre><code>(let [x 1] \n    (inc x))\n</code></pre> <p>Evaluating the above code in the REPL returns <code>2</code> because the repl compiles and executes any code entered into it. But <code>[x 1]</code> is also a literal vector data structure when it appears in a different context.</p> <p>All Clojure code can be interpreted as data in this way. In fact, Clojure is a superset of EDN \u2013 Extensible Data Notation, a data transfer format similar to JSON. EDN supports numbers, strings, lists (1 2 3), vectors [1 2 3], maps {\"key\" \"value\"}.</p> <p>If this sounds and looks a lot like Clojure syntax, it\u2019s because it is. The relationship between Clojure and EDN is similar to that of Javascript and JSON, but much more powerful.</p> <p>In Clojure, unlike JavaScript, all code is written in this data format. We can look at our let statement not as Clojure code, but an EDN data structure. Let\u2019s take a closer look:</p> <pre><code>(let [x 1] \n    (inc x))\n</code></pre> <p>In this data structure, there are four different types of data.</p> <ul> <li>1 is a literal integer.</li> <li>let, x, and inc are symbols. A symbol is an object representing a name \u2013 think a string, but as an atomic object and not a sequence of characters.</li> <li>[x 1] is a vector containing two elements: symbol, x, and an integer, 1. Square brackets always signify vectors when talking about EDN data structures.</li> <li>(inc x) is a list (a linked list data structure) containing two symbols, inc and x.</li> </ul> <p>When thinking about a piece of Clojure code as a data structure, we say we are talking about the form. Clojure programmers don\u2019t normally talk about EDN, there are just two ways to think about any bit of Clojure: 1) as code that will execute or 2) as a form, a data structure composed of numbers, symbols, keywords, strings, vectors, lists, maps, etc.</p> <p>Symbols are particularly important. They are first class names. In Clojure, we distinguish between a variable and the name of that variable. When our code is executing, x refers to the variable established by our let binding. But when we deal with that code as a form, x is just a piece of data, it\u2019s a name, which in Clojure is called a symbol.</p> <p>This is why Clojure is homoiconic. Code forms are data structures and data structures can be thought of as forms and executed as code. This transformation is quite literal, and two core operations, quote and eval are key ingredients to this potion.</p>"},{"location":"thinking-functionally/homoiconicity/#references","title":"References","text":"<ul> <li>The Reader - Clojure. org</li> <li>Homoiconicity - Wikipedia</li> <li>Is Clojure Homoiconic - muhuk.com</li> <li>Understanding Homoiconicity in Clojure - Drew Colthorp</li> </ul>"},{"location":"thinking-functionally/immutability/","title":"Immutability","text":"<p>There is a strong emphasis on immutability in Clojure.  Rather than create variables that change, Clojure uses values that do not change.</p> <p>Values in Clojure include numbers, characters, strings.</p> <p>When functions act on values, a new value is created and returned, rather than modifying the existing value.</p> <p>TODO include a diagram to visualise this...</p>"},{"location":"thinking-functionally/immutability/#immutabile-data-structures","title":"Immutabile data structures","text":"<p>List, Map, Vector and Set are all immutable data structures in Clojure.</p> <p>So when you use these data structures with a function, a new data structure is returned.</p> <p>Hint When a new data structure is created from an existing data structure, then under the covers the two data structures actually share memory use for any elements that are common.  This keeps copies very cheap to create in terms of memory used.</p> <p>See the section on data structures for more details.</p>"},{"location":"thinking-functionally/immutable-collections/","title":"Immutable collections","text":"<p>As we have discussed, immutable data structures cannot be changed.  So when you run a function over a collection a copy of that collection is returned.  Lets see this by running some code in the REPL.</p> <p>Note Define a data structure called <code>numbers</code> using a vector.  Then write a function that uses the <code>map</code> and <code>inc</code> function to increment all the numbers in a vector.</p> <p>Then check the current value of the <code>numbers</code> data structure by evaluating its name.</p> <pre><code>;; define the data structure \n(defn numbers [1 2 3 4 5])\n\n;; increment the numbers\n(map inc numbers)\n\n;; see the current value of numbers\nnumbers\n</code></pre> <p>Note Use the <code>conj</code> function to first add the number <code>5</code> to the <code>numbers</code> vector from the previous exercise and check the value of <code>numbers</code>.  Then add the number <code>6</code> to the <code>numbers</code> vector and check the value of <code>numbers</code>.</p> <p>Finally, use the <code>conj</code> function to add both <code>5</code> and <code>6</code> to the <code>numbers</code> vector and check the value of <code>numbers</code></p> <pre><code>(def numbers [1 2 3 4])\n\n;; add 5 to the numbers vector\n(conj numbers 5)\n\n;; check the value of numbers\nnumbers\n;; =&gt; [1 2 3 4]\n\n;; add 6 to the numbers vector\n(conj numbers 6)\n\n;; check the value of numbers\nnumbers\n;; =&gt; [1 2 3 4]\n\n;; add 5 and 6 to the numbers vector\n(conj numbers 5 6)\n\n;; Alternatively, you can use the threading macro to chain two conj function calls\n(-&gt; numbers\n    (conj 5)\n    (conj 6))\n\n;; check the value of numbers\nnumbers\n;; =&gt; [1 2 3 4]\n</code></pre> <p>So even though we have applied several functions on the <code>numbers</code> data structure it still has the same value.</p>"},{"location":"thinking-functionally/immutable-local-bindings/","title":"Immutable Local Bindings","text":"<p>Names can be bound to values &amp; and data structures with either the <code>def</code> or <code>let</code> function.  The <code>def</code> binding is global to the namespace, however the <code>let</code> function is local to its use.</p> <p>Hint The <code>let</code> function is typically used to define names within a function definition, or in snippets of code created during repl driven development.</p> <pre><code>(let [five 5]\n  (str \"Within the let expression the value is \" five))\n;; =&gt; Within the let expression the value is 5\n\n;; evaluating the name five outside the let expression returns an error\nfive\n;; =&gt; Unable to resolve symbol: five in this context\n</code></pre> <p>Note Create a local binding called number that represents the value 5 using the <code>let</code> function. Increment the number, then print out the value of number.</p> <pre><code>(let [number 5]\n   (inc number)\n   (str \"The number is still \" number))\n</code></pre> <p>So the value that any local binding points to is immutable too.</p>"},{"location":"thinking-functionally/immutable-values/","title":"Immutable values","text":"<p>Fixme work in progress</p> <p>Values in Clojure include numbers, characters and strings.  When you use functions on these values they do not change, instead a new value is returned.</p> <p>Lets look at a simple example with a number:</p> <pre><code>(def two-little-ducks 22)\n\n(inc two-little-ducks)\n;; =&gt; 23\n\ntwo-little-ducks\n;; =&gt; 22\n</code></pre> <p>Another example with a string:</p> <pre><code>(def message \"Strings are immutable\")\n\n(str message \",\" \" \" \"you cant change them\")\n;; =&gt; \"Strings are immutable, you cant change them\"\n\nmessage\n;; =&gt; \"Strings are immutable\"\n</code></pre> <p>Fixme Add an exercise</p>"},{"location":"thinking-functionally/impure-functions/","title":"Impure functions","text":"<p>We have seen some simple examples of pure functions, so lets see impure functions as a comparison.</p> <pre><code>(def global-value '(5 4 3 2 1))\n\n(defn impure-increment-numbers [number-collection]\n  (map inc global-value))\n\n(impure-increment-numbers '(1 2 3 4 5))\n</code></pre> <p>The above function is using a global value rather than the argument passed makes this function deterministic</p>"},{"location":"thinking-functionally/impure-functions/#side-effect-printing-to-the-console-log","title":"Side Effect: Printing to the console log","text":"<p>Although the following example is probably quite harmless, it is a simple example of a function effecting the state of something outside.  These side effects should be avoided where possible to keep your code simpler to reason about.</p> <pre><code>(defn print-to-console [value-to-print]\n  (println \"The value is:\" value-to-print))\n\n(print-to-console \"a side effect\")\n</code></pre>"},{"location":"thinking-functionally/impure-functions/#side-causes-calling-libraries","title":"Side Causes: Calling libraries","text":"<p>To demonstrate a side causes form of impure functions, lets create a task-comple function that marks a current task complete using the current timestamp.</p> <pre><code>(defn task-complete [task-name]\n  (str \"Setting task \" task-name \" completed on \" (js/Date)))\n\n(task-complete \"hack clojure\")\n</code></pre> <pre><code>(:import java.util.Date)\n\n(defn task-complete [task-name]\n  (str \"Setting task \" task-name \" completed on \" (java.util.Date.)))\n\n(task-complete \"hack clojure\")\n</code></pre> <p>In this example we have called to the outside world to generate a value for us.  The above example is fairly simple, however by calling the outside world rather than passing in a date it makes the functions purpose far less clear.</p>"},{"location":"thinking-functionally/impure-functions/#hint-the-function-javautildate-is-actually-a-call-to-instantiate-a-javautildate-object-the-full-stop-character-at-the-end-of-the-name-makes-it-a-function-call-and-is-the-short-form-of-new-javautildate","title":"Hint:: The function <code>(java.util.Date.)</code> is actually a call to instantiate a java.util.Date object.  The full-stop character at the end of the name makes it a function call and is the short form of <code>(new java.util.Date)</code>","text":""},{"location":"thinking-functionally/impure-functions/#re-write-as-a-pure-function","title":"Re-write as a pure function","text":"<p>Change the task-complete function definition and function call to take both the task-name and completed-date as arguments.</p> <pre><code>(defn task-complete [task-name completed-date]\n  (str \"Setting task \" task-name \" completed on \" completed-date))\n\n(task-complete \"hack clojure\" (js/Date))\n</code></pre> <p>Required values should be generated outside a function where possible.  In this case in the <code>(js/Date)</code> function is first evaluated and replaced by its value, then that date value is passed to the function as an argument, keeping the function pure.</p> <p>The pure version of the function in Clojure, using the java.util.Date function.</p> <pre><code>(:import java.util.Date)\n\n(defn task-complete [task-name completed-date]\n  (str \"Setting task \" task-name \" completed on \" completed-date))\n\n(task-complete \"hack clojure\" (java.util.Date.))\n</code></pre>"},{"location":"thinking-functionally/iterate-over-values/","title":"iterate Over Values","text":"<p>This</p> <ul> <li>loop recur</li> <li>reducing functions</li> <li>map apply reduce</li> <li>partition group-by sort-by</li> </ul>"},{"location":"thinking-functionally/iterate-over-values/#hintwork-in-progress","title":"Hint::Work in progress","text":""},{"location":"thinking-functionally/iterate-over-values/#loop-recur","title":"loop recur","text":"<p>loop recur is a very detailed way of defining a way to iterate over values. map, reduce and apply are commonly used abstractions for iterating over values. They simplify the code (once you are comfortable with them)</p> <p>Functions that iterate over values usually treat a string as a sequence of characters.</p>"},{"location":"thinking-functionally/lazy-evaluation/","title":"Lazy Evaluation","text":"<p>Fixme work in progress</p> <p>In the most basic way possible, laziness is the ability to evaluate an expression only when it's actually needed.  Taken further, laziness is also evaluating an expression only to the extent required.</p>"},{"location":"thinking-functionally/lazy-evaluation/#laziness-in-definition","title":"Laziness in definition","text":""},{"location":"thinking-functionally/lazy-evaluation/#laziness-in-evaluation","title":"Laziness in evaluation","text":""},{"location":"thinking-functionally/lazy-evaluation/#laziness-in-partial-evaluation","title":"Laziness in partial evaluation","text":"<p>Clojure is not entirely lazy, only the majority of sequence operations like map, reduce, filter or repeatedly are lazy evaluated.</p> <p>The most common use of laziness are infinite lists or streams. For example, we could define a list of all prime numbers. In case you didn't know, that's a lot of prime numbers (infinitely many).</p> <p>If we would define such list in a language like C++ or Python then the language would try to calculate all prime numbers immediately, which would run literally forever.</p> <p>If we define such list in Haskell or Clojure, then nothing is calculated just yet. As a matter of fact we could happily print out the first 1000 prime numbers from that list without running into a problem. Again, because lazy evaluation only calculates what is really needed, and nothing more.</p>"},{"location":"thinking-functionally/lazy-evaluation/#laziness-in-number-calculation-ratio-type","title":"Laziness in number calculation - Ratio type","text":"<p>Dividing an integer value by another results in a Ratio type if the result would otherwise result in a decimal number.  Clojure only partially evaluates this expression.</p> <pre><code>(/ 22 7)\n</code></pre> <p>We can also just express a value as a ratio.  This works because of the prefix notation of Clojure</p> <pre><code>22/7\n</code></pre> <p>The laziness can be overridden by specifying a precision, eg coercing the result into a specific type</p> <pre><code>(/  22 7.0)\n(double (/ 22 7))\n(float (/ 22 7))\n</code></pre>"},{"location":"thinking-functionally/lazy-evaluation/#making-something-lazy","title":"Making something lazy","text":"<p>The <code>range</code> function returns a sequence of numbers limited by any arguments given when calling the range function.</p> <p>Calling the range function without arguments will force an infinite sequence of numbers to be generated, quickly resulting in an out of memory error in the heap.</p> <p>Instead, we can either pass arguments to the range function that limit the sequence size or wrap the range function in another function</p> <pre><code>(take 7 (range))\n</code></pre> <p>The <code>take</code> function defines how much of a sequence that <code>range</code> should generate.  So we can call range without arguments and it will generate only those numbers in the sequence as specified by <code>take</code>.</p>"},{"location":"thinking-functionally/lazy-evaluation/#references","title":"References","text":"<ul> <li>Being lazy in Clojure - lazily generating monsters</li> </ul>"},{"location":"thinking-functionally/list-comprehension/","title":"List Comprehension","text":"<p>In general terms, list comprehensions should:</p> <ul> <li>be distinct from (nested) for loops and the use of map &amp; filter functions within the syntax of the language.</li> <li>return either a list or an iterator (an iterating being something that returns successive members of a collection, in order),</li> </ul> <p>In Clojure, list comprehension is via the <code>for</code> function.  This is different to the for in other languages as you will see.</p> <pre><code>(for [number [1 2 3]] (* number 2))\n</code></pre> <p>The <code>for</code> function should be read as follows:</p> <p>\"for each number in the collection [1 2 3], apply the function (* number 2)\"</p> <p>Couldn't we just do this with map?  Yes, we could.</p> <pre><code>(map #(* % 2) [1 2 3])\n</code></pre> <p>So why do we need <code>for</code> function?  It really shows its value when you are working with multiple collections</p> <pre><code>(for [number [1 2 3]\n      letter [:a :b :c]]\n  (str number letter))\n</code></pre> <p>Again we could use <code>map</code> function for this as follows</p> <pre><code>(mapcat (fn [number] (map (fn [letter] (str number letter)))))\n</code></pre> <p>So with the <code>for</code> function we can do the same calculation with much easier code to reason about.</p>"},{"location":"thinking-functionally/list-comprehension/#filtering-results-with-predicates","title":"Filtering results with predicates","text":"<p>With the <code>for</code> function we can add a filter on the results by using a predicate, to test if a condition is true or false.  Any values that meet the condition as true are returned, values that are false are omitted.</p> <pre><code>(for [x (range 10) :when (odd? x)] x)\n\n(for [x (range 10) :while (even? x)] x)\n</code></pre> <p>To do this kind of filtering with maps would be possible, however the code would be harder for humans to parse and understand.</p> <p>Note Create a 3-tumbler combination padlock, with each tumbler having a range of 0 to 9. Count the number of possible combinations.  Then add a predicate that filters out some of the combinations</p> <p>Lets just model all the possible combinations</p> <pre><code>(for [tumbler-1 (range 10)\n      tumbler-2 (range 10)\n      tumbler-3 (range 10)]\n [tumbler-1 tumbler-2 tumbler-3])\n</code></pre> <p>Now lets count the combinations</p> <pre><code>(count (for [tumbler-1 (range 10)\n             tumbler-2 (range 10)\n             tumbler-3 (range 10)]\n         [tumbler-1 tumbler-2 tumbler-3]))\n</code></pre> <p>Now add a predicate using <code>:when</code> to filter out the combinations that do not match.</p> <pre><code>(count (for [tumbler-1 (range 10)\n             tumbler-2 (range 10)\n             tumbler-3 (range 10)\n             :when (or (= tumbler-1 tumbler-2)\n                       (= tumbler-2 tumbler-3)\n                       (= tumbler-3 tumbler-1))]\n         [tumbler-1 tumbler-2 tumbler-3]))\n</code></pre> <p>Note Create a 2 character prefix for tickets, using capital letters from the English alphabet.  However, exclude I and O as they can be mistaken for numbers</p> <p>Lets just model all the possible combinations</p> <pre><code>(for [letter-1 capital-letters\n      letter-2 capital-letters\n      :when (and (not (blacklisted letter-1))\n                 (not (blacklisted letter-2)))]\n  (str letter-1 letter-2))\n</code></pre>"},{"location":"thinking-functionally/managing-state-changes/","title":"Managing state changes","text":""},{"location":"thinking-functionally/map-with-partial/","title":"map with partial","text":"<p>Lets look at different ways we can map functions over collections with <code>partial</code></p> <p>We can map over a collection of words and increment them by writing an anonymous function.</p> <pre><code>(map (fn [animal] (str animal \"s\")) [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"])\n</code></pre> <p>The anonymous function has a terse form, that removes the boiler plate function definition <code>(fn [])</code>, allowing definition of only the body of a function.</p> <p><code>%</code> represents a single argument passed to the function.  The <code>%</code> syntax also supports numbers where there are multiple arguments, e.g. <code>%1</code>, <code>%2</code> for the first and second arguments.  <code>%&amp;</code> represents all other arguments and is the same as <code>(fn [&amp; args])</code> or <code>(fn [arg1 &amp; args])</code>.</p> <p>The <code>#</code> character tells the Clojure reader that this is the macro form of a function definition and expands the code to the full form before executing.</p> <pre><code>(map #(str % \"s\") [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"])\n</code></pre>"},{"location":"thinking-functionally/map-with-partial/#hintwhen-to-use-the-terse-form-of-anonymous-function","title":"Hint::When to use the terse form of anonymous function","text":"<p>The terse form is often used with higher order functions, as an argument to a function. If the body of the function is simple to comprehend, then the terse form of anonymous function definition is appropriate.  When the body of a function is more complex, then consider using a separate <code>defn</code> function definition.</p>"},{"location":"thinking-functionally/map-with-partial/#returning-a-vector-instead-of-a-sequence","title":"Returning a Vector instead of a sequence","text":"<p>The <code>map</code> function returns a lazy sequence. This is very useful for large data sets.</p> <p><code>mapv</code> is an eager version of map that returns the result as a vector.  This is useful when you require random access lookup in real time.  <code>mapv</code> can also be used to return an eager result if laziness is not required.</p> <pre><code>(mapv #(str % \"s\") [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"])\n</code></pre>"},{"location":"thinking-functionally/map-with-partial/#hintlists-and-vectors-does-it-matter","title":"Hint::Lists and vectors - does it matter?","text":"<p>Some functions in <code>clojure.core</code> will return a sequence using the list syntax, even if the arguments given are vectors.  Most of the time this is not important, as Clojure considers values rather than constructs for most of its functions. For example, <code>(= (\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\") [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"])</code> is true as the values are compared rather than the type of container (list, vector)</p>"},{"location":"thinking-functionally/map-with-partial/#using-conditionals","title":"Using conditionals","text":"<p>Adding sheep as an element raises a problem, as the plural of sheep is sheep.</p> <p>Using a conditional, a test can be added to determine if a name should be made plural</p> <p>First lets abstract out the anonymous function to a shared function using <code>defn</code></p> <pre><code>(defn pluralise\n  \"Pluralise a given string value\"\n  [animal]\n  (str string \"s\"))\n</code></pre> <p><code>def</code> will bind a name to our collection of animals</p> <pre><code>(def animals [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"])\n\n(map pluralise animals)\n</code></pre> <p>The <code>if</code> function included a conditional test.  If that test is true the next expression is evaluated.  If the test is false, the second expression is evaluated.</p> <pre><code>(defn pluralise\n  \"Pluralise a given string value\"\n  [animal]\n  (if (= animal \"sheep\")\n    animal\n    (str animal \"s\")))\n\n(map pluralise animals)\n</code></pre> <p>There are several animals that do not have a plural form.  Rather than make a complicated test, a collection of animals that are not plural can be defined.</p> <pre><code>(def non-plural-words [\"deer\" \"sheep\" \"shrimp\" ])\n\n(defn pluralise\n  \"Pluralise a given string value\"\n  [animal]\n  (if (some #{animal} non-plural-words)\n    animal\n    (str animal \"s\")))\n\n(def animals [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\" \"sheep\" \"shrimp\" \"deer\"])\n\n(map pluralise animals)\n</code></pre> <p>To keep the function pure, we should pass the non-plural-words as an argument</p> <pre><code>(defn pluralise\n  \"Pluralise a given string value\"\n  [animal non-plural-words]\n  (if (some #{animal} non-plural-words)\n    animal\n    (str animal \"s\")))\n</code></pre> <p>Using the terse form of the anonymous function, <code>#()</code>, call the pluralise function with two arguments.  <code>map</code> will replace the <code>%</code> character with an element from the animals collection for each element in the collection.</p> <pre><code>(map #(pluralise % non-plural-words) animals)\n</code></pre> <p>The <code>partial</code> function can be used instead of creating an anonymous function, removing the need for more custom code.  The order of the arguments must be swapped for <code>partial</code> to call <code>pluralise</code> correctly</p> <pre><code>(defn pluralise\n  \"Pluralise a given string value\"\n  [non-plural-words animal]\n  (if (some #{animal} non-plural-words)\n    animal\n    (str animal \"s\")))\n</code></pre> <p>Now we can call pluralise by wrapping it as a partial function.</p> <p>The argument that is the non-plural-words is constant, its the individual elements of animals I want to get out via map.  So when map runs it gets an element from the animals collection and adds it to the call to pluralise, along with non-plural-words</p> <pre><code>(map (partial pluralise non-plural-words) animals)\n</code></pre> <p>Using partial here is like calling <code>(pluralise non-plural-words ,,,)</code> but each time including an element from animals where the <code>,,,</code> is.</p>"},{"location":"thinking-functionally/map-with-partial/#learning-at-the-repl","title":"Learning at the REPL","text":"<p>At first I was getting incorrect output, <code>[\"deer\" \"sheep\" \"shrimp\"]</code>, then I realised that it was returning the non-plural-words instead of pluralised animals.  The arguments from the partial function were being sent in the wrong order.  So I simply changed the order in the pluralise function and it worked.</p> <p>I checked this by adding some old-fashioned print statement.</p> <pre><code>(defn pluralise-wrong-argument-order\n  \"Pluralise a given string value\"\n  [animal non-plural-words ]\n  (if (some #{animal} non-plural-words)\n    (do\n      (println (str animal \" its true\"))\n      animal)\n    (do\n      (println (str animal \" its false\"))\n      (str animal \"s\"))))\n</code></pre>"},{"location":"thinking-functionally/partial-functions/","title":"Currying &amp; Partial Functions","text":"<p>Clojure does not support automatic currying, (+3) would result in applying + to 3, resulting with number 3 instead of a function that adds 3 as in Haskell. Therefore, in Clojure we use partial that enables the equivalent behavior.</p> <pre><code>(defn sum\n  \"Sum two numbers together\"\n  [number1 number2]\n  (+ number1 number2))\n\n(sum 1 2)\n;; =&gt; 3\n</code></pre> <p>If you try and evaluate <code>sum</code> with a single value then you get an arity exception</p> <pre><code>(sum 1)\n;; =&gt; clojure.lang.ArityException\n;; =&gt; Wrong number of args (1) passed to: functional-concepts/sum\n</code></pre> <p>If we did need to call sum with fewer than the required arguments, for example if we are mapping sum over a vector, then we can use partial to help us call the sum function with the right number of arguments.</p> <p>Lets add the value 2 to each element in our collection</p> <pre><code>(map (partial sum 2) [1 3 5 7 9])\n</code></pre>"},{"location":"thinking-functionally/partial-functions/#using-functions-on-more-arguments-than-they-can-normally-take","title":"Using functions on more arguments than they can normally take","text":"<p>The <code>reduce</code> function can only work on a single collection as an argument (or a value and a collection), so an error occurs if you wish to reduce over multiple collections.</p> <pre><code>(reduce + [1 2 3 4])\n;; =&gt; 10\n\n(reduce + [1 2 3 4] [5 6 7 8])\n;; returns an error due to invalid arguments\n</code></pre> <p>However, by using partial we can take one collection at once and return the result of reduce on each of those collections.</p> <pre><code>(map (partial reduce +) [[1 2 3 4] [5 6 7 8]])\n</code></pre> <p>In the above example we map the partial reduce function over each element of the vector, each element being a collection.</p>"},{"location":"thinking-functionally/partial-functions/#using-partial-to-set-a-default-value","title":"Using partial to set a default value","text":"<p>We can use the partial function to create a default message that can be just given just the custom part.  For example, if we want to have a default welcome message but include a custom part to the message at the end.</p> <p>First we would define a function that combines parts of the message together.</p> <pre><code>(defn join-strings\n  \"join one or more strings\"\n  [&amp; args]\n  (apply str args))\n</code></pre> <p>The [&amp; args] argument string says take all the arguments passed and refer to them by the name args.  Its the &amp; character that has the semantic meaning, so any name after the &amp; can be used, although args is common if there is no domain specific context involved.</p> <p>We can simply call this function with all the words of the message.</p> <pre><code>(join-strings \"Hello\" \" \" \"Clojure\" \" \" \"world\")\n;; \u21d2 \"Hello Clojure world\"\n</code></pre> <p>Now we define a name called <code>wrap-message</code> that can be used to wrap the start of our message.  This name binds to a partial function call to <code>join-strings</code> which send that function the default message and any custom message you add when evaluate <code>wrap-message</code></p> <pre><code>(def wrap-message (partial join-strings \"Hello Clojurians in \"))\n\n(wrap-message)\n;; \u21d2 \"Hello Clojurians in \"\n\n(wrap-message \"London\")\n ;; =&gt; \"Hello Clojurians in London\"\n</code></pre>"},{"location":"thinking-functionally/partial-functions/#currying-in-clojure","title":"Currying in clojure","text":"<p>Currying is the process of taking some function that accepts multiple arguments, and turning it into a sequence of functions, each accepting a single argument.  Or put another way, to transform a function with multiple arguments into a chain of single-argument functions.</p> <p>Currying relies on having fixed argument sizes, whereas Clojure gets a lot of flexibility from variable argument lengths (variable arity).</p> <p>Clojure therefore has the partial function gives results similar to currying, however the <code>partial</code> function also works with variable functions.</p> <p><code>partial</code> refers to supplying some number of arguments to a function, and getting back a new function that takes the rest of the arguments and returns the final result</p> <p>One advantage of <code>partial</code> is to avoid having to write your own anonymous functions</p>"},{"location":"thinking-functionally/partial-functions/#useful-references","title":"Useful references","text":"<ul> <li>Partial function applications for humans</li> </ul>"},{"location":"thinking-functionally/pattern-matching/","title":"Pattern matching","text":"<p>Fixme work in progress</p>"},{"location":"thinking-functionally/pattern-matching/#regular-expression","title":"Regular Expression","text":""},{"location":"thinking-functionally/pattern-matching/#destructuring","title":"Destructuring","text":""},{"location":"thinking-functionally/persistent-data-structures/","title":"Persistent data structures","text":""},{"location":"thinking-functionally/polymorphism/","title":"Polymorphic function definitions","text":"<p>Polymorphic means many forms.</p> <p>The simplest example of polymorphism in Clojure is a function definition that acts differently based on the number of arguments passed.</p> <p>Usually you define a function with one set of arguments, either none <code>[]</code>, one <code>[one]</code> or many <code>[any number of args]</code>, using the basic syntax</p> <pre><code>(defn name\n\"I am the doc string to describe the function\"\n  [args]\n  (str \"define your behaviour here\"))\n</code></pre> <p>Instead of writing multiple functions with the same name that each take different numbers of arguments, you can use the following polymorphic syntax in Clojure</p> <pre><code>(defn name\n  \"I am the doc string to describe the function\"\n  ([]\n    (str \"behaviour with no args\"))\n  ([one]\n    (str \"behaviour with one arg\"))\n  ([one two &amp; args]\n    (str \"behaviour with multiple args\")))\n</code></pre> <p>Note Write a simple function called <code>i-am-polly</code> that returns a default message when given no arguments and a custom message when given a custom string as an argument</p> <pre><code>(defn i-am-polly\n  ([] (i-am-polly \"My name is polly\"))\n  ([message] (str message)))\n\n(i-am-polly)\n(i-am-polly \"I call different behaviour depending on arguments sent\")\n</code></pre>"},{"location":"thinking-functionally/pure-functions/","title":"Pure functions","text":"<p>A function is considered pure if does not side effects or is affected by side causes.  A pure function does not change any other part of the system and is not affected by any other part of the system.</p> <p>When you pass arguments to a function and that function returns a value without interacting with any other part of the system, then that function is considered pure.</p> <p>Should something from outside a function be allowed to affect the result of evaluating a function, or if that function be allowed to affect the outside world, then its an impure function.</p> <p></p> <p>So lets look at a simple code example</p> <pre><code>(defn add-numbers [number1 number2]\n  (+ number1 number2))\n\n(add-numbers 1 2)\n</code></pre> <p>Lets look at each line of this suggested answer</p> <pre><code>;; function takes 2 arguments\n;; function uses both arguments for result\n(defn add-numbers [number1 number2]\n  (+ number1 number2))\n\n;; specific values are passed as arguments\n(add-numbers 1 2)\n</code></pre>"},{"location":"thinking-functionally/pure-functions/#notewrite-a-pure-function-that-adds-two-numbers-together","title":"Note::Write a pure function that adds two numbers together ?","text":""},{"location":"thinking-functionally/pure-functions/#an-example-with-map","title":"An example with map","text":"<p>Note Define a collection called numbers and write a named function that increments each number of the numbers collection. Is your function pure or impure ?</p> <pre><code>(def numbers '(5 4 3 2 1))\n\n(defn increment-numbers []\n  (map inc numbers))\n\n(increment-numbers)\n</code></pre> <p>The function takes no arguments and is pulling in a value from outside the function.  This is a trivial example, but if all your code is like this it would be more complex.  If the value pointed to by <code>numbers</code> is mutable and changes before the <code>increment-numbers</code> function is called then you will get different results.</p> <p>Here is a Pure function example</p> <pre><code>(def numbers '(5 4 3 2 1))\n\n(defn increment-numbers [number-collection]\n  (map inc number-collection))\n\n(increment-numbers numbers)\n</code></pre> <p>In this example we are explicitly passing the <code>numbers</code> collection to the function.  The function works on passed value and returns a predictable result.</p>"},{"location":"thinking-functionally/recursion-polymorphism/","title":"Recursion &amp; Polymorphism","text":"<p>Fixme work in progress</p> <p>The following <code>sum</code> function will calculate the value of adding all the elements in a collection.  You can alter the results by adding a starting value to the calculation as a second argument when calling <code>sum</code></p> <pre><code>(defn sum\n  ([vals] (sum vals 0))\n  ([vals accumulating-total]\n    (if (empty? vals)\n      accumulating-total\n      (sum (rest vals) (+ (first vals) accumulating-total)))))\n\n(sum [2 7 9 11 13])\n(sum [1])\n(sum [2 7 9 11 13] 9)\n</code></pre> <p>Rather than duplicate the calculation, the behaviour of calling <code>sum</code> with just a collection simply calls <code>sum</code> again, this time passing a starting value of zero.</p>"},{"location":"thinking-functionally/recursion/","title":"Recursion","text":"<p>Fixme work in progress</p> <p>Recursion is used greatly in Clojure to iterate through data and as anything can be treated as data in Clojure you can understand why.</p> <p>The constructs available in Clojure for recursion include</p> <ul> <li><code>loop</code> and <code>recur</code></li> <li>Named function that calls itself</li> <li><code>map</code>, <code>reduce</code>, <code>filter</code>, <code>remove</code>, etc.</li> <li><code>for</code></li> </ul>"},{"location":"thinking-functionally/recursion/#recursively-calling-the-same-function","title":"Recursively calling the same function","text":"<p>Lets iterate though a collection using recursion by writing a function that calls itself</p> <pre><code>(defn recursively-use-a-collection [collection]\n  (println (first collection))\n  (if (empty? collection)\n    (print-str \"no more values to process\")\n    (recursively-use-a-collection  (rest collection))))\n\n(recursively-use-a-collection [1 2 3])\n</code></pre> <p>Lets take this recursive approach to create a function that can tell us the length of a collection (list or vector)</p> <p>We define a function that takes a collection of an argument.  The collection is tested to see if it is empty and if so a zero value is returned.  If the collection is not empty, then we</p> <pre><code>(defn length [collection]\n  (if (empty? collection)\n    0\n    (+ 1 (length (rest collection)))))\n;; =&gt; #'clojure-through-code.01-basics/length\n</code></pre> <p>If we call the <code>length</code> function with an empty collection, then the <code>empty?</code> condition will return true and the <code>if</code> expression will evaluate the first expression, 0, returning 0.</p> <pre><code>(length [])\n;; =&gt; 0\n</code></pre> <p>If we call the <code>length</code> function with a collection containing 3 values, then the <code>empty?</code> function will return <code>false</code> and the <code>if</code> function will evaluate the second expression.</p> <p>The second expression starts with a simple counter, using the <code>+</code> function and the value one</p> <pre><code>(length [0 1 2])\n;; =&gt; 3\n</code></pre> <pre><code>(+ 1 (length [1 2]))\n(+ 1 (+ 1 (length [2])))\n(+ 1 (+ 1 (+ 1 (length []))))\n(+ 1 (+ 1 (+ 1 0)))\n\n(length (range 24))\n;; =&gt; 24\n</code></pre> <p>(defn length [collection]   (kk))</p>"},{"location":"thinking-functionally/recursion/#further-recursion-examples","title":"Further recursion examples","text":"<p>Other functions to consider</p> <ul> <li>every</li> <li>accumulating / accumulative</li> <li>keep</li> </ul>"},{"location":"thinking-functionally/sequence-abstractions/","title":"Sequence abstraction","text":"<p>Fixme work in progress</p> <pre><code>(first '(1 2 3 4 5))\n(rest '(1 2 3 4 5))\n(last '(1 2 3 4 5))\n</code></pre> <pre><code>(defn nth [items n]\n (if (= n 0)\n   (first items)\n   (recur (rest items) (- n 1))))\n\n(define squares '(0 1 4 9 16 25))\n\n(nth squares 3)\n</code></pre>"},{"location":"thinking-functionally/sequences/","title":"Sequences","text":"<p>Fixme work in progress</p> <p>Data structures can be built by combining functions</p> <pre><code>(cons 1 (cons 2  (cons 3  (cons 4  nil))))\n</code></pre> <pre><code>(-&gt;&gt;\n nil\n (cons 4)\n (cons 3)\n (cons 2)\n (cons 1))\n</code></pre>"},{"location":"thinking-functionally/side-effects/","title":"Side effects","text":"<p>A side effect is something that creates a change outside of the current code scope, or something external that affects the behaviour or result of executing the code in the current scope.</p>"},{"location":"thinking-functionally/side-effects/#nondeterministic-the-complexity-iceberg","title":"Nondeterministic - the complexity iceberg","text":"<p>When you have side effects, you cannot reason accurately about a piece of the code.</p> <p>In order to understand a piece of code you must look at all possible side effects created in all lines of code to ensure you fully understand the result of executing your code.</p> <p>With side effects in your system, complexity is hidden, causing a far greater risk of a dangerous situation.</p>"},{"location":"thinking-functionally/side-effects/#side-causes-side-effects","title":"Side causes - side effects","text":"<p>You can think about these effects is in two specific areas, Side Causes and Side Effects</p> <ul> <li> <p>Side Causes - are where other pieces of code (function) or state change affects the behaviour of a function.</p> </li> <li> <p>Side Effects - are where the current code (function) affects the rest of the system</p> </li> </ul> <p></p>"},{"location":"thinking-functionally/side-effects/#hintside-causes-term","title":"Hint::Side Causes term","text":"<p>The term of side causes was coined by Kris Jenkins in the superb article What is Functional Programming?</p>"},{"location":"thinking-functionally/tail-recursion/","title":"Tail recursion","text":"<p>Fixme work in progress</p> <p>If we generate a very large collection we run the risk of blowing our heap space.  For example we could use range to generate a very large collection, say a vector containing 10 billion values</p> <p>Don't try this example below</p> <pre><code>(vec (range 0 9999999999))\n;; this will crash after a short while as it will use up all your heap space\n</code></pre> <p>Using tail call optimisation (tail recursion) allows us to reuse a memory location when we call a function recursively.  This tail recursion is not part of the underlying Java Virtual Machine (JVM), so instead Clojure has a specific function called <code>recur</code></p> <p>The <code>recur</code> function allows the processing of a very large data set without blowing the heap space because the memory space will be reused.</p> <p>The <code>recur</code> function must be the last expression in order to work.</p> <pre><code>(defn sum\n  ([vals] (sum vals 0))\n  ([vals accumulating-total]\n   (if (empty? vals)\n     accumulating-total\n     (recur (rest vals) (+ (first vals) accumulating-total)))))\n\n(sum (vec (range 0 9999999)))\n</code></pre>"},{"location":"thinking-functionally/threading-macros/","title":"Threading macros","text":"<p>The thread-first <code>-&gt;</code> and thread-last <code>-&gt;&gt;</code> macros allow Clojure code to be written in a more sequential style and with a more terse syntax.  This can sometimes make code easier to understand by humans.</p> <p>Using the thread-first macro, <code>-&gt;</code>, the result of the first evaluation is passed as the first argument to the next function and so on.</p> <p>```clojure (-&gt;  (clojure.string/lower-case \"HELLO\")  (str \", Clojure world\")) <pre><code>The value hello is converted to lower case and that result is passed as the first argument to the next function.  The string function is then evaluated with this new argument and the final \"hello, Clojure world\" string is returned as the result.\n\n  The thread-last macro `-&gt;&gt;` passes the result of the first evaluation as the **last argument** to the next expression.\n\n```clojure\n(-&gt;&gt;  \" this\"\n (str \" is\")\n (str \" backwards\"))\n</code></pre></p>"},{"location":"thinking-functionally/threading-macros/#hintparens-optional","title":"Hint::Parens optional","text":"<p>function calls that only take one argument, the one passed by earlier expressions, can be included in the threading macro code without the surrounding <code>()</code> parens.</p>"},{"location":"thinking-functionally/threading-macros/#reading-clojure-code","title":"Reading Clojure code","text":"<p>To read Clojure it is common to start from the inside out, as this is how the Clojure reader also works.  This style is inherited from Lisp of which Clojure is an implementation.</p> <p>The following code is written in classic Lisp style.</p> <pre><code>(reverse\n  (sort-by val (frequencies\n                 (remove common-english-words\n                   (map #(clojure.string/lower-case %)\n                        (re-seq #\"[a-zA-Z0-9|']+\"\n                                (slurp book.txt)))))))\n</code></pre> <p>Reading inside out:</p> <ol> <li>slurp in the contents of the book.txt file, converting it to a string.</li> <li>use a regular expression to create a new sequence where the book is a sequence of individual strings for each word.</li> <li>convert each string in the sequence by mapping the lower-case function over each element of the sequence.</li> <li>remove common english words such as the and and from the sequence.</li> <li>count how many times each word occurs and pair the string with its frequency in the book.</li> <li>reverse the order of the sequence by the value of frequency, so the most used word is at the start of the sequence.</li> </ol> <p>This function uses the var <code>common-english-words</code> which is defined as:</p> <pre><code>(def (set\n       (clojure.string/split (slurp \"common-english-words.txt\") #\",\" )))\n</code></pre> <p>This takes a comma separated file of words and splits them.  The words are put into a set so only one instance of each word is included.</p>"},{"location":"thinking-functionally/threading-macros/#rewriting-the-code-with-threading-macros","title":"Rewriting the code with threading macros","text":"<pre><code>(-&gt;&gt; (slurp book.txt)\n     (re-seq #\"[a-zA-Z0-9|']+\" ,,,)\n     (map #(clojure.string/lower-case %))\n     (remove common-english-words)\n     frequencies\n     (sort-by val)\n     reverse)\n</code></pre> <p><code>frequencies</code> and <code>reverse</code> only take one argument, so they do not require surrounding <code>()</code> inside the threading macro.</p> <p>The common-english-words var is fairly easy to read, so probably doesn't need to be written using a threading macro, however, for completeness here is a thread-first example.</p> <pre><code>(def common-english-words\n  (-&gt; (slurp \"common-english-words.txt\")\n      (clojure.string/split #\",\")\n      set))\n</code></pre>"},{"location":"thinking-functionally/threading-macros/#hintmacroexpand","title":"Hint::Macroexpand","text":"<p>use <code>macroexpand-1</code> around the threading macro code to show resulting lisp style Clojure code.  Clojure editors also provide evaluation functions that will macroexpand.</p>"},{"location":"thinking-functionally/transducers/","title":"Transducers","text":"<p>In Clojure everything is a value, as even a function is a value potential which returns that value when evaluated.</p> <p>Transducers provide an efficient way to transform values which can be simple values, collections, core.async channels and java.jdbc (0.7.0 upwards).</p> <p>https://www.youtube.com/watch?v=WkHdqg_DBBs</p>"},{"location":"thinking-functionally/transducers/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>A very messy brain dump of ideas to tidy up. Pull requests are welcome</p>"},{"location":"thinking-functionally/transducers/#from-slack-beginners-channel","title":"From slack - beginners channel","text":"<p>Transducers are a functional design to compose operations on data collections, whereby the operations you describe through your transducers, aren't applied each on the entire input collection as in normal plain clojure code, but rather every element in the collection gets acted upon by a composition of what you specify in your transducers. Meaning, the input collection gets walked only once!</p> <p>Transducers provide an alternative way to act on data collections, which requires of you to stray from the plain clojure API you'd normally would, but brings along some benefits like lazy evaluation and/or different performance trade-offs.</p> <p>In addition, some advantages in terms of affording greater modularity in applying transformations on  data, are mentioned in the linked SO question above \u2015 although not really well elucidated in code examples there.</p> <p>Using Transducers eliminates the need for intermediate structures.</p> <p>A walk through the basics of Transducers</p> <p>Items coming from a collection are a common case with transducers, but a big motivation for making transducers was the ability to apply transformation directly to the source of data, without forcing it into a collection first (eg. a core.async channel or a network stream etc.)</p> <p>the fact that you can chain transducing functions without intermediate collections comes from this - the context of another transducer is one of the data sources you can apply a transducer to</p> <p>you can use (map f), as one example of a transducing function, directly on a channel</p> <p>it's an optional arg when you create the channel, and causes that transform to be applied to all data that goes through the channel</p> <p>channels are part of why transducers were added to Clojure. The Clojure maintainers discovered they were re-implementing filter, map, partition, etc. etc. on core.async and realized it would be better to have an abstraction for the transforms independent of the source and destination of data</p> <p>As of <code>java.jdbc</code> 0.7.0-beta1, you can also apply transducers to \u201creducible queries\u201d (and reducible result sets).</p> <p>Instead of passing in functions to transform rows and process the transformed result set, you can now just create a \u201creducible query\u201d and hand it off to anything that knows how to reduce it: reducers, transducers, plain ol\u2019 <code>reduce</code> and <code>into</code> etc\u2026</p>"},{"location":"thinking-functionally/transducers/#from-stackoverflow","title":"from stackoverflow","text":"<p>https://stackoverflow.com/questions/26317325/can-someone-explain-clojure-transducers-to-me-in-simple-terms</p> <p>Transducers are recipes what to do with a sequence of data without knowledge what the underlying sequence is (how to do it). It can be any seq, async channel or maybe observable.</p> <p>They are composable and polymorphic.</p> <p>The benefit is, you don't have to implement all standard combinators every time new data source is added. Again and again. As resulting effect you as user are able to reuse those recipes on different data sources.</p> <p>Ad Update</p> <p>Prior version 1.7 of Clojure you had three ways how to write dataflow queries:</p> <p>nested calls</p> <pre><code>(reduce + (filter odd? (map #(+ 2 %) (range 0 10))))\n</code></pre> <p>functional composition</p> <pre><code>(def xform\n  (comp\n    (partial filter odd?)\n    (partial map #(+ 2 %))))\n  (reduce + (xform (range 0 10)))\n</code></pre> <p>threading macro</p> <pre><code>    (defn xform [xs]\n      (-&gt;&gt; xs\n           (map #(+ 2 %))\n           (filter odd?)))\n    (reduce + (xform (range 0 10)))\n</code></pre> <p>With transducers you will write it like:</p> <pre><code>(def xform\n  (comp\n    (map #(+ 2 %))\n    (filter odd?)))\n(transduce xform + (range 0 10))\n</code></pre> <p>They all do the same. The difference is that you never call Transducers directly, you pass them to another function. Transducers know what to do, the function that gets transducer knows how. The order of combinators is like you write it with threading macro (natural order). Now you can reuse xform with channel:</p> <pre><code>(chan 1 xform)\n</code></pre>"},{"location":"thinking-functionally/transducers/#business-case","title":"Business case","text":"<p>Transducers seem to be a useful way of abstracting over various forms of iterable objects. These can be non-consumable, such as Clojure seqs, or consumable (such as async channels). In this respect, it seems to me you would benefit greatly from using transducers if, e.g., you switch from a seq-based implementation to a core.async implementation using channels. Transducers should allow you to keep the core of your logic unchanged. Using traditional sequence-based processing you would have to convert this to use either transducers or some core-async analog. That's the business case</p> <p>Transducers improve efficiency, and allow you to write efficient code in a more modular way.</p> <p>Trivial examples of using Clojure Transducers</p> <p>Compared to composing calls to the old map, filter, reduce etc. you get better performance because you don't need to build intermediate collections between each step, and repeatedly walk those collections.</p> <p>Compared to reducers, or manually composing all your operations into a single expression, you get easier to use abstractions, better modularity and reuse of processing functions.</p> <p>Just curious, you said above: \"to build intermediate collections between each step\". But doesn't \"intermediate collections\" sound like an anti-pattern? .NET offers lazy enumerables, Java offers lazy streams or Guava-driven iterables, lazy Haskell must have something lazy too. None of these requires map/reduce to use intermediate collections because all of them build an iterator chain. Where am I wrong here? \u2013 Lyubomyr Shaydariv Oct 11 '14 at 21:01 1 Clojure map and filter create intermediate collections when nested. \u2013 noisesmith Oct 11 '14 at 22:59 2 And at least regarding Clojure's version of laziness, the issue of laziness is orthogonal here. Yes, map and filter are lazy, the also generate containers for lazy values when you chain them. If you don't hold onto the head, you don't build up large lazy sequences that aren't needed, but you still build those intermediate abstractions for each lazy element. \u2013 noisesmith Oct 12 '14 at 0:59</p> <p>An example would be nice. \u2013 Zubair Oct 13 '14 at 6:56 2 @LyubomyrShaydariv By \"intermediate collection\", noisesmith doesn't mean \"iterate/reify an entire collection, then iterate/reify another entire collection\". He or she means that when you nest function calls that return sequentials, each function call results in the creation of a new sequential. The actual iteration still only happens once, but there is additional memory consumption and object allocation due to the nested sequentials</p> <p>Transducers are a means of combination for reducing functions.</p> <p>Example: Reducing functions are functions that take two arguments: A result so far and an input. They return a new result (so far). For example +: With two arguments, you can think of the first as the result so far and the second as the input.</p> <p>A transducer could now take the + function and make it a twice-plus function (doubles every input before adding it). This is how that transducer would look like (in most basic terms):</p> <p>(defn double   [rfn]   (fn [r i]     (rfn r (* 2 i)))) For illustration substitute rfn with + to see how + is transformed into twice-plus:</p> <p>(def twice-plus ;; result of (double +)   (fn [r i]     (+ r (* 2 i))))</p> <p>(twice-plus 1 2)  ;-&gt; 5 (= (twice-plus 1 2) ((double +) 1 2)) ;-&gt; true So</p> <p>(reduce (double +) 0 [1 2 3]) would now yield 12.</p> <p>Reducing functions returned by transducers are independent of how the result is accumulated because they accumulate with the reducing function passed to them, unknowingly how. Here we use conj instead of +. Conj takes a collection and a value and returns a new collection with that value appended.</p> <p>(reduce (double conj) [] [1 2 3]) would yield [2 4 6]</p> <p>They are also independent of what kind of source the input is.</p> <p>Multiple transducers can be chained as a (chainable) recipe to transform reducing functions.</p> <p>Update: Since there now is an official page about it, I highly recommend to read it: http://clojure.org/transducers</p> <p>Say you want to use a series of functions to transform a stream of data. The Unix shell lets you do this kind of thing with the pipe operator, e.g.</p> <p>cat /etc/passwd | tr '[:lower:]' '[:upper:]' | cut -d: -f1| grep R| wc -l (The above command counts the number of users with the letter r in either upper- or lowercase in their username). This is implemented as a set of processes, each of which reads from the previous processes's output, so there are four intermediate streams. You could imagine a different implementation that composes the five commands into a single aggregate command, which would read from its input and write its output exactly once. If intermediate streams were expensive, and composition were cheap, that might be a good trade-off.</p> <p>The same kind of thing holds for Clojure. There are multiple, concise ways to express a pipeline of transformations, but depending on how you do it, you can end up with intermediate streams passing from one function to the next. If you have a lot of data, it's faster to compose those functions into a single function. Transducers make it easy to do that. An earlier Clojure innovation, reducers, let you do that too, but with some restrictions. Transducers remove some of those restrictions.</p> <p>So to answer your question, transducers won't necessarily make your code shorter or more understandable, but your code probably won't be longer or less understandable either, and if you're working with a lot of data, transducers can make your code faster.</p> <p>https://bendyworks.com/transducers-clojures-next-big-idea/</p> <p>Ah, so transducers are mostly a performance optimisation, is that what you are saying? \u2013 Zubair Oct 13 '14 at 9:10</p> <p>@Zubair Yes, that's right. Note that the optimization goes beyond eliminating intermediate streams; you may also be able to perform operations in parallel. \u2013 user100464 Oct 14 '14 at 19:17</p> <p>It's worth mentioning pmap, which doesn't seem to get enough attention. If you are mapping an expensive function over a sequence, making the operation parallel is as easy as adding \"p\". No need to change anything else in your code, and it's available now--not alpha, not beta. (If the function creates intermediate sequences, then transducers might be faster, I would guess.) \u2013 Mars Oct 30 '14 at 15:13</p> <p>Rich Hickey gave a 'Transducers' talk at the Strange Loop 2014 conference (45 min).</p> <p>He explains in simple way what transducers are, with real world examples - processing bags in an airport. He clearly separates the different aspects and contrasts them with the current approaches. Towards the end, he gives the rationale for their existence.</p> <p>Video: https://www.youtube.com/watch?v=6mTbuzafcII</p> <p>5 down vote A transducer clear definition is here:</p> <p>Transducers are a powerful and composable way to build algorithmic transformations that you can reuse in many contexts, and they\u2019re coming to Clojure core and core.async. To understand it, let's consider the following simple example:</p> <p>;; The Families in the Village</p> <p>(def village   [{:home :north :family \"smith\" :name \"sue\" :age 37 :sex :f :role :parent}    {:home :north :family \"smith\" :name \"stan\" :age 35 :sex :m :role :parent}    {:home :north :family \"smith\" :name \"simon\" :age 7 :sex :m :role :child}</p> <p>{:home :south :family \"jones\" :name \"jill\" :age 45 :sex :f :role :parent}    {:home :south :family \"jones\" :name \"jeff\" :age 45 :sex :m :role :parent}    {:home :south :family \"jones\" :name \"jackie\" :age 19 :sex :f :role :child}    {:home :south :family \"jones\" :name \"jason\" :age 16 :sex :f :role :child}</p> <p>{:home :west :family \"brown\" :name \"billie\" :age 55 :sex :f :role :parent}    {:home :west :family \"brown\" :name \"brian\" :age 23 :sex :m :role :child}</p> <p>{:home :east :family \"williams\" :name \"walter\" :age 23 :sex :m :role :parent}    {:home :east :family \"williams\" :name \"wanda\" :age 3 :sex :f :role :child}]) What about it we want to know how many children are in the village? We can easily find it out with the following reducer:</p> <p>;; Example 1a - using a reducer to add up all the mapped values</p> <p>(def ex1a-map-children-to-value-1 (r/map #(if (= :child (:role %)) 1 0)))</p> <p>(r/reduce + 0 (ex1a-map-children-to-value-1 village)) ;;=&gt; 8 Here is another way to do it:</p> <p>;; Example 1b - using a transducer to add up all the mapped values</p> <p>;; create the transducers using the new arity for map that ;; takes just the function, no collection</p> <p>(def ex1b-map-children-to-value-1 (map #(if (= :child (:role %)) 1 0)))</p> <p>;; now use transduce (c.f r/reduce) with the transducer to get the answer (transduce ex1b-map-children-to-value-1 + 0 village) ;;=&gt; 8 Besides, it is really powerful when taking subgroups in account as well. For instance, if we would like to know how many children are in Brown Family, we can execute:</p> <p>;; Example 2a - using a reducer to count the children in the Brown family</p> <p>;; create the reducer to select members of the Brown family (def ex2a-select-brown-family (r/filter #(= \"brown\" (string/lower-case (:family %)))))</p> <p>;; compose a composite function to select the Brown family and map children to 1 (def ex2a-count-brown-family-children (comp ex1a-map-children-to-value-1 ex2a-select-brown-family))</p> <p>;; reduce to add up all the Brown children (r/reduce + 0 (ex2a-count-brown-family-children village)) ;;=&gt; 2</p>"}]}